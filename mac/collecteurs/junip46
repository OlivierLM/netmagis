#! /usr/local/bin/tclsh8.4


#
# Collecte la table arp et les voisins ipv6 d'un routeur juniper
#

package require Tnm
namespace import Tnm::*

# Community String par defaut
set conf(community) "communaute-snmp"

# 
# Collecte la table ARP
#
# entree :
#       addr      : adresse ip de l'equipement reseau
#       community : community string snmp
# sortie : 
#       liste de couple adresse mac - adresse ip
#
proc collecte-arp {addr community} {

    # Crée la session SNMP
    if { [catch {snmp generator -address $addr -community $community} s ] } {
        puts stderr "Impossible de créer la session SNMP pour $addr"
        return 0
    }

    # Les colonnes de la table SNMP ipNetToMedia à récupérer
    set vbl [list \
            IP-MIB!ipNetToMediaNetAddress \
            IP-MIB!ipNetToMediaPhysAddress 
        ]
    # Récupère la table arp
    $s walk x $vbl {
        set v      [snmp value $x]
        set ip     [lindex $v 0]
        set mac    [lindex $v 1]
        puts [string tolower "$ip $mac"]
    }
    
    return 1

}

#
# Collecte des voisins IPv6 sur un juniper via ssh
# On passe par xml pour simplifier le décodage
#
# En entree (arg. sur la ligne de commande)
# - nom ou adresse ip du routeur
#
# En sortie (sortie standard)
# - lignes de la forme suivante :
# adresseIPv6 adresseMAC
#

package require xml
set conf(user)     "v6view"
set conf(cmd)      "show ipv6 neighbor | display xml"

proc collecte-v6neigh {router} {
    global conf
    global clef entree

    # Initialisations 
    set clef ""
    array set entree {}

    set parser [::xml::parser \
	-elementstartcommand debutelem \
	-elementendcommand finelem \
	-characterdatacommand donnee \
    ]

    set r [catch {
	$parser parse [exec ssh "$conf(user)@$router" $conf(cmd)]
	} msg
    ]

    if {$r != 0} {
	puts stderr "Erreur de collecte : $msg"
	return 0
    }

    return 1
}

#
# Callbacks XLM
#
proc debutelem {nom attlist args} {
    global entree clef

    switch -exact $nom {
	"ipv6-nd-entry"               { array unset entree }
	"ipv6-nd-neighbor-address"    { set clef "ip"       }
	"ipv6-nd-neighbor-l2-address" { set clef "mac"      }
    }
}
proc finelem {nom} {
    global entree

    switch -exact $nom {
    	"ipv6-nd-entry" {
	    if { ![info exists entree(ip)]} {
		puts stderr  "Erreur : adresse ip non trouvée"
		return
	    }
	    if { ![info exists entree(mac)]} {
		puts stderr "Erreur : adresse mac non trouvée"
		return
	    }
	    if { ! [string equal $entree(mac) "none"]} {
		puts [string tolower "$entree(ip) $entree(mac)"]
	    }
	}
    }
}
proc donnee {valeur} {
    global entree clef

    if { [string length $clef] > 0 } {
    	set entree($clef) [string trim $valeur]
	set clef ""
    }
}

#
# Programme principal
#
proc main {argv0 argv} {
    global conf

    if {[llength $argv] != 1} then {
        puts stderr "$argv0 <hostname>"
        return 1
    }

    # Equipement sur lequel on se connecte
    set host     [lindex $argv 0]

    set r  [collecte-arp $host $conf(community)]

    set r2 [collecte-v6neigh $host]
    
    if {$r && $r2} {
        return 0
    } else {
        return -1
    }
}

exit [main $argv0 $argv]
