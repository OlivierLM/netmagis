#!%TCLSH%

#
# Display mail host of a mail address (or list of existing mail addresses)
#
# Called by: mail
#
# Parameters (form or url):
#   - nom : name (first component of fqdn) of mail address (or empty)
#   - domaine : domain (last components of fqdn) of mail address
#
# History
#   2004/02/06 : pda/jean : design
#   2010/12/13 : pda      : i18n
#

#
# Template pages used by this script
#

set conf(err)		erreur.html
set conf(pageliste)	mailheberg-liste.html
set conf(pageedit)	mailheberg-edit.html

#
# Next actions
# 

set conf(nextheberg)	"%HOMEURL%/bin/mailheberg"
set conf(nextmodif)	"%HOMEURL%/bin/mailmodif"

#
# Script parameters
#

set conf(form)		{
	{nom		1 1}
	{domaine	1 1}
}

#
# Tabular format
# Columns :
#	- mail address
#	- mail host
#

set conf(tableau) {
    global {
	chars {12 normal}
	columns {50 50}
	botbar {yes}
	align {left}
    }
    pattern Title {
	title {yes}
	topbar {yes}
	chars {bold}
	align {center}
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
    }
    pattern Normal {
	title {yes}
	topbar {yes}
	vbar {yes}
	column {
	    format {raw}
	}
	vbar {yes}
	column { }
	vbar {yes}
    }
}

#
# WebDNS general library
#

source %LIBDNS%

# ::webapp::cgidebug ; exit

##############################################################################
# Utility functions
##############################################################################

#
# Read all "role mail" associated with a group and a domain. If name
# if supplied, only role associated with the specified address is returned.
#
# Input:
#   - dbfd : database handle
#   - idcor : user id
#   - name : name (first component) of mail address
#   - domain : domain name (last components) of mail address
# Output:
#   - return value: list {{namea domaina nameh domainh} ...} where:
#	    - namea : name of mail address
#	    - domaina : domain of mail address
#	    - nameh : name of mail host
#	    - domainh : domain of mail host
#
# History
#   2004/02/06 : pda/jean : design
#   2004/02/27 : pda/jean : use user id
#   2004/03/01 : jres     : what a beautiful sql request!
#

proc read-mailrole {dbfd idcor name domain} {
    if {$name ne ""} then {
	set name " AND r1.nom = '$name' "
    }
    set sql "
	SELECT r1.nom AS namea, d1.nom AS domaina,
		r2.nom AS nameh, d2.nom AS domainh
	    FROM dns.role_mail, global.corresp,
		dns.rr r1, dns.domaine d1, dns.rr r2, dns.domaine d2
	    WHERE corresp.idcor = $idcor
		$name
		AND role_mail.idrr = r1.idrr
		AND r1.iddom = d1.iddom
		AND d1.nom = '$domain'
		AND r1.iddom =
			(SELECT dd1.iddom FROM dns.dr_dom dd1
					WHERE dd1.idgrp = corresp.idgrp
					    AND dd1.iddom = r1.iddom
					    AND dd1.rolemail > 0
			    )
		AND role_mail.heberg = r2.idrr
		AND r2.iddom = d2.iddom
		AND r2.iddom =
			(SELECT dd2.iddom FROM dns.dr_dom dd2
					WHERE dd2.idgrp = corresp.idgrp
					    AND dd2.iddom = r2.iddom
			    )
		AND r2.idrr IN
			(SELECT r3.idrr FROM dns.rr_ip r3
					WHERE valide_ip_cor(adr, $idcor)
					    AND r3.idrr = r2.idrr
			    )
		AND r2.idrr NOT IN
			(SELECT r4.idrr FROM dns.rr_ip r4
					WHERE NOT valide_ip_cor(adr, $idcor)
					    AND r4.idrr = r2.idrr
			    )
	    ORDER BY domaina ASC, namea ASC
		"
    set r {}
    pg_select $dbfd $sql tab {
	lappend r [list $tab(namea) $tab(domaina) $tab(nameh) $tab(domainh)]
    }
    return $r
}

##############################################################################
# Main procedure
##############################################################################

proc main {} {
    global conf

    #
    # Initialization
    #

    ::dnscontext create d
    d init-cgi "dns" $conf(err) "" $conf(form) ftab dbfd login tabuid

    set idcor $tabuid(idcor)

    set name   [string trim [lindex $ftab(nom) 0]]
    set domain [string trim [lindex $ftab(domaine) 0]]

    #
    # Do we have permission for declaring mail roles in this domain?
    #

    set iddom -1
    set msg [check-domain $dbfd $idcor iddom domain "rolemail"]
    if {$msg ne ""} then {
	d error $msg
    }

    #
    # Should we display a list of mail addresses?
    #

    set lsubst {}
    if {$name eq ""} then {
	#
	# No name given: we must display of list of existing mail addresses
	# in database for addresses owned by the user.
	#

	set page $conf(pageliste)
	set lroles [read-mailrole $dbfd $idcor "" $domain]

	if {[llength $lroles] == 0} then {
	    set tableau [mc "No mail role found for '%s'" $domain]
	} else {
	    set lines {}
	    lappend lines [list "Title" \
				    [mc "Mail address"]  \
				    [mc "Mailbox host"]  \
				]
	    foreach q [read-mailrole $dbfd $idcor "" $domain] {
		# link "..../mailheberg?nom=...&domaine=.."
		lassign $q namea domaina nameh domainh

		# there is only "RFC compatible" characters, no need to quote
		d urlset "" $conf(nextheberg) [list \
						    [list "nom" $namea] \
						    [list "domaine" $domaina] \
					    ]
		set url [d urlget ""]
		set html [::webapp::helem "a" "$namea.$domaina" "href" $url]

		lappend lines [list Normal $html "$nameh.$domainh"]
	    }
	    set tableau [::arrgen::output "html" $conf(tableau) $lines]
	}

	lappend lsubst [list %TABLEAU% $tableau]
	lappend lsubst [list %DOMAINE% $domain]

    } else {
	#
	# A name has been given. We must display the edit page for this role.
	#

	set page $conf(pageedit)
	set nameh ""
	set domh ""

	#
	# Check mail address syntax
	#

	set msg [check-name-syntax $name]
	if {$msg ne ""} then {
	    d error $msg
	}

	#
	# Check permission to edit this mail address
	#

	set msg [check-role-mail $dbfd $idcor $name $domain trr trrh]
	if {$msg ne ""} then {
	    d error $msg
	}

	set nameh $trrh(nom)
	set domh $trrh(domaine)
	set domainh [menu-domain $dbfd $idcor "domaineh" "" $domh]

	lappend lsubst [list %NOM%      $name]
	lappend lsubst [list %DOMAINE%  $domain]
	lappend lsubst [list %NOMH%	$nameh]
	lappend lsubst [list %DOMAINEH% $domainh]
    }

    #
    # End of script: output page and close database
    #

    d urlset "%URLFORM%" $conf(nextmodif) {}
    d result $page $lsubst
}

::webapp::cgi-exec main %DEBUG%
