#!%TCLSH%


#
# Script pour chercher le ou les correspondants associés à un
# réseau, à une adresse IP ou une machine.
#
# Appelé par : index.htgt
#
# Paramètres (formulaire ou URL) :
#	- critere : critere de recherche (ip, cidr, ou fqdn, ou _ pour ici)
#
# Historique
#   2002/07/25 : pda      : création
#   2003/05/13 : pda/jean : utilisation de la base d'authentification
#   2004/01/14 : pda/jean : ajout IPv6
#   2004/08/06 : pda/jean : extension des droits sur les réseaux
#   2005/02/24 : pda      : ajout cas rôle mail sans adresse IP
#   2010/10/17 : pda      : ajout recherche "où suis-je"
#

set conf(homeurl)	%HOMEURL%

#
# Chemins utilisés par les scripts
#

set conf(lib)		%DESTDIR%/lib
set conf(libdns)	$conf(lib)/libdns.tcl

#
# Définition des noms des pages "à trous"
#

set conf(err)		$conf(lib)/erreur.html
set conf(page)		$conf(lib)/corresp.html

#
# Scripts suivants (actions de formulaire)
# 

set conf(next)		"%HOMEURL%/bin/corresp"

#
# Quelques paramètres du script
#

set conf(form)	{
	{critere	0 1 {}}
	{ousuisje	0 1 {}}
}

#
# Tableau pour afficher une machine
#



#
# Les outils du parfait concepteur de pages Web dynamiques...
#

lappend auto_path %PKGTCL%
package require webapp
package require pgsql
package require arrgen

#
# On y va !
#

# ::webapp::cgidebug ; exit

source $conf(libdns)

proc corresp-erreur {critere msg} {
    global conf

    set qmsg     [::webapp::html-string $msg]
    set qcritere [::webapp::html-string $critere]
    set resultat "<FONT COLOR=\"FF0000\">$qmsg</FONT>"
    d urlset "%URLFORM%" $conf(next) {}
    d result $conf(page) [list \
				[list %CRITERE% $qcritere] \
				[list %RESULTAT% $resultat] \
			    ]
    exit 0
}

##############################################################################
# Programme principal
##############################################################################

proc main {} {
    global conf

    #
    # Initialisation
    #

    ::dnscontext create d
    d init-cgi "dns" $conf(err) "" $conf(form) ftab dbfd login tabcor

    set critere [string trim [lindex $ftab(critere) 0]]

    #
    # Est-ce que c'est une adresse IP ?
    #

    if {[string equal $critere ""]} then {
	#
	# Rien. Ce n'est pas une erreur à strictement parler,
	# mais on le traite comme tel.
	#
	corresp-erreur "" ""

    } elseif {[string equal $critere "_"]} then {
	global env

	if {[info exists env(REMOTE_ADDR)]} then {
	    set adr $env(REMOTE_ADDR)
	    set critere $adr
	    read-rr-by-ip $dbfd $adr tabrr
	} else {
	    corresp-erreur "" ""
	}
    } elseif {[string equal [check-ip-syntax $dbfd $critere "inet"] ""]} then {
	#
	# Adresse IP
	#
	set adr $critere

	#
	# Tentative de recherche de la machine. Si elle existe,
	# tabrr sera rempli. Si non, tabrr ne sera pas créé.
	# On ne se préoccupe pas du résultat (l'existence ou non
	# de tabrr(idrr) nous suffira) par la suite.
	#
	read-rr-by-ip $dbfd $critere tabrr

    } elseif {[string equal [check-ip-syntax $dbfd $critere "cidr"] ""]} then {
	#
	# CIDR
	#
	set adr $critere

    } elseif {[regexp {^([^.]+)\.(.+)$} $critere bidon nom domaine]} then {
	#
	# Nom et domaine
	#
	set iddom [read-domain $dbfd $domaine]
	if {$iddom == -1} then {
	    corresp-erreur $critere "Domaine '$domaine' non trouvé."
	}

	if {! [read-rr-by-name $dbfd $nom $iddom tabrr]} then {
	    corresp-erreur $critere \
		"Machine '$nom' non trouvée dans le domaine '$domaine'."
	}

    } elseif {[regexp {^([^.]+)$}  $critere bidon nom]} then {
	#
	# Nom sans domaine : prendre par défaut le domaine privilégié
	# du correspondant qui exécute ce script.
	#
	set qnom [::pgsql::quote $nom]
	set idrr -1
	set iddom -1
	set sql "SELECT d.iddom, d.nom
			FROM global.corresp c, global.groupe g, dns.dr_dom dd, dns.domaine d
			WHERE c.idcor = $tabcor(idcor)
			    AND c.idgrp = g.idgrp
			    AND g.idgrp = dd.idgrp
			    AND dd.iddom = d.iddom
			ORDER BY dd.tri ASC
			LIMIT 1
			"
	pg_select $dbfd $sql tab {
	    set iddom $tab(iddom)
	    set domaine $tab(nom)
	}
	if {$iddom == -1} then {
	    d error "Pas de domaine par défaut !"
	}
	if {! [read-rr-by-name $dbfd $nom $iddom tabrr]} then {
	    corresp-erreur $critere \
		"Machine '$nom' non trouvée dans le domaine '$domaine'."
	}

    } else {
	#
	# On ne peut normalement pas arriver là : tout doit passer
	# dans le cas précédent !
	#
	corresp-erreur $critere "Critère de recherche '$critere' invalide."
    }

    #
    # Si on arrive ici, c'est qu'on a réussi à analyser le
    # critère de recherche.
    #
    # Si, de plus, tabrr(idrr) existe, c'est que le nom ou l'adresse
    # correspond à une machine réelle.
    #

    #
    # Si c'est un alias, rechercher la vraie adresse
    #

    if {[info exists tabrr(cname)]} then {
	if {! [string equal $tabrr(cname) ""]} then {
	    set idrr $tabrr(cname)
	    unset tabrr
	    if {! [read-rr-by-id $dbfd $idrr tabrr]} then {
		d error "Erreur interne : objet pointé par l'alias non trouvé"
	    }
	}
    }

    #
    # Si c'est un rôle de messagerie, sans adresse IP, rechercher
    # l'adresse de l'hébergeur.
    #

    if {[info exists tabrr(rolemail)] && [llength $tabrr(ip)] == 0} then {
	if {! [string equal $tabrr(rolemail) ""]} then {
	    set idrr $tabrr(rolemail)
	    unset tabrr
	    if {! [read-rr-by-id $dbfd $idrr tabrr]} then {
		d error "Erreur interne : hébergeur du rolemail non trouvé"
	    }
	}
    }

    #
    # Si le critère était un nom et pas une adresse IP, extraire une
    # adresse IP (au hasard parmi celles associées au nom).
    #

    if {! [info exists adr]} then {
	if {! [info exists tabrr(ip)]} then {
	    d error "Erreur interne : pas d'adresse et pas de tabrr"
	}

	set adr [lindex $tabrr(ip) 0]
    }

    #
    # Afficher l'adresse
    #

    set resultat ""

    append resultat "Adresse recherchée&nbsp;: $adr\n"
    append resultat "<P>\n"

    #
    # Si on a trouvé une machine à cette adresse, afficher les
    # informations pertinentes
    #

    if {[info exists tabrr(idrr)]} then {
	append resultat [display-rr $dbfd -1 tabrr]
	append resultat "<P>"
    }

    #
    # Rechercher les différents correspondants qui peuvent
    # potentiellement s'occuper de la plage dans laquelle
    # il y a cette adresse.
    #

    set sql "SELECT c.login, c.idcor
		    FROM global.corresp c, global.groupe g,
			dns.dr_reseau d, dns.reseau r
		    WHERE c.idgrp = g.idgrp
			AND g.idgrp = d.idgrp
			AND d.idreseau = r.idreseau
			AND ('$adr' <<= r.adr4 OR '$adr' <<= r.adr6)
			ORDER BY g.admin, g.nom
			"
    set lcor {}
    pg_select $dbfd $sql tab {
	lappend lcor [list $tab(login) $tab(idcor)]
    }

    #
    # Parmi les correspondants sélectionnés, rechercher ceux
    # dont les droits correspondent à l'adresse fournie.
    #

    set trouve 0
    foreach cor $lcor {
	lassign $cor login idcor
	if {[check-authorized-ip $dbfd $idcor $adr]} then {
	    lassign [read-user $dbfd $login tabcor] msg arg
	    if {$msg ne ""} then {
		d error [format [mc $msg] $arg]
	    }
	    append resultat [display-user tabcor]
	    append resultat "\n<P>\n"
	    set trouve 1
	}
    }

    #
    # Fin du script : sortie de la page et fermeture de la base
    #

    d urlset "%URLFORM%" $conf(next) {}
    d result $conf(page) [list \
				[list %CRITERE% $critere] \
				[list %RESULTAT% $resultat] \
			    ]
}

::webapp::cgi-exec main %DEBUG%
