#!%TCLSH%


#
# Script pour afficher le statut de topod
#
# Appelé par : admin
#
# Paramètres (formulaire ou URL) :
#	- refresh : temps en secondes entre chaque rafraichissement de page
#	- nrefresh : nouveau temps de rafraichissement
#	- key : "eqmod", "ifchg", "status" ou "keepstate"
#	- arg : "" ou nom d'équipement ou nom d'objet keepstate
#  
#
# Historique
#   2010/11/15 : pda      : création
#

set conf(homeurl)	%HOMEURL%

#
# Chemins utilisés par les scripts
#

set conf(lib)		%DESTDIR%/lib
set conf(libdns)	$conf(lib)/libdns.tcl

#
# Définition des noms des pages "à trous"
#

set conf(err)		$conf(lib)/erreur.html
set conf(page)		$conf(lib)/topotop.html

#
# Scripts suivants (actions de formulaire)
# 

set conf(next)		"%HOMEURL%/bin/topotop"
set conf(nextpar)	"%HOMEURL%/bin/admparliste"

#
# Quelques paramètres du script
#

set conf(form) {
   	 {refresh	0 1}
   	 {nrefresh	0 1}
	 {key		0 1}
	 {arg		0 1}
}

# nb max de lignes d'équipements traités
set conf(maxeq)		10

# nb max de lignes de statut dans l'affichage compact
set conf(maxstatus)	10

# taille maximum (en caractères) de l'affichage d'un message
set conf(maxmsg)	50

set conf(taball) {
    global {
	chars {10 normal}
	align {left}
	botbar {yes}
	columns {20 20 60}
	align {left}
	format {raw}
    }
    pattern Titre {
	topbar {yes}
	vbar {yes}
	column {
	    chars {bold}
	    align {center}
	    multicolumn {3}
	}
	vbar {yes}
    }
    pattern Normal3 {
	topbar {yes}
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
    }
    pattern Normal2 {
	topbar {yes}
	vbar {yes}
	column { }
	vbar {yes}
	column {
	    multicolumn {2}
	}
	vbar {yes}
    }
}

set conf(tabeqmod) {
    global {
	chars {10 normal}
	align {left}
	botbar {yes}
	columns {40 20 20 20}
	align {left}
	format {cooked}
    }
    pattern Titre {
	topbar {yes}
	vbar {yes}
	column {
	    chars {bold}
	    align {center}
	}
	vbar {yes}
	column {
	    chars {bold}
	    align {center}
	}
	vbar {yes}
	column {
	    chars {bold}
	    align {center}
	}
	vbar {yes}
	column {
	    chars {bold}
	    align {center}
	}
	vbar {yes}
    }
    pattern Normal4 {
	topbar {yes}
	vbar {yes}
	column {
	    format {raw}
	}
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
    }
}

# eq
# iface
# reqdate
# login
# modif (vlan/voip/desc)
# processed
# moddate
# modlog (les premiers caractères)

set conf(tabifchg) {
    global {
	chars {10 normal}
	align {left}
	botbar {yes}
	columns {20 20 20 10 30 5 20 20}
	align {left}
	format {cooked}
    }
    pattern Titre {
	chars {bold}
	align {center}
	topbar {yes}
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
    }
    pattern Normal8 {
	topbar {yes}
	vbar {yes}
	column {
	    format {raw}
	}
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column {
	    format {raw}
	}
	vbar {yes}
    }
    pattern Bold8 {
	chars {bold}
	topbar {yes}
	vbar {yes}
	column {
	    format {raw}
	}
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
	column {
	    format {raw}
	}
	vbar {yes}
    }
}

set conf(tabstatus) {
    global {
	chars {10 normal}
	align {left}
	botbar {yes}
	columns {30 70}
	align {left}
	format {cooked}
    }
    pattern Titre {
	topbar {yes}
	vbar {yes}
	column {
	    multicolumn {2}
	    chars {bold}
	    align {center}
	}
	vbar {yes}
    }
    pattern Normal2 {
	topbar {yes}
	vbar {yes}
	column { }
	vbar {yes}
	column { }
	vbar {yes}
    }
}

set conf(tabks) {
    global {
	chars {10 normal}
	align {left}
	botbar {yes}
	columns {100}
	align {left}
	format {cooked}
    }
    pattern Titre {
	topbar {yes}
	vbar {yes}
	column {
	    chars {bold}
	    align {center}
	}
	vbar {yes}
    }
    pattern Normal1 {
	topbar {yes}
	vbar {yes}
	column {
	    format {lines}
	}
	vbar {yes}
    }
}

set conf(tabmodlog) $conf(tabks)

#
# Les outils du parfait concepteur de pages Web dynamiques...
#

lappend auto_path %PKGTCL%
package require webapp
package require arrgen
package require pgsql

#
# On y va !
#

# ::webapp::cgidebug ; exit

source $conf(libdns)

##############################################################################
# Fonction d'affichage de tous les éléments, en version compacte
##############################################################################

proc topotop-all {dbfd datefmt arg} {
    global conf

    set donnees {}

    lappend donnees [list Titre "Général"]

    #
    # Récupérer et mettre en forme l'indicateur d'activation de la
    # fonctionnalité "topo"
    #

    if {[dnsconfig get "topoactive"]} then {
	set active "activée"
    } else {
	set active "désactivée"
    }
    d urlset "" $conf(nextpar) {}
    set url [d urlget ""]
    set active [::webapp::helem "a" $active "href" $url]
    lappend donnees [list Normal2 "Fonctionnalité Topo" $active]

    #
    # Récupérer et mettre en forme la date de dernier passage de full-rancid
    #

    set lastfull "(jamais)"
    pg_select $dbfd "SELECT * FROM topo.lastrun" tab {
	if {$tab(date) ne ""} then {
	    set lastfull [clock format [clock scan $tab(date)] -format $datefmt]
	}
    }
    lappend donneees [list Normal2 "Dernier full-rancid" $lastfull]

    #
    # Récupérer et mettre en forme la liste des équipements modifiés
    # et en attente de reconstruction du graphe
    #

    set unproc {}
    pg_select $dbfd "SELECT DISTINCT eq FROM topo.modeq WHERE processed=0" tab {
	d urlset "" $conf(next) [list {key eqmod} [list "arg" $tab(eq)]]
	set url [d urlget ""]
	lappend unproc [::webapp::helem "a" $tab(eq) "href" $url]
    }
    if {[llength $unproc] == 0} then {
	set unproc "(aucun)"
    } else {
	set unproc [join $unproc ", "]
    }

    d urlset "" $conf(next) [list {key eqmod}]
    set url [d urlget ""]
    set msg [::webapp::helem "a" "Équipements modifiés" "href" $url]
    lappend donnees [list Normal2 $msg $unproc]

    #
    # Récupérer et mettre en forme la liste d'attente des modifications
    # d'interfaces.
    #

    set unproc {}
    set sql "SELECT DISTINCT r.nom || '.' || d.nom AS eq
			FROM topo.ifchanges i, dns.rr r, dns.domaine d
			WHERE i.processed = 0
			    AND i.idrr = r.idrr
			    AND r.iddom = d.iddom"
    pg_select $dbfd $sql tab {
	d urlset "" $conf(next) [list {key ifchg} [list "arg" $tab(eq)]]
	set url [d urlget ""]
	lappend unproc [::webapp::helem "a" $tab(eq) "href" $url]
    }
    if {[llength $unproc] == 0} then {
	set unproc "(aucun)"
    } else {
	set unproc [join $unproc ", "]
    }

    d urlset "" $conf(next) [list {key ifchg}]
    set url [d urlget ""]
    set msg [::webapp::helem "a" "Changements en attente" "href" $url]
    lappend donnees [list Normal2 $msg $unproc]

    #
    # Mettre en forme les dernières lignes de statut
    #

    lappend donnees [list Titre "Statut"]

    set status {}
    set sql "SELECT message FROM topo.keepstate WHERE type = 'status'"
    pg_select $dbfd $sql tab {
	set status $tab(message)
    }
    d urlset "" $conf(next) [list {key status}]
    set url [d urlget ""]
    set statut [::webapp::helem "a" "Statut" "href" $url]
    set ls {}
    set i 0
    foreach s $status {
	lassign $s date msg
	set date [clock format [clock scan $date] -format $datefmt]
	set msg [::webapp::html-string $msg]
	lappend ls "$date $msg"
	incr i
	if {$i >= $conf(maxstatus)} then {
	    break
	}
    }
    lappend donnees [list Normal2 $statut [join $ls "<br>"]]

    #
    # Récupérer et mettre en forme les autres messages de keepstate
    #

    set sql "SELECT * FROM topo.keepstate
				WHERE type != 'status'
				ORDER BY date DESC"
    pg_select $dbfd $sql tab {
	set type $tab(type)
	set date [clock format [clock scan $tab(date)] -format $datefmt]
	set mess [string range $tab(message) 0 $conf(maxmsg)]
	regsub "\n" $mess "/" message
	set message [::webapp::html-string $message]
	if {$mess ne $tab(message)} then {
	    append message "..."
	    d urlset "" $conf(next) [list {key keepstate} [list "arg" $type]]
	    set url [d urlget ""]
	    set message [::webapp::helem "a" $message "href" $url]
	}
	lappend donnees [list Normal3 $type $date $message]
    }

    #
    # Récupérer les derniers équipements traités
    #

    d urlset "" $conf(next) [list {key eqmod}]
    set url [d urlget ""]
    set msg [::webapp::helem "a" "Derniers équipements traités" "href" $url]
    lappend donnees [list Titre $msg]

    set sql "SELECT * FROM topo.modeq
				WHERE processed != 0
				ORDER BY date desc
				LIMIT $conf(maxeq)"
    set le {}
    pg_select $dbfd $sql tab {
	set eq $tab(eq)
	set date [clock format [clock scan $tab(date)] -format $datefmt]
	set login $tab(login)

	d urlset "" $conf(next) [list {key eqmod} [list "arg" $eq]]
	set url [d urlget ""]
	set eq [::webapp::helem "a" $eq "href" $url]

	lappend donnees [list Normal3 $eq $date $login]
    }

    return [::arrgen::output "html" $conf(taball) $donnees]
}

##############################################################################
# Fonction spécialisée pour l'affichage des équipements modifiés
##############################################################################

# arg = "" ou eq
proc topotop-eqmod {dbfd datefmt arg} {
    global conf

    set donnees {}
    lappend donnees [list Titre "Équipement" "Date" "Login" "Traité"]
    if {$arg eq ""} then {
	set where ""
    } else {
	set qeq [::pgsql::quote $arg]
	set where "WHERE eq = '$qeq'"
    }

    pg_select $dbfd $sql tab {
	set reqdate [clock format [clock scan $tab(date)] -format $datefmt]
	if {$tab(processed)} then {
	    set traite "Oui"
	} else {
	    set traite "Non"
	}
	set eq $tab(eq)
	if {$arg eq ""} then {
	    d urlset "" $conf(next) [list {key eqmod} [list "arg" $eq]]
	    set url [d urlget ""]
	    set eq [::webapp::helem "a" $eq "href" $url]
	}
	lappend donnees [list Normal4 $eq $date $tab(login) $traite]
    }
    return [::arrgen::output "html" $conf(tabeqmod) $donnees]
}

##############################################################################
# Fonction spécialisée pour l'affichage des interfaces à modifier
##############################################################################

# arg = "" ou eq
proc topotop-ifchg {dbfd datefmt arg} {
    global conf

    set donnees {}
    lappend donnees [list Titre "Équipement" "Interface" "Date" "Login" \
				"Modification" "Traité" "Date d'envoi" "Log"]
    if {$arg eq ""} then {
	set sql "SELECT r.nom || '.' || d.nom AS eq, i.*
			FROM topo.ifchanges i, dns.rr r, dns.domaine d
			WHERE i.idrr = r.idrr AND r.iddom = d.iddom
			ORDER BY reqdate DESC"
    } else {
	set qeq [::pgsql::quote $arg]
	set sql "SELECT r.nom || '.' || d.nom AS eq, i.*
			FROM topo.ifchanges i, dns.rr r, dns.domaine d
			WHERE i.idrr = r.idrr AND r.iddom = d.iddom
			    AND (r.nom || '.' || d.nom) = '$qeq'
			ORDER BY reqdate DESC"
    }

    pg_select $dbfd $sql tab {
	set reqdate [clock format [clock scan $tab(reqdate)] -format $datefmt]
	if {$tab(processed)} then {
	    set pattern "Normal8"
	    set traite "Oui"
	} else {
	    set pattern "Bold8"
	    set traite "Non"
	}

	d urlset "" $conf(next) [list {key ifchg} [list "arg" $tab(eq)]]
	set url [d urlget ""]
	set eq [::webapp::helem "a" $tab(eq) "href" $url]

	set mod "vlan=$tab(ethervlan), voip=$tab(voicevlan), desc=$tab(ifdesc)"
	set moddate $tab(moddate)
	if {$moddate ne ""} then {
	    set moddate [clock format [clock scan $moddate] -format $datefmt]
	}

	set modlog [string range $tab(modlog) 0 $conf(maxmsg)]
	regsub "\n" $modlog "/" modlog
	set modlog [::webapp::html-string $modlog]
	if {$modlog ne $tab(modlog)} then {
	    append modlog "..."
	    set arg "$tab(eq)|$tab(iface)|$tab(reqdate)"
	    d urlset "" $conf(next) [list {key modlog} [list "arg" $arg]]
	    set url [d urlget ""]
	    set modlog [::webapp::helem "a" $modlog "href" $url]
	}

	lappend donnees [list $pattern \
				$eq $tab(iface) $reqdate $tab(login) \
				$mod $traite $moddate $modlog]
    }
    return [::arrgen::output "html" $conf(tabifchg) $donnees]
}

##############################################################################
# Fonction spécialisée pour l'affichage du log de modification d'interface
##############################################################################

# arg = "eq|iface|date"
proc topotop-modlog {dbfd datefmt arg} {
    global conf

    if {! [regexp {^([^|]+)\|([^|]+)\|([^|]+)$} $arg bidon eq iface date]} then {
	d error "invalid argument '$arg'"
    }

    set qeq [::pgsql::quote $eq]
    set qif [::pgsql::quote $iface]
    set qdate [::pgsql::quote $date]
    set sql "SELECT moddate, modlog FROM topo.ifchanges,
					dns.rr r, dns.domaine d
			WHERE (r.nom || '.' || d.nom) = '$qeq'
			    AND iface = '$qif'
			    AND reqdate = '$qdate'"
    set donnees {}
    pg_select $dbfd $sql tab {
	set moddate $tab(moddate)
	set modlog $tab(modlog)
    }

    if {$moddate ne ""} then {
	set moddate [clock format [clock scan $moddate] -format $datefmt]
    }
    regsub -all "\n+" $modlog "\n" modlog
    regsub -all "\b" $modlog "" modlog

    set harg [::webapp::html-string $arg]
    if {$moddate eq ""} then {
	set msg [format "Modification de '%s/%s' non encore effectuée" \
				$eq $iface]
	lappend donnees [list Titre $msg]
    } else {
	set msg [format "Log des modifications de '%s/%s' au %s" \
				$eq $iface $moddate]
	lappend donnees [list Titre $msg]
	lappend donnees [list Normal1 $modlog]
    }

    return [::arrgen::output "html" $conf(tabmodlog) $donnees]
}

##############################################################################
# Fonction spécialisée pour l'affichage détaillé du statut
##############################################################################

# arg = ""
proc topotop-status {dbfd datefmt arg} {
    global conf

    set donnees {}
    lappend donnees [list Titre "Statut"]

    set status {}
    set sql "SELECT message FROM topo.keepstate WHERE type = 'status'"
    set status {}
    pg_select $dbfd $sql tab {
	set status $tab(message)
    }
    foreach s $status {
	lassign $s date msg
	set date [clock format [clock scan $date] -format $datefmt]
	set msg [::webapp::html-string $msg]
	lappend donnees [list Normal2 $date $msg]
    }

    return [::arrgen::output "html" $conf(tabstatus) $donnees]
}

##############################################################################
# Fonction spécialisée pour l'affichage détaillé d'un keepstate particulier
##############################################################################

# arg = type
proc topotop-keepstate {dbfd datefmt arg} {
    global conf

    set donnees {}

    set qtype [::pgsql::quote $arg]
    set sql "SELECT date, message FROM topo.keepstate WHERE type = '$qtype'"

    set date ""
    set message ""
    pg_select $dbfd $sql tab {
	set date [clock format [clock scan $tab(date)] -format $datefmt]
	set message $tab(message)
    }

    set harg [::webapp::html-string $arg]
    if {$date eq ""} then {
	set msg [format "Aucun message pour '%s'" $harg]
	lappend donnees [list Titre $msg]
    } else {
	set msg [format "Dernier message pour '%s' au '%s'" $harg $date]
	lappend donnees [list Titre $msg]
	lappend donnees [list Normal1 $message]
    }

    return [::arrgen::output "html" $conf(tabks) $donnees]
}

##############################################################################
# Programme principal
##############################################################################

proc main {} {
    global conf

    #
    # Initialisation
    #

    ::dnscontext create d
    d init-cgi "admin" $conf(err) "admin" $conf(form) ftab dbfd login tabcor

    ::webapp::import-vars ftab
    if {[llength $ftab(key)] > 1} then {
	d error "Formulaire non conforme aux spécifications ('key' présent plusieurs fois)"
    }

    foreach f $conf(form) {
	set var [lindex $f 0]
	set $var [string trim [lindex [set $var] 0]]
    }

    # nrefresh (le champ texte saisi par l'utilisateur) prend le pas
    # sur la valeur refresh qui est passée dans l'url. Du coup, la
    # nouvelle url devra tenir compte de nrefresh
    if {$nrefresh ne ""} then {
	set refresh $nrefresh
    }

    d urlset "%URLFORM%" $conf(next) [list \
					    [list "key" $key] \
					    [list "arg" $arg] \
					    [list "refresh" $refresh] \
					]

    set datefmt [dnsconfig get "datefmt"]

    set date [clock format [clock seconds] -format $datefmt]

    #
    # Activer le refresh
    #

    set meta ""
    if {[regexp {^[0-9]+$} $refresh] && $refresh > 0} then {
	d urlset "" $conf(next) [list \
					    [list "key" $key] \
					    [list "arg" $arg] \
					    [list "refresh" $refresh] \
					]
	set u [d urlget ""]
	append meta "<meta http-equiv=\"refresh\" content=\"$refresh;url=$u\">"
	append meta "<meta http-equiv=\"pragma\" content=\"no-cache\">"
    } else {
	set refresh [::webapp::html-string $refresh]
    }


    #
    # Activer l'affichage spécifique d'une clef
    #

    if {$key eq "" || [catch {info args topotop-$key}]} then {
	set top [topotop-all $dbfd $datefmt ""]
    } else {
	set top [topotop-$key $dbfd $datefmt $arg]
    }

    #
    # Fin du script : sortie de la page et fermeture de la base
    #

    set key [::webapp::html-string $key]
    set arg [::webapp::html-string $arg]

    d result $conf(page) [list \
				[list %META% $meta] \
				[list %REFRESH% $refresh] \
				[list %DATE% $date] \
				[list %TOP% $top] \
			    ]
}

::webapp::cgi-exec main %DEBUG%
