#!%TCLSH%

#
# Script pour afficher la liste des équipements,
# ou les détails d'un équipement
#
# Appelé par : /applis/topo/<tous les scripts>
#
# Paramètres (formulaire ou URL) :
#	- eq : si fourni, nom (ou pattern glob) de l'équipement
#	- iface : si fourni, nom d'une interface à souligner
#
# Historique
#   2006/06/05 : pda        : création
#   2006/08/14 : pda        : fusion script listeq
#   2007/01/04 : pda        : ajout du paramètre uti
#   2007/01/11 : pda        : mutualisation initialisation
#   2007/01/11 : pda        : substitution possible d'un uid
#   2008/05/06 : pda        : ajout localisation
#   2008/07/31 : pda/boggia : vue arborescente
#   2008/08/01 : pda        : stats wifi sur la page d'un équipement
#

set conf(homeurl)	%HOMEURL%

#
# Chemins utilisés par les scripts
#

set conf(pkg)		%PKGTCL%
set conf(lib)		%DESTDIR%/lib
set conf(libdns)	%LIBDNS%
set conf(libtopo)	$conf(lib)/libtopo.tcl

#
# Définition des noms des pages "à trous"
#

set conf(err)		$conf(lib)/erreur.html
set conf(page1)		$conf(lib)/eq.html
set conf(pagen)		$conf(lib)/liste.html

#
# Quelques paramètres du script
#

set conf(base)		%BASE%
set conf(nologin)	%NOLOGIN%

set conf(form)	{
    {eq			0 1}
    {iface		0 1}
}

set conf(dumpgraph)	"%TOPODIR%/bin/dumpgraph %s < %GRAPH%"
set conf(extracteq)	"%TOPODIR%/bin/extracteq %s %s < %GRAPH%"
set conf(extractcoll)	"%TOPODIR%/bin/extractcoll -w %s < %GRAPH%"
set conf(urlstat)	"$conf(homeurl)/bin/metro?id=%s%s"
set conf(urleq)		"$conf(homeurl)/bin/eq?eq=%s%s"
set conf(urleqiface)	"$conf(homeurl)/bin/eq?eq=%s&iface=%s%s"
set conf(urll2)		"$conf(homeurl)/bin/l2?eq=%s&iface=%s&vlan=%d%s"
set conf(urll3)		"$conf(homeurl)/bin/l3?addr=%s%s"

#
# Les outils du parfait concepteur de pages Web dynamiques...
#

lappend auto_path $conf(pkg)
package require webapp
package require pgsql

#
# On y va !
#

# ::webapp::cgidebug ; exit

source $conf(libdns)
source $conf(libtopo)

#
# Hierarchiser un élément dans un tableau en vue de consituer une
# arborescence
#
# Entrée :
#   - _thier : tableau passé par nom, contenant l'arborescence
#   - liste : liste d'éléments par niveau
#   - cumul : 1 si les éléments doivent être cumulés, 0 sinon (cf ci-dessous)
# Sortie :
#   - valeur de retour : aucune
#   - tableau _thier : réactualisé
#
# Exemple 1 :
#   si liste = {anapat -ap 3} et cumul = 1
#   et tableau vaut :
#	t()		= {anapat}
#	t(anapat)	= {anapat-ap}
#	t(anapat-ap)	= {anapat-ap1}
#	t(anapat-ap1)	= {}
#   alors le tableau est actualisé avec :
#	t()		= {anapat}
#	t(anapat)	= {anapat-ap}
#	t(anapat-ap)	= {anapat-ap1 anapat-ap3} (peu importe l'ordre 3/1 ou 1/3)
#	t(anapat-ap1)	= {}
#	t(anapat-ap3)	= {}
#
# Exemple 2 :
#   pour l'exemple ci-dessus, si cumul = 0, il faudrait avoir la
#   liste {anapat anapat-ap anapat-ap3}
#
# Exemple 3 :
#   si liste = {horus}
#   et tableau vaut :
#	(rien)
#   alors le tableau est actualisé avec :
#	t()		= {horus}
#	t(horus)	= {}
#
# Historique :
#   2008/07/31 : pda/boggia : conception
#

proc hierarchiser-un-element {_thier liste cumul} {
    upvar $_thier thier

    set racine ""
    set idx ""
    foreach mot $liste {
	if {$cumul} then {
	    append idx $mot
	} else {
	    set idx $mot
	}
	if {! [info exists thier($idx)]} then {
	    lappend thier($racine) $idx
	}
	set racine $idx
    }
    lappend thier($racine) {}
}

#
# Hiérarchiser une liste d'équipements 
#
# Entrée :
#   - _t : tableau passé par nom, contenant l'arborescence
#   - leq : liste d'équipements
# Sortie :
#   - valeur de retour : aucune
#   - tableau _t : réactualisé
#
# Note : le regroupement en arbre est réalisé sur le nom d'équipement
#   qui est découpé suivant une politique spécifique Osiris, à savoir
#	[xxx] [-tt] [nn]
#   où xxx est le préfixe, -tt le type d'équipement et nn le numéro
#   dans le type. Par exemple, "anapat-ap3" est découpé en :
#	anapat -ap 3
#
# Historique :
#   2008/07/31 : pda/boggia : conception
#

proc hiearchiser-liste-equipements {_t leq} {
    upvar $_t t

    catch {unset t}

    #
    # Première phase : hiérarchiser tous les éléments
    #

    foreach eq $leq {
	if {[regexp  {(.*)(-[a-z]+)([0-9]+)$} $eq bidon n1 n2 n3]} then {
	    hierarchiser-un-element t [list $n1 $n2 $n3] 1
	} else {
	    hierarchiser-un-element t [list $eq] 1
	}
    }

    #
    # Deuxième phase : remonter d'un niveau (récursivement) tous
    # les éléments qui sont seuls sur leur niveau (sauf les -ap)
    #

    # XXX : il manque quelque chose là, vous ne trouvez pas ?

    #
    # Troisième phase : trier chaque niveau
    #

    foreach i [array names t] {
	set t($i) [lsort $t($i)]
    }
}

#
# Générer un arbre à l'aide d'un tableau hiérarchisé
#
# Entrée :
#   - racine : racine de l'arbre
#   - _thier : tableau passé par nom, contenant l'arborescence
#   - _tabeq : tableau passé par nom, contenant les équipements
#   - _tabwifi : tableau passé par nom, contenant les sondes wifi
#   - u1 : fragment d'url pour le paramètre "uid=..." le cas échéant
# Sortie :
#   - valeur de retour : liste des arbres dont la racine est à ce
#	niveau)
#
# Historique :
#   2008/07/31 : pda/boggia : conception
#   2008/08/01 : pda/boggia : ajout tabwifi
#

proc generer-arbre-eq {racine _thier _tabeq _tabwifi u1} {
    global conf
    upvar $_thier thier
    upvar $_tabeq tabeq
    upvar $_tabwifi tabwifi

    set arbre {}
    foreach fils $thier($racine) {
	#
	# Cette boucle a pour but d'éviter de faire des niveaux
	# multiples s'il n'y a qu'un seul fils à chaque niveau.
	#
	set prec $racine
	while {! [string equal $fils ""] && [llength $thier($fils)] <= 1} {
	    set prec $fils
	    set fils [lindex $thier($fils) 0]
	}

	#
	# Noeud ou feuille ?
	#

	if {[string equal $fils ""]} then {
	    #
	    # Feuille : c'est donc un équipement
	    #
	    set type   [lindex $tabeq($prec) 0]
	    set modele [lindex $tabeq($prec) 1]
	    set url [format $conf(urleq) $prec $u1]

	    set lien [::webapp::helem "a" $prec "href" $url]
	    lappend arbre [list "$lien $type $modele"]
	} else {
	    #
	    # Noeud : on recommence récursivement
	    #
	    lappend arbre [generer-arbre-eq $fils thier tabeq tabwifi $u1]
	}
    }
    return [linsert $arbre 0 $racine]
}

##############################################################################
# Programme principal
##############################################################################

proc main {} {
    global conf

    #
    # Initialisation
    #

    init-topo $conf(nologin) $conf(base) $conf(err) "corresp" \
			$conf(form) ftab dbfd uid tabuid ouid tabouid urluid

    foreach f $conf(form) {
	set var [lindex $f 0]
	set $var [string trim [lindex [set $var] 0]]
    }

    set u1 ""
    set u2 ""
    if {! [string equal $urluid ""]} then {
	set u1 "&$urluid"
	set u2 "?$urluid"
    }

    #
    # Récupérer les informations sur les équipements lues dans le graphe
    #

    set cmd [format $conf(dumpgraph) $tabuid(flags)]
    set fd [open "|$cmd" "r"]
    while {[gets $fd ligne] > -1} {
	switch [lindex $ligne 0] {
	    eq {
		set nomeq  [lindex $ligne 1]
		if {[string equal $eq ""] || [string match -nocase $eq $nomeq]} then {
		    set type   [lindex $ligne 3]
		    set modele [lindex $ligne 5]
		    set tabeq($nomeq) [list $type $modele]
		}
	    }
	}
    }
    if {[catch {close $fd} msg]} then {
	::webapp::error-exit $conf(err) \
		"Erreur lors de la lecture des équipements (msg)"
    }

    #
    # Récupérer les stats wifi sur ces équipements
    #

    set cmd [format $conf(extractcoll) $tabuid(flags)]
    set fd [open "|$cmd" "r"]
    while {[gets $fd ligne] > -1} {
	set kw [lindex $ligne 0]
	switch $kw {
	    nbassocwifi -
	    nbauthwifi {
		set id    [lindex $ligne 1]
		set weq   [lindex $ligne 2]
		set iface [lindex $ligne 4]
		set ssid  [lindex $ligne 5]

		if {[info exists tabeq($weq)]} then {
		    lappend tabwifi($weq) [list $kw $id $ssid]
		    lappend tabwifi($weq:$iface) [list $kw $id $ssid]
		}
	    }
	}
    }
    if {[catch {close $fd} msg]} then {
	::webapp::error-exit $conf(err) \
		"Erreur lors de la lecture des sondes wifi (msg)"
    }

    #
    # S'il y a plusieurs équipements trouvés, les présenter
    # dans le bon ordre
    #

    # 1 si aucun eq cherché, 0 si recherche d'un éq
    set ceq [string equal $eq ""]

    # nb d'équipements trouvés
    set neq [llength [array names tabeq]]

    switch -glob "$ceq-$neq" {
	*-0 {
	    #
	    # Aucun équipement trouvé. Faire comme pour une liste, mais
	    # une liste vide ;-)
	    # Peu importe qu'on ait cherché ou non un équipement.
	    #

	    set liste "Aucun équipement trouvé"

	    #
	    # Sortie de la page
	    #

	    ::webapp::send html [::webapp::file-subst $conf(pagen) \
						[list \
							[list %OBJETS% "équipements"] \
							[list %LISTE%  $liste] \
							[list %EQ%     $eq] \
							[list %VLAN%   ""] \
							[list %ADDR%   ""] \
							[list %URLUID% $u2] \
							[list %HEADER% ""] \
							[list %ONLOAD% ""] \
						    ] \
					    ]
	}
	*-1 {
	    #
	    # On n'a trouvé qu'un seul équipement. Peu importe
	    # qu'on l'ait cherché ou non (le réseau peut être
	    # tout petit ;-)
	    # Récupérer les informations lues dans le graphe
	    #

	    set nomeq [lindex [array names tabeq] 0]

	    set cmd [format $conf(extracteq) $tabuid(flags) $nomeq]
	    set fd [open "|$cmd" "r"]
	    while {[gets $fd ligne] > -1} {
		switch [lindex $ligne 0] {
		    eq {
			set nomeq    [lindex $ligne 1]
			set type     [lindex $ligne 2]
			set modele   [lindex $ligne 3]
			set location [lindex $ligne 4]
			set titre "Équipement $nomeq $type $modele"
			if {! [string equal $location "-"]} then {
			    set location [binary format H* $location]
			    append titre " (localisation $location)"
			}
		    }
		    iface {
			set if [lindex $ligne 1]
			set tabiface($if) $ligne
		    }
		}
	    }
	    close $fd

	    #
	    # Trier les interfaces pour les présenter dans le bon ordre
	    #

	    set iflist [lsort -command compare-interfaces \
					[array names tabiface] \
				    ]

	    #
	    # Mettre en forme toutes ces informations
	    #

	    set texte ""
	    foreach i $iflist {
		set txt ""

		#
		# Nom de l'interface et paramètres associés (Ethernet, radio)
		#

		set ligne $tabiface($i)

		set nom   [lindex $ligne 1]
		set radio [lindex $ligne 2]
		set stat  [lindex $ligne 3]
		set mode  [lindex $ligne 4]
		set lien  [lindex $ligne 5]
		set ligne [lreplace $ligne 0 5]


		if {[string equal $iface $nom]} then {
		    append txt [::webapp::helem "b" $nom]
		} else {
		    append txt "$nom"
		}

		if {[llength $radio] > 0} then {
		    set channel [conv-channel [lindex $radio 0]]
		    set power   [lindex $radio 1]
		    append txt " (channel $channel power $power mW)"
		}

		if {! [string equal $stat "-"]} then {
		    set url [format $conf(urlstat) [::webapp::post-string $stat] $u1]
		    append txt " "
		    append txt [::webapp::helem "a" {[Trafic]} "href" $url]
		}

		append txt " $mode"

		if {[llength $lien] > 1} then {
		    set via [lindex $lien 0]
		    set eq2 [lindex $lien 1]
		    set if2 [lindex $lien 2]

		    set urleqiface [format $conf(urleqiface) $eq2 $if2 $u1]
		    append txt " $via vers "
		    append txt [::webapp::helem "a" "$eq2 $if2" "href" $urleqiface]
		}

		#
		# Récapitulatif des stats wifi
		#

		if {[info exists tabwifi($nomeq:$i)]} then {
		    #
		    # Cumuler les graphes d'associations et d'authentification
		    # Cumuler les graphes par ssid
		    #
		    set cumulkw(assoc) {}
		    set cumulkw(auth)  {}
		    foreach l $tabwifi($nomeq:$i) {
			# kw id ssid
			set kw [lindex $l 0]
			set id [lindex $l 1]
			set ssid [lindex $l 2]

			switch $kw {
			    nbassocwifi {
				lappend cumulkw(assoc) $id
				lappend detailassoc($ssid) $id
			    }
			    nbauthwifi  {
				lappend cumulkw(auth) $id
				lappend detailauth($ssid) $id
			    }
			}
		    }

		    append txt " "

		    #
		    # Cumuls
		    #

		    if {[llength $cumulkw(assoc)] > 1} then {
			set hid [join $cumulkw(assoc) "+"]
			set url [format $conf(urlstat) \
					[::webapp::post-string $hid] $u1]
			append txt " "
			append txt [::webapp::helem "a" {[Cumul Assoc]} \
							"href" $url]
		    }
		    if {[llength $cumulkw(auth)] > 1} then {
			set hid [join $cumulkw(auth) "+"]
			set url [format $conf(urlstat) \
					[::webapp::post-string $hid] $u1]
			append txt " "
			append txt [::webapp::helem "a" {[Cumul Auth]} \
							"href" $url]
		    }

		    #
		    # Détails par SSID
		    #

		    set l [array names detailassoc]
		    if {[llength $l] > 1} then {
			set lid {}
			foreach ssid $l {
			    lappend lid $detailassoc($ssid)
			}
			set hid [join $lid "|"]
			set url [format $conf(urlstat) \
					[::webapp::post-string $hid] $u1]
			append txt " "
			append txt [::webapp::helem "a" {[Détail Assoc]} \
							"href" $url]
		    }

		    set l [array names detailauth]
		    if {[llength $l] > 1} then {
			set lid {}
			foreach ssid $l {
			    lappend lid $detailauth($ssid)
			}
			set hid [join $lid "|"]
			set url [format $conf(urlstat) \
					[::webapp::post-string $hid] $u1]
			append txt " "
			append txt [::webapp::helem "a" {[Détail Auth]} \
							"href" $url]
		    }

		}

		#
		# Parcours des vlans présents sur cette interface
		#

		set nvlan [llength $ligne]
		foreach vlan [lsort -index 0 -integer $ligne] {
		    set vlanid [lindex $vlan 0]
		    set desc   [lindex $vlan 1]
		    if {[string equal $desc "-"]} then {
			set desc "pas de description"
		    } else {
			set desc [binary format H* $desc]
		    }
		    set stat   [lindex $vlan 2]

		    append txt "\n<BR>\n"

		    if {$nvlan > 1 || $vlanid != 0} then {
			set urll2 [format $conf(urll2) $nomeq $i $vlanid $u1]
			append txt "Vlan "
			append txt [::webapp::helem "a" "$vlanid ($desc)" \
						"href" $urll2]

			if {! [string equal $stat "-"]} then {
			    set url [format $conf(urlstat) $stat $u1]
			    append txt " "
			    append txt [::webapp::helem "a" {[Trafic]} \
						"href" $url]
			}
		    }

		    foreach ip [lsort [lindex $vlan 3]] {
			set urll3 [format $conf(urll3) $ip $u1]
			append txt " "
			append txt [::webapp::helem "a" $ip "href" $urll3]
		    }
		}

		#
		# Pour les interfaces radio, parcourir les points
		# de métrologie pour les ssid trouvés
		#

		set ssidprec ""
		if {[info exists tabwifi($nomeq:$i)]} then {
		    foreach l [lsort -index 2 $tabwifi($nomeq:$i)] {
			# kw id ssid
			set kw [lindex $l 0]
			set id [lindex $l 1]
			set ssid [lindex $l 2]

			switch $kw {
			    nbassocwifi { set k "assoc" }
			    nbauthwifi  { set k "auth" }
			    default     { set k "???" }
			}

			set url [format $conf(urlstat) $id $u1]
			if {! [string equal $ssid $ssidprec]} then {
			    append txt "\n<BR>\nSsid $ssid "
			}
			append txt [::webapp::helem "a" "\[$k\]" "href" $url]

			set ssidprec $ssid
		    }
		}

		#
		# Résultat final
		#
		append texte [::webapp::helem "li" [::webapp::helem "p" $txt]]
	    }
	    set texte [::webapp::helem "ul" $texte]

	    #
	    # Sortie de la page
	    #

	    ::webapp::send html [::webapp::file-subst $conf(page1) \
						[list \
							[list %TITRE% $titre] \
							[list %TEXTE% $texte] \
							[list %EQ%    $eq] \
							[list %VLAN%  ""] \
							[list %ADDR%  ""] \
							[list %URLUID% $u2] \
						    ] \
					    ]
	}
	0-* {
	    #
	    # On a cherché un équipement (via une expression régulière
	    # par exemple), et on en a trouvé plusieurs.
	    # Trier les équipements pour les présenter dans le bon ordre
	    # dans une liste bien linéaire.
	    #

	    set liste ""
	    foreach e [lsort [array names tabeq]] {
		set type   [lindex $tabeq($e) 0]
		set modele [lindex $tabeq($e) 1]
		set url [format $conf(urleq) $e $u1]

		set lien [::webapp::helem "a" $e "href" $url]
		append liste [::webapp::helem "li" "$lien $type $modele"]
	    }
	    set liste [::webapp::helem "ul" $liste]

	    #
	    # Sortie de la page
	    #

	    ::webapp::send html [::webapp::file-subst $conf(pagen) \
						[list \
							[list %OBJETS% "équipements"] \
							[list %LISTE%  $liste] \
							[list %EQ%     $eq] \
							[list %VLAN%   ""] \
							[list %ADDR%   ""] \
							[list %URLUID% $u2] \
							[list %HEADER% ""] \
							[list %ONLOAD% ""] \
						    ] \
					    ]
	}
	1-* {
	    #
	    # On n'a cherché aucun équipement, on veut juste voir
	    # la liste (arborescente).
	    # Regrouper les équipements par leur nom, en attendant
	    # de faire mieux.
	    #

	    hiearchiser-liste-equipements thier [array names tabeq]
	    set arbre [generer-arbre-eq "" thier tabeq tabwifi $u1]
	    set t [::webapp::interactive-tree "leq" $arbre]

	    set head1  [lindex $t 0]
	    set head2  [lindex $t 1]
	    set onload [lindex $t 2]
	    set html   [lindex $t 3]

	    set header "$head1\n$head2\n"


	    #
	    # Sortie de la page
	    #

	    ::webapp::send html [::webapp::file-subst $conf(pagen) \
						[list \
							[list %OBJETS% "équipements"] \
							[list %LISTE%  $html] \
							[list %EQ%     $eq] \
							[list %VLAN%   ""] \
							[list %ADDR%   ""] \
							[list %URLUID% $u2] \
							[list %HEADER% $header] \
							[list %ONLOAD% $onload] \
						    ] \
					    ]
	}
    }

    #
    # Déconnexion de la base
    #

    fermer-base $dbfd
}

::webapp::cgi-exec main %DEBUG%
