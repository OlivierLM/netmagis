#!%TCLSH%

#
# Script pour traiter la modification d'une ou plusieurs
# interfaces de l'équipement.
#
# Called by: script ifchg
#
# Parameters (form or url):
#	- eq: equipment name
#	- iface : nom de l'interface (0 .. n)
#	- mode : "mono" ou "multi" (une seule interface ou plusieurs)
#	- vlan : id du vlan ou -1 pour désactiver le port
#	- voip : id du vlan ou -1 pour désactiver la voip sur l'interface
#	- desc : description (ou vide, notamment si plusieurs interfaces)
#	- stat : sondes (ou vide)
#
# History
#   2010/11/26 : pda/jean   : design
#   2010/11/30 : pda/jean   : add sensor
#


#
#


#
# Template pages used by this script
#

set conf(err)		erreur.html
set conf(page)		traiteifchg.html

#
# Next actions
# 

#################set conf(next)		"%HOMEURL%/bin/traiteifchg"
#################set conf(nextifchg)	"%HOMEURL%/bin/ifchg"

#
# Script parameters
#


set conf(form)	{
    {eq			1 1}
    {iface		0 999999}
    {mode		1 1}
    {vlan		1 1}
    {voip		1 1}
    {desc		0 1}
    {stat		0 1}
}

#
#

source %LIBDNS%

#
#

# ::webapp::cgidebug ; exit



##############################################################################
# Main procedure
##############################################################################

proc main {} {
    global conf

    #
    # Initialization
    #

    ::dnscontext create d
    d init-cgi "topo" $conf(err) "" $conf(form) ftab dbfd login tabuid

    ::webapp::import-vars ftab
    foreach f $conf(form) {
	set var [lindex $f 0]
	if {$var ne "iface"} then {
	    set $var [string trim [lindex [set $var] 0]]
	}
    }

    #
    # Lire les informations de l'équipement dans le graphe
    # Ces informations sont filtrées par tabuid qui n'affiche
    # que les vlans autorisés.
    #

    set l [eq-iflist $eq tabuid]

    lassign $l eq type model location liferr iflist arrayif arrayvlan
    array set tabiface $arrayif
    array set tabvlan  $arrayvlan

    #
    # En cas d'erreur, on sort prématurément
    # Ce cas correspond à une (ou plusieurs) interface qui serait
    # modifiable mais non consultable.
    #

    if {[llength $liferr] > 0} then {
	set texte "Incohérence sur les droits d'accès pour les interfaces : "
	append texte [join $liferr " "]
	return [list $titre $texte]
    }

    #
    # S'il n'y a pas d'interface, il n'y a rien à faire
    #

    if {[llength $iface] == 0} then {
	d error "Vous n'avez pas sélectionné d'interface"
    }

    #
    # Vérifier la cohérence et la "modifiabilité" des interfaces
    #

    foreach i $iface {
	if {! ([info exists tabiface($i)] &&
				[lindex $tabiface($i) 1] eq "edit")} then {
	    d error "Modification interdite pour l'interface '$i' sur '$eq'"
	}
    }

    #
    # Vérifier les paramètres
    #

    # vlan
    if {$vlan eq "-1"} then {
	# désactiver le port
    } elseif {[regexp {^[0-9]+$} $vlan] && [info exists tabvlan($vlan)]} then {
	lassign $tabvlan($vlan) vlandesc isvoip
	if {$isvoip} then {
	    d error "Vlan '$vlan' est un VLAN VoIP"
	}
    } else {
	d error "Vlan '$vlan' non trouvé"
    }

    # voip
    if {$voip eq "-1"} then {
	# désactiver la voip
    } elseif {[regexp {^[0-9]+$} $voip] && [info exists tabvlan($voip)]} then {
	lassign $tabvlan($voip) vlandesc isvoip
	if {! $isvoip} then {
	    d error "Vlan '$voip' n'est pas un VLAN VoIP"
	}
    } else {
	d error "Vlan '$vlan' non trouvé"
    }

    # description
    switch -- $mode {
	multi {
	    # topod ignore une description vide
	    set desc ""
	}
	mono {
	    # vérifier les caractères spéciaux et ajouter le X
	    if {[regexp {[^- a-zA-Z0-9+/()&.:#_]} $desc match]} then {
		d error "Caractère '$match' interdit dans la description"
	    }
	    # if user is admin, use the given sensor, else use the
	    # old sensor
	    if {! $tabuid(admin)} then {
		set i [lindex $iface 0]
		set stat [lindex $tabiface($i) 3]
	    }
	    if {$stat eq ""} then {
		set desc "X $desc"
	    } else {
		set desc "$desc <X $stat>"
	    }
	}
    }

    #
    # Chercher l'idrr de l'équipement
    #

    if {! [regexp {^([^.]+)\.(.+)$} $eq bidon host domain]} then {
	set host $eq
	set domain %DEFDOM%
    }

    set iddom [read-domain $dbfd $domain]
    if {$iddom == -1} then {
	d error "Erreur interne : domaine '$domain' non trouvé"
    }
    if {! [read-rr-by-name $dbfd $host $iddom tabrr]} then {
	d error "Erreur interne : équipement '$eq' non trouvé"
    }
    set idrr $tabrr(idrr)

    #
    # Insérer la ou les modifications dans la file d'attente
    #

    # le correspondant réel (i.e. pas celui auquel on s'est éventuellement
    # substitué)
    set qlogin [::pgsql::quote [lindex [d euid] 0]]
    set qifdesc [::pgsql::quote $desc]

    set sql {}
    foreach i $iface {
	set qiface [::pgsql::quote $i]
	lappend sql "INSERT INTO topo.ifchanges
			    (login, idrr, iface, ifdesc, ethervlan, voicevlan)
			VALUES ('$qlogin', $idrr, '$qiface',
					'$qifdesc', $vlan, $voip)"
    }
    set sql [join $sql ";"]
    if {! [::pgsql::execsql $dbfd $sql msg]} then {
	d error "Ajout dans la file d'attente impossible\n$msg"
    }

    #
    # Get status for graph building and spooled equipment modifications
    #

    if {[llength $iface] == 1} then {
	set eqsta [eq-graph-status $dbfd $eq $iface]
    } else {
	set eqsta [eq-graph-status $dbfd $eq]
    }

    #
    # End of script: output page and close database
    #

    d result $conf(page) [list \
			    [list %EQSTA%        $eqsta] \
			]
}

::webapp::cgi-exec main %DEBUG%
