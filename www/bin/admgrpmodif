#!%TCLSH%


#
# Script pour enregistrer les caractéristiques associées à un groupe
#
# Appelé par : index.htgt
#
# Paramètres (formulaire ou URL) :
#	- orggrp : nom du groupe originel ou "::nouveau"
#	- newgrp : nom du groupe modifié (eventuellement)
#	- admin : droit d'administration (0 ou 1)
#	- droitsmtp : droit d'autoriser des machines à émettre en smtp (0 ou 1)
#	- droitttl : droit de modifier les TTL des machines (0 ou 1)
#	- droitmac : droit d'accès au module MAC (0 ou 1)
#	- confirm : oui ou non
#	- loginN : les logins des membres du groupe
#	- domaineN : les noms des domaines validés pour ce groupe
#	- tridomN : la classe de tri d'un domaine (si vide, suppression)
#	- rolemailN : capacité d'éditer les rôles mail pour ce domaine (0 ou 1)
#	- rolewebN : capacité d'éditer les rôles web pour ce domaine (0 ou 1)
#	- reseauN : les id des réseaux valides pour ce groupe
#	- triresN : la classe de tri d'un réseau (si vide, suppression)
#	- dhcpN : capacité d'éditer les intervalles DHCP pour ce réseau (0 ou 1)
#	- aclN : capacité d'éditer les ACL pour ce réseau (0 ou 1)
#	- adrN et allow_denyN : droits IP associés à ce groupe
#	- tridhcpprofN : classe de tri d'un profil DHCP (si vide, suppression)
#	- nomdhcpprofN : nom du profil DHCP
#	- eqrwN : type de droit sur l'équipement (0 ou 1)
#	- eqallowN : allow/deny sur l'équipement (0 ou 1)
#	- eqpatN : pattern de droit sur l'équipement (regexp, si vide : suppr)
#
# Historique
#   2002/05/21 : pda/jean : création
#   2002/07/09 : pda      : ajout de nologin
#   2003/05/13 : pda/jean : utilisation de la base d'authentification
#   2004/01/14 : pda/jean : ajout IPv6
#   2004/02/12 : pda/jean : ajout rôles
#   2004/08/06 : pda/jean : extensions des droits sur les réseaux
#   2005/04/08 : pda/jean : profils dhcp
#   2007/10/10 : pda/jean : centralisation de l'administration des groupes
#   2008/07/23 : pda/jean : ajout droitsmtp
#   2010/10/31 : pda      : ajout droitttl
#   2010/11/03 : pda/jean : ajout dr_eq
#   2010/11/30 : pda/jean : ajout droitmac
#

set conf(homeurl)	%HOMEURL%

#
# Chemins utilisés par les scripts
#

set conf(lib)		%DESTDIR%/lib
set conf(libdns)	$conf(lib)/libdns.tcl

#
# Définition des noms des pages "à trous"
#

set conf(err)		$conf(lib)/erreur.html
set conf(page)		$conf(lib)/admgrpmodif.html
set conf(confirm)	$conf(lib)/admgrpconfirm.html
set conf(confsuppr)	$conf(lib)/admgrpconfsuppr.html
set conf(supprok)	$conf(lib)/admgrpsupprok.html

#
# Scripts suivants (actions de formulaire)
# 

set conf(next)		"%HOMEURL%/bin/admgrpmodif"

#
# Quelques paramètres du script
#

set conf(form) {
	{confirm		1 1}
	{orggrp			1 1}
	{newgrp			1 1}
	{admin			1 1}
	{droitsmtp		1 1}
	{droitttl		1 1}
	{droitmac		1 1}
	{login[0-9]+		0 9999}
	{tridom[0-9]+		0 9999}
	{domaine[0-9]+		0 9999}
	{rolemail[0-9]+		0 9999}
	{roleweb[0-9]+		0 9999}
	{trires[0-9]+		0 9999}
	{reseau[0-9]+		0 9999}
	{dhcp[0-9]+		0 9999}
	{acl[0-9]+		0 9999}
	{adr[0-9]+		0 9999}
	{allow[0-9]+		0 9999}
	{tridhcpprof[0-9]+	0 9999}
	{nomdhcpprof[0-9]+	0 9999}
	{eqrw[0-9]+		0 9999}
	{eqallow[0-9]+		0 9999}
	{eqpat[0-9]+		0 9999}
}

#
# Les outils du parfait concepteur de pages Web dynamiques...
#

lappend auto_path %PKGTCL%
package require webapp
package require pgsql
package require arrgen

#
# On y va !
#

# ::webapp::cgidebug ; exit

source $conf(libdns)

##############################################################################
# Procédures utilitaires
##############################################################################

#
# Valider le nom du groupe, et récupérer son identifiant numérique
#

proc valide-groupe {dbfd groupe existant} {
    global conf

    set qgroupe [::pgsql::quote $groupe]
    set idgrp -1
    pg_select $dbfd "SELECT idgrp FROM global.groupe WHERE nom = '$qgroupe'" tab {
	set idgrp $tab(idgrp)
    }

    if {$existant} then {
	# On veut que le groupe existe
	if {$idgrp == -1} then {
	    d error "Groupe '$groupe' non trouvé"
	}
    } else {
	# On veut que le groupe n'existe pas encore
	# Vérifier d'abord la syntaxe...
	set msg [syntaxe-groupe $groupe]
	if {! [string equal $msg ""]} then {
	    d error $msg
	}
	# ... et ensuite, vérifier que le groupe est inconnu
	if {$idgrp != -1} then {
	    d error "Le groupe '$groupe' existe déjà"
	}
    }

    return $idgrp
}

#
# Suppression d'un groupe
#

proc supprime-groupe {dbfd idgrp idorphelin} {

    set ltab {global.groupe global.corresp
		dns.dr_reseau dns.dr_mbox dns.dr_ip dns.dr_dom dns.dr_dhcpprofil}
    if {! [::pgsql::lock $dbfd $ltab msg]} then {
	return $msg
    } 

    #
    # Supprime les droits
    #

    foreach table {dns.dr_reseau dns.dr_mbox dns.dr_ip dns.dr_dom dns.dr_dhcpprofil} {
	set sql "DELETE FROM $table WHERE idgrp = $idgrp"
	if {! [::pgsql::execsql $dbfd $sql msg]} then {
	    ::pgsql::unlock $dbfd "abort" m
	    return $msg
	}
    }

    #
    # Extrait tous les correspondants qui doivent rester orphelins
    #

    set sql "SELECT corresp.idcor
		FROM global.corresp, dns.rr
		WHERE corresp.idgrp = $idgrp AND rr.idcor = corresp.idcor
		GROUP BY corresp.idcor"
    
    set lidcor {}
    pg_select $dbfd $sql tab {
	lappend lidcor $tab(idcor)
    }

    # 
    # Réaffecter ces correspondants
    # 

    if {[llength $lidcor] > 0} then {
	set lcor [join $lidcor ","]
	set sql "UPDATE global.corresp SET idgrp = $idorphelin, present = 0
		    WHERE idcor IN ($lcor)"
	if {! [::pgsql::execsql $dbfd $sql msg]} then {
	    ::pgsql::unlock $dbfd "abort" m
	    return $msg
	} 
    }

    #
    # Supprime les correspondants restants et le groupe
    #

    foreach table {global.corresp global.groupe} {
	set sql "DELETE FROM $table WHERE idgrp = $idgrp"
	if {! [::pgsql::execsql $dbfd $sql msg]} then {
	    ::pgsql::unlock $dbfd "abort" m
	    return $msg
	}
    }

    if {! [::pgsql::unlock $dbfd "commit" msg]} then {
	return $msg
    }

    return ""
}

##############################################################################
# Programme principal
##############################################################################

proc main {} {
    global conf
    global ah

    #
    # Initialisation
    #

    ::dnscontext create d
    d init-cgi "admin" $conf(err) "admin" $conf(form) ftab dbfd login tabcor

    set orggrp  [lindex $ftab(orggrp) 0]
    set newgrp  [lindex $ftab(newgrp) 0]
    set confirm [lindex $ftab(confirm) 0]

    #
    # Créer le groupe des orphelins si nécessaire
    #

    set idorphelin -1
    pg_select $dbfd "SELECT idgrp FROM global.groupe WHERE nom = ''" tab {
	set idorphelin $tab(idgrp)
    }
    
    if {$idorphelin == -1} then {
	set sql "INSERT INTO global.groupe (nom, admin, droitsmtp, droitttl, droitmac)
			    VALUES ('', 0, 0, 0, 0)"
	if {! [::pgsql::execsql $dbfd $sql msg]} then {
	    ::pgsql::unlock $dbfd "abort" m
	    return $msg
	} 
	pg_select $dbfd "SELECT idgrp FROM global.groupe WHERE nom = ''" tab {
	    set idorphelin $tab(idgrp)
	}
    }

    #
    # Déterminer dans quel cas on se trouve
    #

    set etat [string equal $orggrp "::nouveau"][string equal $newgrp ""] 
    switch $etat {
	11 {
	    d error "Il faut saisir un nom de groupe"
	}
	01 {
	    set action "suppression"
	}
	10 {
	    set action "création"
	    valide-groupe $dbfd $newgrp 0
	    set msgact "création du groupe $newgrp"
	    set idgrp -1
	}
	00 {
	    set action "édition"
	    set msgact "modification du groupe $orggrp"
	    set idgrp [valide-groupe $dbfd $orggrp 1]

	    # Renommage
	    if {! [string equal $orggrp $newgrp]} then {
		valide-groupe $dbfd $newgrp 0
	    }
	}
    }

    #
    # Suppression
    #

    if {[string equal $action "suppression"]} then {
	set idgrp [valide-groupe $dbfd $orggrp 1]
	if {! [string equal $confirm "oui"]} then {
	    # Demander confirmation
	    set ftab(confirm)	{oui}
	    set lchamps [array names ftab]
	    set hidden  [::webapp::hide-parameters $lchamps ftab]
	    d urlset "%URLFORM%" $conf(next) {}
	    d result $conf(confsuppr) [list \
					[list %ORGGRP%	$orggrp] \
					[list %HIDDEN%	$hidden] \
				    ]
	} else {
	    # Procéder à la suppression
	    set msg [supprime-groupe $dbfd $idgrp $idorphelin]
	    if {! [string equal $msg ""]} then {
		d error "Suppression impossible ($msg)"
	    }
	    d result $conf(supprok) [list \
					[list %ORGGRP%	$orggrp] \
				    ]
	}
	exit 0
    }

    #
    # Tout ce qui suit concerne la creation ou la modification d'un
    # groupe existant
    # Validation de l'existence et des droits.
    #
    
    #
    # Tester le champ admin
    #

    set admin [lindex $ftab(admin) 0]
    if {! ([string equal $admin 0] || [string equal $admin 1])} then {
	d error "Champ 'admin' invalide"
    }

    #
    # Tester le champ droitsmtp
    #

    set droitsmtp [lindex $ftab(droitsmtp) 0]
    if {! ([string equal $droitsmtp 0] || [string equal $droitsmtp 1])} then {
	d error "Champ 'droitsmtp' invalide"
    }

    #
    # Tester le champ droitttl
    #

    set droitttl [lindex $ftab(droitttl) 0]
    if {! ([string equal $droitttl 0] || [string equal $droitttl 1])} then {
	d error "Champ 'droitttl' invalide"
    }

    #
    # Tester le champ droitmac
    #

    set droitmac [lindex $ftab(droitmac) 0]
    if {! ([string equal $droitmac 0] || [string equal $droitmac 1])} then {
	d error "Champ 'droitmac' invalide"
    }

    #
    # Tester les logins :
    # - récupérer tous les logins
    # - noter les orphelins à réaffecter
    # - signaler une erreur si le login est déjà affecté à un autre groupe
    # - noter les logins à créer
    # - noter les logins à supprimer
    #
    
    # On récupère tous les correspondants

    set sql "SELECT corresp.login, groupe.nom, groupe.idgrp
		FROM global.corresp, global.groupe
		WHERE corresp.idgrp = groupe.idgrp"
    pg_select $dbfd $sql tab {
	if {[string equal $tab(nom) ""]} then {
	    set torph($tab(login)) ""
	} else {
	    set tcor($tab(login)) [list $tab(idgrp) $tab(nom)]
	}
    }

    set lcorcreate {}
    set lcoraffect {}
    set lcordelete {}
    set n 1
    while {[info exists ftab(login$n)]} {
	set login [string trim [lindex $ftab(login$n) 0]]
	if {[string length $login] > 0} then {
	    if {[info exists torph($login)]} then {
		lappend lcoraffect $login
	    } elseif {[info exists tcor($login)]} then {
		if {$idgrp != [lindex $tcor($login) 0]} then {
		    set g [lindex $tcor($login) 1]
		    d error "Login '$login' déjà affecté au groupe '$g'"
		}
		unset tcor($login)
	    } else {
		lappend lcorcreate $login
	    }
	}
	incr n
    }

    foreach login [array names tcor] {
	if {[lindex $tcor($login) 0] == $idgrp} then {
	    lappend lcordelete $login
	}
    }

    #
    # Tester la validité des domaines, et construire la liste
    # des identificateurs de domaines
    #

    foreach ld [::pgsql::getcols $dbfd dns.domaine "" "" {iddom nom}] {
	set iddom [lindex $ld 0]
	set nom   [lindex $ld 1]
	set tabdom($nom) $iddom
    }

    set liddom {}
    set n 1
    while {[info exists ftab(tridom$n)] && [info exists ftab(domaine$n)]} {
	set tri [string trim [lindex $ftab(tridom$n) 0]]
	if {[string length $tri] > 0} then {
	    if {! [regexp -- {^[0-9]+$} $tri]} then {
		d error "Classe de tri de domaine invalide ($tri)"
	    }

	    set domaine [string trim [lindex $ftab(domaine$n) 0]]
	    if {! [info exists tabdom($domaine)]} then {
		d error "Domaine invalide ($domaine)"
	    }

	    if {! [info exists ftab(rolemail$n)]} then {
		set ftab(rolemail$n) 0
	    }
	    set rolemail [string trim [lindex $ftab(rolemail$n) 0]]
	    if {! [regexp -- {^[01]$} $rolemail]} then {
		d error "Role mail invalide ($rolemail)"
	    }

	    if {! [info exists ftab(roleweb$n)]} then {
		set ftab(roleweb$n) 0
	    }
	    set roleweb [string trim [lindex $ftab(roleweb$n) 0]]
	    if {! [regexp -- {^[01]$} $roleweb]} then {
		d error "Role web invalide ($roleweb)"
	    }

	    lappend liddom [list $tri $tabdom($domaine) $rolemail $roleweb]
	}

	incr n
    }

    #
    # Tester la validité des identificateurs de réseaux et construire
    # la liste des identificateurs de réseaux
    #

    foreach ld [::pgsql::getcols $dbfd dns.reseau "" "" {idreseau adr4 adr6 dhcp}] {
	set idreseau [lindex $ld 0]
	set ladr {}
	foreach i {1 2} {
	    set a [lindex $ld $i]
	    if {! [string equal $a ""]} then {
		lappend ladr $a
	    }
	}
	set tabres($idreseau) $ladr
	set tabdhcp($idreseau) [lindex $ld 3]
    }

    set lidres {}
    set n 1
    while {[info exists ftab(trires$n)] && [info exists ftab(reseau$n)]} {
	set tri [string trim [lindex $ftab(trires$n) 0]]
	if {[string length $tri] > 0} then {
	    if {! [regexp -- {^[0-9]+$} $tri]} then {
		d error "Classe de tri de réseau invalide ($tri)"
	    }

	    set idreseau [string trim [lindex $ftab(reseau$n) 0]]
	    if {! [info exists tabres($idreseau)]} then {
		d error "Réseau invalide ($idreseau)"
	    }

	    if {! [info exists ftab(dhcp$n)]} then {
		set ftab(dhcp$n) 0
	    }
	    set dhcp [string trim [lindex $ftab(dhcp$n) 0]]
	    if {! [regexp -- {^[01]$} $dhcp]} then {
		d error "Droit DHCP invalide ($dhcp)"
	    }

	    if {! [info exists ftab(acl$n)]} then {
		set ftab(acl$n) 0
	    }
	    set acl [string trim [lindex $ftab(acl$n) 0]]
	    if {! [regexp -- {^[01]$} $acl]} then {
		d error "Droit ACL invalide ($acl)"
	    }

	    lappend lidres [list $tri $idreseau $dhcp $acl]
	}

	incr n
    }

    #
    # Tester la validité syntaxique des droits IP
    #

    set n 1
    set ldrip {}
    set droits_allow {}
    while {[info exists ftab(adr$n)] && [info exists ftab(allow$n)]} {
	set allow_deny [lindex $ftab(allow$n) 0]
	if {!([string equal $allow_deny "0"] || \
		[string equal $allow_deny "1"])} then {
	    d error "Valeur incorrecte pour allow/deny '$allow_deny'"
	}

	set adr [string trim [lindex $ftab(adr$n) 0]]
	if {[string length $adr] != 0} then {
	    set m [syntaxe-ip $dbfd $adr "cidr"]
	    if {[string length $m] > 0} then {
		d error "CIDR incorrect '$adr'"
	    }

	    lappend ldrip [list $allow_deny $adr]
	    if {$allow_deny} then {
		lappend droits_allow $adr
	    }
	}

	incr n
    }

    #
    # Tester la validité syntaxique des droits sur les équipements
    #

    set n 1
    set ldreq {}
    while {[info exists ftab(eqpat$n)] &&
		[info exists ftab(eqrw$n)] &&
		[info exists ftab(eqallow$n)]} {

	set rw [lindex $ftab(eqrw$n) 0]
	if {!($rw eq "0" || $rw eq "1")} then {
	    d error "Valeur incorrecte pour read/write '$rw'"
	}

	set allow_deny [lindex $ftab(eqallow$n) 0]
	if {!($allow_deny eq "0" || $allow_deny eq "1")} then {
	    d error "Valeur incorrecte pour allow/deny '$allow_deny'"
	}

	set pattern [string trim [lindex $ftab(eqpat$n) 0]]
	if {$pattern ne ""} then {
	    if {[catch {regexp $pattern ""} msg]} then {
		d error "Incorrect pattern '$msg'"
	    }

	    lappend ldreq [list $rw $allow_deny $pattern]
	}

	incr n
    }

    #
    # Tester la validité des noms de profils DHCP
    #

    foreach ld [::pgsql::getcols $dbfd dns.dhcpprofil "" "" {iddhcpprofil nom}] {
	set iddhcpprofil [lindex $ld 0]
	set nom          [lindex $ld 1]
	set tabdhcpprofil($nom) $iddhcpprofil
    }

    set lidprof {}
    set n 1
    while {[info exists ftab(tridhcpprof$n)] && [info exists ftab(nomdhcpprof$n)]} {
	set tri [string trim [lindex $ftab(tridhcpprof$n) 0]]
	if {[string length $tri] > 0} then {
	    if {! [regexp -- {^[0-9]+$} $tri]} then {
		d error "Classe de tri de profil DHCP invalide ($tri)"
	    }

	    set dhcpprofil [string trim [lindex $ftab(nomdhcpprof$n) 0]]
	    if {! [info exists tabdhcpprofil($dhcpprofil)]} then {
		d error "Profil DHCP invalide ($dhcpprofil)"
	    }

	    lappend lidprof [list $tri $tabdhcpprofil($dhcpprofil)]
	}

	incr n
    }

    ## FIN VALIDATION EXISTANCE ET DROITS ####################################

    #
    # Tester la cohérence des données
    #

    if {! [string equal $confirm "oui"]} then {
	#
	# - au moins un domaine
	# - au moins un réseau
	# - tout réseau a un ou plusieurs droits IP affectés
	#	autrement dit, un correspondant peut bien accéder à
	#	une plage dans les réseaux qui lui sont présentés.
	# - tout droit IP est dans un réseau
	#	autrement dit, on n'affecte pas à un correspondant
	#	des droits plus grands que les réseaux auxquels il
	#	a droit
	# Si une au moins de ces conditions est fausse, on demande
	# confirmation à l'administrateur : on doit pouvoir passer
	# outre (exemple typique : l'administrateur a droit à tous
	# les réseaux via un seul droit CIDR par exemple).
	#

	set incoherences {}

	# logins inexistants dans la base d'authentification

	set u [::webapp::authuser create %AUTO%]
	set n 1
	while {[info exists ftab(login$n)]} {
	    set login [string trim [lindex $ftab(login$n) 0]]
	    if {[string length $login] > 0} then {
		if {[catch {set nb [$ah getuser $login $u]} m]} then {
		    d error "Problème dans la base d'authentification ($m)"
		}
		switch $nb {
		    0 {
			lappend incoherences "Le login '$login' n'existe pas"
		    }
		    1 {
			# rien
		    }
		    default {
			d error "Login '$login' ambigu"
		    }
		}
	    }
	    incr n
	}
	
	# au moins un domaine
	if {[llength $liddom] == 0} then {
	    lappend incoherences "Aucun domaine sélectionné"
	}

	# au moins un réseau
	if {[llength $lidres] == 0} then {
	    lappend incoherences "Aucun réseau sélectionné"
	}

	# autoriser l'accès dhcp nécessite que le réseau soit dhcp-capable
	foreach r $lidres {
	    set idreseau [lindex $r 1]
	    set dhcp [lindex $r 2]
	    if {$dhcp && ! $tabdhcp($idreseau)} then {
		lappend incoherences "Réseau $tabres($idreseau) n'a pas la capacité DHCP"
	    }
	}

	# tout réseau a au moins un droit de type "allow"
	foreach r $lidres {
	    set idreseau [lindex $r 1]
	    foreach adr $tabres($idreseau) {
		set aucun_droit 1
		foreach dr $droits_allow {
		    pg_select $dbfd "SELECT '$adr' >>= '$dr' AS resultat" tab {
			set resultat $tab(resultat)
		    }
		    if {[string equal $resultat "t"]} then {
			set aucun_droit 0
			break
		    }
		}
		if {$aucun_droit} then {
		    lappend incoherences \
			    "Aucun droit 'allow' trouvé pour le réseau '$adr'"
		}
	    }
	}

	# aucun droit de type "allow" n'est plus grand qu'un réseau
	foreach dr $droits_allow {
	    set plus_grand 0
	    foreach r $lidres {
		set idreseau [lindex $r 1]
		foreach adr $tabres($idreseau) {
		    set sql "SELECT cidr '$adr' << cidr '$dr' AS resultat"
		    pg_select $dbfd $sql tab {
			set resultat $tab(resultat)
		    }
		    if {[string equal $resultat "t"]} then {
			set plus_grand 1
			break
		    }
		}
	    }

	    if {$plus_grand} then {
		lappend incoherences "Le droit 'allow - $dr' est trop grand"
	    }
	}

	#
	# S'il y a des incohérences, les annoncer et demander
	# confirmation.
	#

	if {[llength $incoherences] > 0} then {
	    set ftab(confirm)	{oui}
	    set lchamps [array names ftab]
	    set hidden  [::webapp::hide-parameters $lchamps ftab]
	    set message [join $incoherences "<BR>\n"]
	    d urlset "%URLFORM%" $conf(next) {}
	    d result $conf(confirm) [list \
					[list %MSGACT%	$msgact] \
					[list %ORGGRP%	$orggrp] \
					[list %HIDDEN%	$hidden] \
					[list %MESSAGE%	$message] \
			    ]
	    exit 0
	}
    }

    ## FIN VALIDATION COHERENCE ####################################

    #
    # Si on arrive ici, c'est que les données sont cohérentes,
    # ou qu'on a eu confirmation de la demande. Il faut donc
    # enregistrer les données dans la base.
    # Toutes les modifications se font par suppression totale
    # des éléments, puis ré-insertion à partir de ce qui est
    # fourni dans le formulaire
    #

    set ltab {global.groupe global.corresp
		dns.dr_reseau dns.dr_mbox dns.dr_ip dns.dr_dom dns.dr_dhcpprofil} 
    if {! [::pgsql::lock $dbfd $ltab msg]} then {
	return $msg
    } 

    # Création du groupe si nécessaire

    if {[string equal $action "création"]} then {
	set qnewgrp [::pgsql::quote $newgrp]
	set sql "INSERT INTO global.groupe (nom, admin, droitsmtp, droitttl, droitmac)
			VALUES ('$qnewgrp', $admin, $droitsmtp, $droitttl, $droitmac)"
	if {! [::pgsql::execsql $dbfd $sql msg]} then {
	    ::pgsql::unlock $dbfd "abort" m
	    return $msg
	} 
    } else {

	# Édition d'un groupe existant

	set qorggrp [::pgsql::quote $orggrp]

	if {! [string equal $orggrp $newgrp]} then {

	    # Renommage du groupe
	    set qnewgrp [::pgsql::quote $newgrp]
	    set sql "UPDATE global.groupe SET nom = '$qnewgrp' WHERE nom = '$qorggrp'"
	    if {! [::pgsql::execsql $dbfd $sql msg]} then {
		::pgsql::unlock $dbfd "abort" m
		return $msg
	    }
	}
    }

    # Récupère l'identifiant du groupe

    set qnewgrp [::pgsql::quote $newgrp]
    set idgrp -1
    pg_select $dbfd "SELECT idgrp FROM global.groupe WHERE nom = '$qnewgrp'" tab {
	set idgrp $tab(idgrp)
    }
    if {$idgrp == -1} then {
	d error "Erreur interne : groupe '$newgrp' non trouvé"
    }

    # Mettre a jour les attributs du groupe
    lappend cmd "UPDATE global.groupe
		    SET admin = $admin,
			droitsmtp = $droitsmtp,
			droitttl = $droitttl,
			droitmac = $droitmac
		    WHERE idgrp = $idgrp"

    # Créer ou affecter les correspondants

    if {[llength $lcorcreate] > 0} then {
	foreach login $lcorcreate {
	    set qlogin [::pgsql::quote $login]
	    lappend cmd "INSERT INTO global.corresp (login,present,idgrp)
			    VALUES ('$qlogin',1,$idgrp)"
	}
    }
    if {[llength $lcoraffect] > 0} then {
	foreach login $lcoraffect {
	    set qlogin [::pgsql::quote $login]
	    lappend cmd "UPDATE global.corresp SET idgrp = $idgrp
			    WHERE login = '$qlogin'"
	}
    }

    # On réaffecte tous les correspondants à supprimer au groupe orphelin

    if {[llength $lcordelete] > 0} then {
	foreach login $lcordelete {
	    set qlogin [::pgsql::quote $login]
	    lappend cmd "UPDATE global.corresp SET idgrp = $idorphelin
			    WHERE login = '$qlogin'"
	}
    }

    # On nettoie tous les correspondants inutiles

    lappend cmd "DELETE FROM global.corresp 
			WHERE idgrp = $idorphelin 
			    AND idcor NOT IN (SELECT DISTINCT idcor FROM dns.rr)"

    # Les domaines autorisés pour le groupe

    lappend cmd "DELETE FROM dns.dr_dom WHERE idgrp = $idgrp"

    foreach e $liddom {
	set tri      [lindex $e 0]
	set iddom    [lindex $e 1]
	set rolemail [lindex $e 2]
	set roleweb  [lindex $e 3]
	lappend cmd "INSERT INTO dns.dr_dom (idgrp, iddom, tri, rolemail, roleweb)
			VALUES ($idgrp, $iddom, $tri, $rolemail, $roleweb)"
    }

    # Les réseaux autorisés pour le groupe

    lappend cmd "DELETE FROM dns.dr_reseau WHERE idgrp = $idgrp"

    foreach r $lidres {
	set tri      [lindex $r 0]
	set idreseau [lindex $r 1]
	set dhcp     [lindex $r 2]
	set acl      [lindex $r 3]
	lappend cmd "INSERT INTO dns.dr_reseau (idgrp, idreseau, tri, dhcp, acl)
			VALUES ($idgrp, $idreseau, $tri, $dhcp, $acl)"
    }

    # Les droits IP associés au groupe

    lappend cmd "DELETE FROM dns.dr_ip WHERE idgrp = $idgrp"

    foreach e $ldrip {
	set allow_deny [lindex $e 0]
	set adr        [lindex $e 1]
	lappend cmd "INSERT INTO dns.dr_ip VALUES ($idgrp, '$adr', $allow_deny)"
    }

    # Les droits sur les équipements (topo) associés au groupe

    lappend cmd "DELETE FROM topo.dr_eq WHERE idgrp = $idgrp"

    foreach e $ldreq {
	lassign $e rw allow_deny pattern
	set pattern [::pgsql::quote $pattern]
	lappend cmd "INSERT INTO topo.dr_eq (idgrp, rw, allow_deny, pattern)
				VALUES ($idgrp, $rw, $allow_deny, '$pattern')"
    }

    # Les profils DHCP visibles par le groupe

    lappend cmd "DELETE FROM dns.dr_dhcpprofil WHERE idgrp = $idgrp"

    foreach e $lidprof {
	set tri          [lindex $e 0]
	set iddhcpprofil [lindex $e 1]
	lappend cmd "INSERT INTO dns.dr_dhcpprofil (idgrp, iddhcpprofil, tri)
			VALUES ($idgrp, $iddhcpprofil, $tri)"
    }

    #
    # Modifications dans la base
    #

    foreach sql $cmd {
	if {! [::pgsql::execsql $dbfd $sql msg]} then {
	   ::pgsql::unlock $dbfd "abort" m
	   d error "L'opération '$sql' a échoué. Abandon.\n$msg"
	}
    }

    if {! [::pgsql::unlock $dbfd "commit" msg]} then {
       ::pgsql::unlock $dbfd "abort" m
       d error "L'insertion a échoué. Abandon.\n$msg"
    }

    #
    # Récupération du code HTML d'affichage des caractéristiques
    # du groupe auquel appartient le correspondant
    #

    set grospaquet [info-groupe $dbfd $idgrp]
    lassign $grospaquet \
		tabdroits tablogins tabreseaux tabcidrhorsreseau \
		tabdomaines tabdhcpprofils tabdreq

    #
    # Fin du script : sortie de la page et fermeture de la base
    #

    d result $conf(page) [list \
			    [list %NEWGRP% $newgrp] \
			    [list %TABLOGINS% $tablogins] \
			    [list %TABDROITS% $tabdroits] \
			    [list %TABRESEAUX% $tabreseaux] \
			    [list %TABCIDRHORSRESEAU% $tabcidrhorsreseau] \
			    [list %TABDOMAINES% $tabdomaines] \
			    [list %TABDHCPPROFILS% $tabdhcpprofils] \
			    [list %TABDREQ% $tabdreq] \
			]
}

::webapp::cgi-exec main %DEBUG%
