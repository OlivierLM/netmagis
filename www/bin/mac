#!%TCLSH%

#
# Script qui recherche un nom ou une adresse (IP ou MAC)
# dans la base Mac et qui affiche l'ensemble
# sessions correspondantes (historique des occurences
# de cette adresse sur le réseau)
#
# Historique
#   2004/11/14 : jean : conception
#   2005/06/04 : jean : optimisation de la recherche (gen-ipmac et gen-portmac)
#                       disparition des jointures sql, 2 requetes et trait. tcl
#   2010/11/30 : pda/jean : integration a WebDNS
#

set conf(homeurl)       %HOMEURL%

#
# Chemins utilisés par les scripts
#

set conf(lib)           %DESTDIR%/lib
set conf(libdns)        $conf(lib)/libdns.tcl

set conf(cmdhost)	"/usr/bin/host"

#
# Définition des noms des pages "à trous"
#

set conf(page)          $conf(lib)/mac.html
set conf(pagesearch)	$conf(lib)/macsearch.html
set conf(err)           $conf(lib)/erreur.html

#
# Scripts suivants (actions de formulaire)
#

set conf(next)		"%HOMEURL%/bin/mac"

#
# Formats du tableau
#

set conf(tabsession) {
    global {
        chars {12 normal}
        align {left}
        botbar {yes}
        columns {15 35 15 35}
    }   
    pattern Titre {
        vbar {yes}
        column { 
            multicolumn {4}
            align {center}
            chars {14 bold}
        }
        vbar {yes}
    }
    pattern Rem {
        vbar {yes}
        column { 
            multicolumn {4}
            align {center}
            chars {14}
        }
        vbar {yes}
    }
    pattern Close {
        vbar {yes}
        column {
            multicolumn {2}
        }   
        vbar {yes} 
        column {
            multicolumn {2}
        }   
        vbar {yes}
    }
    pattern Active {
        vbar {yes}
        column {
            multicolumn {2}
            chars {bold}
        }
        vbar {yes}
        column {
            multicolumn {2}
            chars {bold}
        }   
        vbar {yes}
    }   
    pattern Info {
        vbar {yes}
        column {
	}
        vbar {yes}
        column {
            multicolumn {3}
            chars {bold}
	    format {raw}
        }
        vbar {yes}
    }
}

set conf(tabmenuipmac) {
    global {
        chars {12 normal}
        align {left}
        botbar {yes}
        columns {12 48 15 25}
    }   
    pattern Data {
        vbar {yes}
        column {
	    format {raw}
	}
        vbar {yes}
        column { 
	    format {raw}
	}
        vbar {yes}
        column {
	    format {raw}
	}
        vbar {yes} 
        column { }
        vbar {yes}
    }
    pattern Titre {
        vbar {yes}
        column { 
            chars {bold}
	}
        vbar {yes}
        column { 
            chars {bold}
	}
        vbar {yes}
        column {
            chars {bold}
        }
        vbar {yes} 
        column {
            chars {bold}
        }
        vbar {yes}
    }
}

set conf(tabmenuportmac) {
    global {
        chars {12 normal}
        align {left}
        botbar {yes}
        columns {5 5 10 10 25 25}
    }   
    pattern Data {
        vbar {yes}
        column {
	    format {raw}
	}
        vbar {yes}
        column { 
	    format {raw}
	}
        vbar {yes}
        column {
	    format {raw}
	}
        vbar {yes} 
        column {
	}
        vbar {yes}
        column {
	    format {raw}
	}
        vbar {yes}
        column {
	}
        vbar {yes}
    }
    pattern Titre {
        vbar {yes}
        column { 
            chars {bold}
	}
        vbar {yes}
        column { 
            chars {bold}
	}
        vbar {yes}
        column { 
            chars {bold}
	}
        vbar {yes}
        column {
            chars {bold}
        }
        vbar {yes} 
        column {
            chars {bold}
        }
        vbar {yes}
        column {
            chars {bold}
        }
        vbar {yes}
    }
}

#
# Quelques paramètres du script
#

set conf(dbmac)          %BASEMAC%

set conf(form)          {
    {recherche    0 1}
}

set conf(sqldateformat) {'DD/MM/YYYY HH24:MI:SS'}
set conf(clockformat)   {%d/%m/%Y %H:%M:%S}

lappend auto_path %PKGTCL%
package require webapp
package require arrgen
package require pgsql

#
# On y va !
#

# ::webapp::cgidebug ; exit

source $conf(libdns)

#
# Détermine le type de paramètre
#
# Entree : 
#   dbfd : acces a la base de donnee (utilise pour check-ip-syntax)
#   recherche : objet de la recherche à identifier
# Sortie :
#   Retourne une liste constituée de deux éléments : {type param}
#	- type = "ip", "nom", "mac", "idipmac", ... 
#	- type = param : objet de la recherche après décomposition éventuelle
#       Si le type est indeterminé, retourne une liste vide.
#   varmsg : message d'erreur eventuel
#
proc determine-type {dbfd recherche varmsg} {
    upvar $varmsg msg

    set type ""
    set param $recherche

    set msg  ""

    if { [regexp {^[0-9a-f]{1,2}(:[0-9a-f]{1,2}){5}$} $recherche] } {
	# Adresse MAC
	set type "mac"
    }
    if { [regexp {^[0-9a-f]{4}(.[0-9a-f]{4}){2}$} $recherche] } {
	# Adresse MAC (au format cisco : 00AB.1234.5678), conversion
	set n {([0-9a-f]{2})}
	regsub  "^$n$n.$n$n.$n$n" $recherche {\1:\2:\3:\4:\5:\6} recherche
	set type "mac"
    } elseif { [regexp {^idportmac:([0-9]+)$} $recherche bidon idportmac] } {
        # ID portmac
	set type "idportmac"
	set param $idportmac
    } elseif { [regexp {^idipmac:([0-9]+)$} $recherche bidon idipmac] } {
        # ID ipmac
	set type "idipmac"
	set param $idipmac
    } elseif { [regexp {^eq:([a-z0-9\-.]+)$} $recherche bidon eq] } {
        # Par équipement
	set type "equipement"
	set param $eq
    } elseif { [regexp {^vlan:([a-z0-9\-.]+)$} $recherche bidon vlan] } {
        # Par VLAN
	set type "vlan"
	set param $vlan
    } elseif { [regexp {^([0-9.]+|[0-9a-f:.]+)$} $recherche] } {
	# Adresse IP
        set msg [check-ip-syntax $dbfd $recherche "inet"]
        if { [string equal $msg ""]} {
  	    set type "ip"
        }
    } elseif { [regexp {^[a-z0-9\-.]+$} $recherche] } {
        # Nom
	set type "nom"
    } else {
	# Autres
	set msg "Chaine de recherche '$recherche' incorrecte"
	return {}
    }

    return [list $type $param]
}

#
# Génère un tableau html contenant le résultat de la recherche
#
# Entrée :
#   dbfd   : accès à la base de donnée
#   type   : type de recherche (ip, mac, etc.)
#   param : critère de recherche
# Sortie :
#   retourne le code html de résultat
#
proc gen-res {dbfd type param} {
    global conf

    set tab ""

    #
    # Effectue la recherche en fonction du type
    #

    switch $type {
	nom {
	    set lip [resolution "nom" $param]
	    foreach ip $lip {
		append tab [gen-ipmac $dbfd $ip ""]
	    }
	}
	ip {
	    append tab [gen-ipmac $dbfd $param ""]
	}
	idipmac {
	    append tab [gen-idipmac-session $dbfd $param]
	}
	idportmac {
	    append tab [gen-idportmac-session $dbfd $param]
	}
	equipement {
	    append tab [gen-eq $dbfd $param]
	}
	vlan {
	    append tab [gen-vlan $dbfd $param]
	}
	mac {
	    append tab [gen-ipmac      $dbfd "" $param]
 	    append tab [gen-mac    $dbfd $param]
	}
	default {
	    ::webapp::error-exit $conf(err) "type de parametre"
	}
    }

    return $tab
}

#
# Génère un tableau pour une session ipmac
# Entre :
#      idipmac : identifiant d'un couple ip-mac
#

proc gen-idipmac-session {dbfd idipmac} {
    global conf

    #
    # Détermine l'adresse ip et l'adresse mac
    #

    set ip ""
    set mac ""
    pg_select $dbfd "SELECT ip, mac FROM ipmac WHERE idipmac=$idipmac" tab {
	set ip $tab(ip)
	set mac $tab(mac)
    }
    if {[string equal $ip ""]} {
	return "Erreur : Identifiant IP-MAC '$idipmac' non trouvé dans la base"
    }

    set donnees {}

    set nomdns [resolution "ip" $ip]
    
    set lienip [gen-lien [presenter-ip $ip $nomdns] $ip]
    lappend donnees [list Info "Adresse IP" $lienip]

    lappend donnees [list Info "Adresse MAC" \
			[gen-lien \
			    [presenter-mac $dbfd $mac] \
			    $mac \
			] \
		    ]

    #
    # Produit les sessions IPMAC
    #
    
    set found 0
    set tableau ""
    pg_select $dbfd "
		SELECT  to_char(debut,$conf(sqldateformat)) AS ddebut,
			to_char(fin,$conf(sqldateformat)) AS dfin,
			close
		FROM sessionipmac
		WHERE idipmac='$idipmac' ORDER BY debut DESC" tab2 {

	if {$tab2(close)} { set pat "Close" } else { set pat "Active" }

	if {$found == 0} {
	    lappend donnees [list Active "Debut" "Fin" ]
	    set found 1
	}
	lappend donnees [list $pat $tab2(ddebut) $tab2(dfin)]
    }

    if {$found == 0} {
	lappend donnees [list Rem "Pas de session IP - MAC dans la base" ]
    }

    # 
    # Génère le code html pour ce couple IP-MAC
    # 
    append tableau [::arrgen::output "html" $conf(tabsession) $donnees]

    return $tableau
}

#
# Génère un tableau html contenant la liste des sessions portmac
# trouvées dans la base pour un idportmac donné
#
proc gen-idportmac-session {dbfd idportmac} {
    global conf

    set donnees {}

    pg_select $dbfd "
	SELECT portmac.mac AS mac,
	    portmac.port AS port,
	    portmac.ideq AS ideq,
	    portmac.idvlan AS idvlan
	FROM portmac
	WHERE portmac.idportmac=$idportmac
    " tab {
	lappend donnees [list Info  "Adresse MAC" \
			    [gen-lien \
				[presenter-mac $dbfd $tab(mac)] \
				$tab(mac) \
			    ] \
			]

	set eq [get-eq-name $dbfd $tab(ideq)]
	lappend donnees [list Info  "Equipement"  [gen-lien $eq "eq:$tab(ideq)"]]
	lappend donnees [list Info  "Port"        $tab(port)]
	set vlan [presenter-vlan $dbfd $tab(idvlan)]
	lappend donnees [list Info  "VLAN"        [gen-lien $vlan "vlan:$tab(idvlan)"]]
    }

    set found 0
    pg_select $dbfd "
	SELECT 
	    to_char(sessionportmac.debut,$conf(sqldateformat)) AS ddebut,
	    to_char(sessionportmac.fin,$conf(sqldateformat)) AS dfin,
	    sessionportmac.close AS close
	FROM sessionportmac
	WHERE sessionportmac.idportmac=$idportmac
	ORDER BY sessionportmac.fin DESC
    " tab2 {

	if {$found==0} {
	    set found 1
	    lappend donnees [list Active "Debut" "Fin" ]
	}

	if {$tab2(close)} {
	    set pat "Close"
	} else {
	    set pat "Active"
	}
	lappend donnees [list $pat $tab2(ddebut) $tab2(dfin)]
    }

    set tableau [::arrgen::output "html" $conf(tabsession) $donnees]

    return $tableau
}

#
# Genere un menu cliquable des association adresses IP - adresse
# MAC à partir d'une adresse IP ou d'une adresse MAC
#
# Entree :
#   ip : adresse ip (éventuellement vide)
#   mac : adresse mac (éventuellement vide)
#
# Sortie :
#   retourne une chaine de caractère contenant un tableau html
#

proc gen-ipmac {dbfd ip mac} {
global conf

    if {[string equal $mac ""] && [string equal $ip ""]} {
	return ""
    }

    set tableau ""
    set donnees {}
    lappend donnees [list Titre  "Sessions" "IP" "MAC" "Dernière occurence"]

    set critere {}

    if {![string equal $ip ""]} {
	lappend critere " ipmac.ip='$ip' "
    }

    if {![string equal $mac ""]} {
	lappend critere " ipmac.mac='$mac' "
    }

    #
    # Cherche toutes les associations ip-mac
    # et leur date de dernière occurence
    #
    
    set n 0
    set sql "SELECT idipmac AS idipmac, ipmac.mac AS mac, ipmac.ip AS ip
		FROM ipmac WHERE [join $critere AND] "

    set d {}
    pg_select $dbfd $sql tab {
	    incr n
	    set idipmac $tab(idipmac)
	    set lienidipmac [gen-lien "Détails" "idipmac:$idipmac"]
	    set nomdns [resolution "ip" $tab(ip)]
	    set lienip [gen-lien [presenter-ip $tab(ip) $nomdns] $tab(ip)]

	    pg_select $dbfd "SELECT extract(epoch from max(fin)) AS fin
		    FROM sessionipmac
		    WHERE idipmac=$idipmac" tab2 {
		set fin $tab2(fin)
	    }

	    if {![string equal $fin ""]} {
		set fin [expr int($fin)]
	    } else {
		set fin 0
	    }
	    set lienmac [gen-lien [presenter-mac $dbfd $tab(mac)] $tab(mac)]
	    lappend d [list Data $lienidipmac $lienip $lienmac $fin]
    }

    #
    # Trie la liste et converti la date au bon format
    #
    foreach l [lsort -index end -integer $d] {
	set t [lindex $l end]
	set date [clock format $t -format "$conf(clockformat)"]
	if {[regexp {^01/01/1970} $date]} then {
	    set date "(date effacee)"
	}
	lappend donnees \
	    [lreplace $l end end $date]
    }
    
    if {$n > 0} {
	if {$n == 1} { set p "" } else { set p "s" }
	set tableau "$n associations adresse$p MAC - adresse IP trouvée$p pour $mac$ip:<BR>"
	append tableau [::arrgen::output "html" $conf(tabmenuipmac) $donnees]
    } else {
	set tableau "Aucune association IP - MAC trouvée pour $mac$ip<BR>"
    }

    append tableau "<BR>"

    return $tableau
}

#
# Genere un menu cliquable des association adresses MAC - 
# équipement - port
#
# Entree :
#   mac : adresse mac
#
# Sortie :
#   retourne une chaine de caractère contenant un tableau html
#

proc gen-mac {dbfd mac} {

    if {[string equal $mac ""]} {
	return ""
    }

    return [gen-portmac $dbfd "portmac.mac='$mac'"]
}

#
# Genere un menu cliquable des association adresse mac-equipement-port-vlan
# pour un équipement donné
#
# Entree :
#   eq : nom d'équipement
#
# Sortie :
#   retourne une chaine de caractère contenant un tableau html
#

proc gen-eq {dbfd eq} {

    set ideq [get-eq-id $dbfd $eq]
    if {$ideq==0} {
	return "$eq : équipement non trouvé"
    }

    return [gen-portmac $dbfd "portmac.ideq=$ideq"]
}

#
# Genere un menu cliquable des association adresse mac-equipement-port-vlan
# pour un vlan donné
#
# Entree :
#   idvlan : numéro de vlan
#
# Sortie :
#   retourne une chaine de caractère contenant un tableau html
#

proc gen-vlan {dbfd idvlan} {

    if {[string equal [presenter-vlan $dbfd $idvlan] ""]} {
	return "$idvlan : vlan non trouvé"
    }

    return [gen-portmac $dbfd "portmac.idvlan=$idvlan"]
}

#
# Cherche toutes les associations port-equipement-mac-vlan
# et leur date de dernière occurence en fonction du critère 
# (expression au format SQL) passé en paramètre
#
    
proc gen-portmac {dbfd critere} {
    global conf

    set n 0
    set tableau ""
    set donnees {}
    lappend donnees [list Titre  "Sessions" "MAC" "Equipement" "Port" "VLAN" "Dernière occurence"]
    set sql "
	SELECT   mac, idvlan, idportmac, ideq, port
	FROM	portmac
	WHERE	$critere
	GROUP BY    idportmac, mac, idvlan, port, ideq"

    set d {}
    pg_select $dbfd $sql tab {
	    incr n
	    set idportmac $tab(idportmac)
	    set lienidportmac [gen-lien "Détails" "idportmac:$idportmac"]
	    set lienmac [gen-lien [presenter-mac $dbfd $tab(mac)] $tab(mac)]
	    set idvlan $tab(idvlan)
	    set lienvlan [gen-lien [presenter-vlan $dbfd $idvlan] "vlan:$idvlan"]
	    set nomeq [get-eq-name $dbfd $tab(ideq)] 
	    set lieneq [gen-lien $nomeq "eq:$nomeq"]

	    pg_select $dbfd "SELECT extract(epoch from max(fin)) AS fin
		    FROM sessionportmac
		    WHERE idportmac=$idportmac" tab2 {
		set fin $tab2(fin)
	    }

	    if {![string equal $fin ""]} {
		set fin [expr int($fin)]
	    } else {
		set fin 0
	    }
	    lappend d [list Data \
		$lienidportmac $lienmac $lieneq $tab(port) $lienvlan $fin ]

    }
    #
    # Trie la liste et converti la date au bon format
    #
    foreach l [lsort -index end -integer $d] {
	set t [lindex $l end]
	lappend donnees \
	    [lreplace $l end end [clock format $t -format "$conf(clockformat)"]]
    }

    if {$n > 0} {
	if {$n == 1} { set p "" } else { set p "s" }
	set tableau "$n associations adresse$p MAC - équipement - port - vlan trouvée$p"
	append tableau [::arrgen::output "html" $conf(tabmenuportmac) $donnees]
    } else {
	set tableau "Aucune association adresse MAC - équipement - port - vlan trouvée"
    }
	
    return $tableau
}

#
# Génère un lien cliquable
#

proc gen-lien {texte cible} {
    global conf

    d urlset "" $conf(next) [list [list "recherche" $cible]]
    set url [d urlget ""]
    return [::webapp::helem "a" $texte "href" $url]
}

#
# Produit une chaine décrivant le VLAN de la forme
#   "5" si le vlan d'id 5 est inconnu
# ou
#   "5 (vlan CRC)" si le vlan existe dans la base
#
proc presenter-vlan {dbfd idvlan} {
    global cachevlan

    set vlan ""
    if {[info exists cachevlan($idvlan)]} {
	set vlan $cachevlan($idvlan)
    } else {
	pg_select $dbfd "SELECT nom FROM vlan WHERE idvlan=$idvlan" tab {
	    set vlan $tab(nom)
	}
	set cachevlan($idvlan) $vlan
    }

if {![string equal $vlan ""]} {
    set affichevlan "$idvlan ($vlan)"
} else {
    set affichevlan $idvlan
}

return $affichevlan
}

#
# Cherche le nom de l'équipement
#
proc get-eq-name {dbfd ideq} {
    global cacheideq
    global cacheeq

    set eq "équipement inconnu (id $ideq)"
    if {[info exists cacheeq($ideq)]} {
	set eq $cacheeq($ideq)
    } else {
	pg_select $dbfd "SELECT nom FROM eq WHERE ideq=$ideq" tab {
	    set eq $tab(nom)
	}
	set cacheideq($eq) $ideq
	set cacheeq($ideq) $eq
    }

    return $eq
}

#
# Cherche l'id de l'équipement dans le cache ou
# dans la base en cas d'absence dans la cache.
#
# Retourne 0 si non trouvé.
# Place le résultat de la requête dans le cache
#

proc get-eq-id {dbfd eq} {
    global cacheideq
    global cacheeq

    set ideq 0
    if {[info exists cacheideq($eq)]} {
	set ideq $cacheideq($eq)
    } else {
	pg_select $dbfd "SELECT ideq FROM eq WHERE nom='$eq'" tab {
	    set ideq $tab(ideq)
	}
	set cacheeq($ideq) $eq
	set cacheideq($eq) $ideq
    }

    return $ideq
}


#
# Présenter le critère de recherche sur la page de résultat
# de façon lisible par un être humain...
#

proc presenter-crit {dbfd type param} {

    switch $type {
	mac       { set m "l'adresse MAC $param" }
	ip        { set m "l'adresse IP $param" }
	idipmac   { set m "cette association adresse IP - adresse MAC" }
	idportmac { set m "cette association adresse MAC - Équipement - Port - VLAN" }
	vlan      { set m "le vlan [presenter-vlan $dbfd $param]" }
	nom       { set m "la machine $param" }
	default   { set m "???" }
    }
    
    return $m
}

#
# Reformate une adresse IP :
# soit l'adresse IP suivi du nom s'il existe,
# soit l'adresse IP seule
#

proc presenter-ip {ip nomdns} {

    if {![string equal $nomdns ""]} {
	set affichenomip "$ip ($nomdns)"
    } else {
	set affichenomip "$ip"
    }
    
    return $affichenomip
}

#
# Recherche l'OUI pour une adresse MAC donnée
# et retourne une chaine de caractère composé de l'adresse
# MAC et du nom du constructeur
# 
# Exemple :
# - l'adresse mac "08:00:20:67:89:ab" devient :
#   "08:00:20:67:89:ab (SUN MICROSYSTEMS INC.)"
#
# - l'adresse mac "01:23:45:67:89:ab" devient :
# "01:23:45:67:89:ab"
# (pas de changement car OUI non trouvé)
#

proc presenter-mac {dbfd mac} {
    global ouicache

    if {[info exists ouicache($mac)]} {
	return $ouicache($mac)
    }

    set manuf 0
    pg_select $dbfd "SELECT manuf('$mac') AS m" tab {
	set manuf $tab(m)
    }
    
    if {![string equal $manuf ""]} {
	set affichemac "$mac ($manuf)"
    } else {
	set affichemac "$mac"
    }
    
    set ouicache($mac) $affichemac

    return $affichemac
}

#
# Resolution DNS : 
# Appelle la commande "host" et en fonction du type
# de resolution DNS demandée, produit une liste d'ip ou un nom de
# domaine
#
# Paramètres :
#   Entree : 
#     type : "nom" pour une resolution de nom, "ip" pour un resolution inverse
#     arg  : objet de la resolution (nom de domaine ou adresse ip)
#   Sortie : 
#     Valeur de retour : liste d'adresse ip ou nom de domaine
#

proc resolution {type arg} {
    global conf
    global dnscache

    if { !([regexp {^[a-z0-9\-.]+$} $arg] ||
	   [regexp {^([0-9.]+|[0-9a-f:.]+)$} $arg]) } {
	return {}
    }

    #
    # Définition du filtre
    #

    if {[info exists dnscache($arg)]} {
	return $dnscache($arg)
    }

    switch $type {
	"nom" { set pat "address" }
	"ip"  { set pat "domain name pointer" }
    }

    #
    # On récupère le résultat de la commande "host"
    #

    if { [catch {set buf [exec $conf(cmdhost) $arg]} msg]} {
	set buf ""
    }

    #
    # On ne garde que le dernier mot de chaque ligne
    #

    set l {}
    foreach line [split $buf "\n"] {
	if { [regexp $pat $line] } {
	    lappend l [lindex $line end]
	}
    }

    set dnscache($arg) $l

    return $l 
}



#
# Programme Principal
#

proc main {} {
    global conf

    #
    # Initialisation
    #

    ::dnscontext create d
    d init-cgi "mac" $conf(err) "" $conf(form) ftab dbfd login tabcor

    if {[catch {set dbfdmac [pg_connect -conninfo $conf(dbmac)]} msg]} then {
        d error $msg
    }

    #
    # Analyse des arguments
    #

    set recherche [string tolower [string trim [lindex $ftab(recherche) 0]]]

    if {$recherche eq ""} then {
	#
	# Sortie du résultat
	#

	d urlset "%URLFORM%" $conf(next) {}

	d result $conf(pagesearch) {}
    } else {
	#
	# Détermine le type
	#

	set l [determine-type $dbfdmac $recherche msg]
	if {[llength $l]==0} {
	    ::webapp::error-exit $conf(err) "type de parametre : $msg"
	} 
	set type [lindex $l 0]
	set param [lindex $l 1]

	#
	# Génère le tableau html de résultat
	#

	set tableau [gen-res $dbfdmac $type $param]

	if { [string equal $tableau ""] } {
	    set tableau "Aucune information trouvée"
	}

	#
	# Sortie du résultat
	#

	d result $conf(page) [list \
				    [list %RECHERCHE% [presenter-crit $dbfdmac $type $param]] \
				    [list %TABLEAU%   $tableau] \
				]
    }
}

::webapp::cgi-exec main %DEBUG%
