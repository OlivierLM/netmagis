#!%TCLSH%

# $Id: dnswriteprol,v 1.5 2007-11-29 15:54:35 pda Exp $

#
# Script pour écrire le prologue d'une zone dans la base
#
# Syntaxe :
#   dnswriteprol <zone> <fichier>
#
# Historique
#   2004/05/25 : pda      : conception en sh
#   2005/04/11 : pda      : réécriture en Tcl pour bénéficier du Makefile
#   2007/10/25 : jean     : log des actions de modification
#

set conf(homeurl)	%HOMEURL%

#
# Chemins utilisés par les scripts
#

set conf(pkg)		%PKGTCL%
set conf(lib)		%DESTDIR%/lib
set conf(libdns)	$conf(lib)/libdns.tcl

#
# Quelques paramètres du script
#

set conf(base)		%BASE%
set conf(auth)		%AUTH%
set conf(nologin)	%NOLOGIN%
set conf(log)		%LOG%
set conf(defuser)	%DEFUSER%

set conf(interactive)	yes

#
# Les outils du parfait concepteur de pages Web dynamiques...
#

lappend auto_path $conf(pkg)
package require pgsql

#
# On y va !
#

# ::webapp::cgidebug ; exit

source $conf(libdns)

##############################################################################
# Petites fonctions utilitaires
##############################################################################

proc syntax-error {argv0} {
    regsub {.*/} $argv0 {} argv0
    puts stderr "usage: $argv0 zone file"
    exit 1
}

##############################################################################
# Programme principal
##############################################################################

proc main {argv0 argv} {
    global conf

    #
    # Initialisation des accès
    #

    set errmsg [init-dns-util $conf(nologin) $conf(auth) $conf(base) \
				    dbfd $conf(defuser) tabcor $conf(log)]
    if {! [string equal $errmsg ""]} then {
	puts stderr "$errmsg"
	puts stderr "Aborted."
	return 1
    }

    #
    # Validation des arguments
    #

    if {[llength $argv] != 2} then {
	syntax-error $argv0
	return 1
    }

    set zone [lindex $argv 0]
    set file [lindex $argv 1]

    set qzone [::pgsql::quote $zone]
    set sql "SELECT prologue FROM zone WHERE domaine = '$qzone'"

    set trouve 0
    pg_select $dbfd $sql tab {
	set old $tab(prologue)
	set trouve 1
    }

    if {! $trouve} then {
	puts stderr "Zone '$zone' not found"
	return 1
    }

    #
    # Récupération du fichier
    #

    if {[catch {set fd [open $file "r"]} msg]} then {
	puts stderr $msg
	return 1
    }
    set new [read $fd]
    close $fd

    #
    # Tests
    #

    if {[string equal $new $old]} then {
	puts stderr "No difference. Zone '$zone' not modified."
	return 0
    }

    if {$conf(interactive)} then {

	#
	# Afficher les diffs pour éviter des bourdes
	#

	set tmp1 "/tmp/dnswriteprol1.[pid]"
	set tmp2 "/tmp/dnswriteprol2.[pid]"

	foreach {fname text} [list $tmp1 $old $tmp2 $new] {
	    if {[catch {set fd [open $fname "w"]} msg]} then {
		puts stderr $msg
		return 1
	    }
	    puts $fd $text
	    close $fd
	}

	set diff [exec sh -c "diff $tmp1 $tmp2 ; exit 0"]
	puts stdout $diff

	puts -nonewline stdout {Modify [n] : }
	flush stdout
	gets stdin answer

	file delete $tmp1 $tmp2

	switch -glob -- $answer {
	    {[oOyY]*} {
		# rien : on continue en séquence
	    }
	    default {
		puts stderr "Zone '$zone' not modified."
		return 0
	    }
	}
    }

    #
    # Modification
    #

    set txt [::pgsql::quote $new]
    set sql "UPDATE zone SET prologue = '$txt' WHERE domaine = '$qzone'"

    if {! [::pgsql::execsql $dbfd $sql msg]} then {
	return "Impossible de modifier : $msg"
    }

    #
    # Écrire le log
    #

    writelog "modifref" $tabcor(login) \
	"modification du prologue de la zone '$zone' (ligne de commande)"

    #
    # Déconnexion de la base
    #

    fermer-base $dbfd

    return 0
}

exit [main $argv0 $argv]
