#!%TCLSH%

#
# Delete host, IP address or alias
#
# Called by: suppr
#
# Parameters (form or url):
#   - display page
#	- action : (empty)
#   - name removal
#	- action : "del-name"
#	- nom : name of object to delete
#	- domaine : domain of object to delete
#	- idviews : selected (after confirmation) views
#   - IP address removal
#	- action : "del-ip"
#	- confirm : "no" or "yes" (if confirm ok)
#	- adr: IP address
#
# History
#   2002/04/11 : pda/jean : design
#   2002/05/03 : pda/jean : split 3 modification types
#   2002/07/09 : pda      : add nologin
#   2003/05/13 : pda/jean : use auth base
#   2004/01/14 : pda/jean : add IPv6
#   2004/08/05 : pda/jean : add mac
#   2005/04/08 : pda/jean : add dhcpprofil
#   2007/10/25 : jean     : log modify actions
#   2008/07/24 : pda/jean : add droitsmtp
#   2008/07/29 : pda      : use display-rr
#   2010/10/15 : pda      : add journey
#   2010/12/14 : pda      : i18n
#   2010/12/25 : pda      : use cgi-dispatch
#   2012/11/13 : pda/jean : add views
#

#
# Template pages used by this script
#

set conf(page)			del-sel.html
set conf(page-conf-name)	del-conf-name.html
set conf(page-conf-ip)		del-conf-ip.html
set conf(page-ok)		del-ok.html

set conf(page-oneip)	del-ip1.html
set conf(page-obj)	del-ipobj.html

#
# Next actions
# 

set conf(next)		"del"
set conf(nextmap)	"net"
set conf(nextlist)	"net"
set conf(nextipinact)	"ipinact"

#
# Script parameters
#

set conf(tab-confirm-name) {
    global {
	chars {10 normal}
	columns {5 10 85}
	align {left}
	botbar {no}
    }
    pattern Line {
	vbar {no}
	column {
	    format {raw}
	}
	vbar {no}
	column {
	}
	vbar {no}
	column {
	    format {raw}
	}
	vbar {no}
    }
}

#
# Netmagis general library
#

source %LIBNETMAGIS%

# ::webapp::cgidebug ; exit

##############################################################################
# Display page
##############################################################################

d cgi-register {action {}} {
} {
    global conf

    #
    # Get domains authorized for the user
    #

    set domain [menu-domain $dbfd $tabuid(idcor) "domaine" "" ""]

    #
    # End of script: output page and close database
    #

    d urlset "%URLFORM%" $conf(next) {}
    d result $conf(page) [list \
				[list %DOMAINE% $domain] \
			    ]
}

##############################################################################
# Name removal
##############################################################################

# History
#   2002/04/19 : pda/jean : design
#

d cgi-register {action del-name} {
    {nom	1 1}
    {domaine	1 1}
    {idviews	0 9999}
} {
    global conf

    set fqdn "$nom.$domaine"

    #
    # Are views selected? If so, this is a confirmation
    #

    set confirm [llength $idviews]
    if {! $confirm} then {
	#
	# We must check all our views in order to search deletion
	# candidates
	#
	set myviewids [u myviewids]
	if {[llength $myviewids] == 0} then {
	    d error "Sorry, but you do not have access to any view"
	}
    } else {
	#
	# User has selected one or more views. This is a confirmation.
	# 
	set myviewids $idviews
    }

    #
    # Check name in all views
    #

    set nok 0
    set nerr 0
    foreach idview $myviewids {

	set v [list $idview]
	set vn [u viewname $idview]

	set msg [check-authorized-host $dbfd $tabuid(idcor) $nom $domaine $v trr "del-name"]

	set err 0
	if {$msg ne ""} then {
	    set err 1
	} else {
	    #
	    # Is it an alias in this view?
	    #

	    set cname [rr-cname-by-view trr $idview]
	    if {$cname eq ""} then {
		#
		# It is not an alias, there must be at least an IP address
		#
		set ip [rr-ip-by-view trr $idview]
		if {$ip eq ""} then {
		    set msg [mc {Name '%1$s' is not a host in view '%2$s'} $fqdn $vn]
		    set err 1
		}

	    }
	}

	if {$err} then {
	    set checkedviews($idview) [list $vn $msg]
	    incr nerr
	} else {
	    set checkedviews($idview) [list $vn]
	    incr nok
	}
    }

    #
    # Check that name exists
    #

    if {$trr(idrr) eq ""} then {
	d error [mc "Name '%s' does not exist" $fqdn]
    }

    #
    # Check that :
    # - there is at least one view in which we can delete a name
    # - there is no view in error, if this is a confirmation
    #

    if {$nok == 0 || ($confirm && $nerr > 0)} then {
	set msg ""
	foreach idview $myviewids {
	    lassign $checkedviews($idview) vn m
	    if {$m ne ""} then {
		append msg [mc {Error detected in view '%1$s': %2$s} $vn $m]
		append msg "\n"
	    }
	}
	d error $msg
    }

    #
    # At this point, myviewids contains:
    # - all user's view ids (good and in error) if confirmation is needed
    # - only good view ids if user has already confirmed
    #


    #
    # Ask for confirmation if needed
    #

    if {! $confirm} then {
	ask-confirm-name $dbfd $nok $myviewids checkedviews trr
    } else {
	process-del-name $dbfd $myviewids trr
    }
}

proc ask-confirm-name {dbfd nok idviews _checkedviews _trr} {
    upvar $_trr trr
    upvar $_checkedviews checkedviews
    global conf

    # display checkbutton for view only if there is more than a single view
    set dispconfview [expr $nok > 1]

    if {$dispconfview} then {
	set info [display-rr-core $dbfd -1 trr]
    } else {
	set info ""
    }

    set lines {}
    foreach idview $idviews {
	lassign $checkedviews($idview) vn msg

	if {$msg eq ""} then {
	    #
	    # Information about host found
	    #

	    set cname [rr-cname-by-view trr $idview]
	    if {$cname eq ""} then {
		# This is not an alias
		if {$dispconfview} then {
		    set host [display-rr-host $dbfd $idview trr]
		} else {
		    set host [display-rr $dbfd -1 trr]
		}
	    } else {
		# This is an alias, display informations about target host
		set host [display-rr-cname $dbfd $idview trr]
	    }

	    #
	    # View name and check box
	    #

	    if {$dispconfview} then {
		set c ""
	    } else {
		set c " CHECKED"
	    }
	    set check "<INPUT TYPE=CHECKBOX NAME=\"idviews\" VALUE=\"$idview\" $c>"

	} else {
	    #
	    # Error message
	    #
	    set host [::webapp::html-string $msg]
	    set check ""
	}

	lappend lines [list Line $check $vn $host]
    }

    set seldel [::arrgen::output "html" $conf(tab-confirm-name) $lines]

    #
    # Confirmation needed
    #

    d urlset "%URLFORM%" $conf(next) {}
    d urladdnext "%URLFORM%"

    d result $conf(page-conf-name) [list \
					[list %NOM% $trr(nom)] \
					[list %DOMAINE% $trr(domaine)] \
					[list %INFO% $info] \
					[list %SELDEL% $seldel] \
				    ]
}

proc process-del-name {dbfd idviews _trr} {
    upvar $_trr trr
    global conf

    #
    # Confirmation is accepted. All view ids have been checked.
    # Do the removal.
    #

    d dblock {}

    set fqdn "$trr(nom).$trr(domaine)"
    set log {}
    set result {}

    foreach idview $idviews {
	set vn [u viewname $idview]

	set cname [rr-cname-by-view trr $idview]
	if {$cname ne ""} then {
	    if {! [del-alias-by-id $dbfd $trr(idrr) $idview msg]} then {
		d dbabort [mc "delete %s" $fqdn/$vn] $msg
	    }

	    set p "?"
	    if {[read-rr-by-id $dbfd $cname tc]} then {
		set p "$tc(nom).$tc(domaine)"
	    }
	    lappend log [list "delalias" "delete alias $fqdn -> $p"]

	    lappend result [mc {'%1$s' has been removed from view '%2$s'} $fqdn $vn]
	} else {
	    #
	    # This is not an alias: delete all RR dependancies:
	    # - aliases pointing this object
	    # - MX
	    # - IP addresses
	    #
	    if {! [del-rr-and-dependancies $dbfd trr $idview msg]} then {
		d dbabort [mc "delete %s" $fqdn/$vn] $msg
	    }
	    lappend log [list "delname" "delete all of $fqdn/$vn"]
	}

    }

    d dbcommit [mc "delete %s" $fqdn]

    #
    # Leave a trace
    #

    foreach l $log {
	lassign $l logevt logmsg
	d writelog $logevt $logmsg
    }

    #
    # Prepare next step in journey
    #

    switch -- [d nextprog] {
	map {
	    d urlset "%URLSUITE%" $conf(nextmap) [list {domap {yes}} [d nextargs]]
	}
	list {
	    d urlset "%URLSUITE%" $conf(nextlist) [list {dolist {yes}} [d nextargs]]
	}
	default {
	    d urlset "%URLSUITE%" $conf(next) {}
	}
    }

    #
    # End of script: output page and close database
    #

    set result [join $result "<br>"]

    d result $conf(page-ok) [list \
				    [list %RESULT% $result] \
			]
}

##############################################################################
# IP address removal
##############################################################################

# History
#   2002/04/23 : pda/jean : design
#   2002/04/26 : pda/jean : design end
#   2002/05/03 : pda/jean : keep a log of modification
#

d cgi-register {action del-ip} {
    {confirm	1 1}
    {adr	1 1}
} {
    global conf

    #
    # Check IP address
    #

    set msg [check-ip-syntax $dbfd $adr "inet"]
    if {$msg ne ""} then {
	d error $msg
    }
    if {! [check-authorized-ip $dbfd $tabuid(idcor) $adr]} then {
	d error [mc "You don't have rights on '%s'" $adr]
    }

    #
    # Check that this address exists and get all stored informations
    #

    if {! [read-rr-by-ip $dbfd $adr trr]} then {
	d error [mc "Address '%s' not found" $adr]
    }

    #
    # Check access to this name
    #

    set nom     $trr(nom)
    set domaine $trr(domaine)
    set msg [check-authorized-host $dbfd $tabuid(idcor) $nom $domaine bidon "del-name"]
    if {$msg ne ""} then {
	d error $msg
    }
    set fqdn "$nom.$domaine"

    #
    # Is it the last IP address?
    #

    if {[llength $trr(ip)] == 1} then {
	set lastadr "yes"
    } else {
	set lastadr "no"
    }

    #
    # Prepare display of informations, if needed
    #

    set objet ""
    set host [display-rr $dbfd -1 trr]

    #
    # Remove only if confirmation is ok
    #

    if {$confirm eq "yes"} then {
	#
	# Proceed to removal
	#

	d dblock {}

	if {! $lastadr} then {
	    #
	    # Only delete an IP address
	    #

	    set sql "DELETE FROM dns.rr_ip WHERE adr = '$adr'"
	    if {! [::pgsql::execsql $dbfd $sql msg]} then {
		d dbabort [mc "delete %s" $adr] $msg
	    }
	    set msg [touch-rr $dbfd $trr(idrr)]
	    if {$msg ne ""} then {
		d dbabort [mc "modify %s" [mc "RR"]] $msg
	    }

	    set logevt "deladdr"
	    set logmsg "delete address $adr from $fqdn"

	} else {
	    #
	    # Delete the whole object
	    #

	    if {! [del-rr-and-dependancies $dbfd trr msg]} then {
		d dbabort [mc "delete %s" $fqdn] $msg
	    }

	    set logevt "deladr"
	    set logmsg "delete address $adr -> delete all $fqdn"
	}

	d dbcommit [mc "delete %s" $adr]
	d writelog $logevt $logmsg
    }

    #
    # Prepare next step in journey
    #

    switch -- [d nextprog] {
	map {
	    d urlset "%URLSUITE%" $conf(nextmap) [list {domap {yes}} [d nextargs]]
	}
	list {
	    d urlset "%URLSUITE%" $conf(nextlist) [list {dolist {yes}} [d nextargs]]
	}
	ipinact {
	    d urlset "%URLSUITE%" $conf(nextipinact) [list [d nextargs]]
	}
	default {
	    d urlset "%URLSUITE%" $conf(next) {}
	}
    }

    #
    # Prepare page display
    #

    d urlset "%URLFORM%" $conf(next) {}

    switch -- "confirm=$confirm-lastadr=$lastadr" {
	confirm=no-lastadr=no {
	    #
	    # Ask for confirmation to remove one of the IP addresses
	    # 
	    set page $conf(page-oneip)
	    d urladdnext "%URLFORM%"
	}
	confirm=no-lastadr=yes {
	    #
	    # Ask for confirmation to remove the last IP address, and thus
	    # of the whole object.
	    # 
	    set page $conf(page-obj)
	    d urladdnext "%URLFORM%"
	}
	confirm=yes-lastadr=no {
	    #
	    # Address has been removed
	    #
	    set page $conf(page-ok)
	    set objet $adr
	}
	confirm=yes-lastadr=yes {
	    #
	    # The whole object has been removed
	    #
	    set page $conf(page-ok)
	    set objet "$nom.$domaine"
	}
	default {
	    d error [mc "Internal error: impossible case '%s'" "confirm=$confirm, lastadr=$lastadr"]
	}
    }

    d result $page [list \
			[list %NOM%         $nom] \
			[list %DOMAINE%     $domaine] \
			[list %ADR%         $adr] \
			[list %MACHINE%     $host] \
			[list %OBJET%       $objet] \
		    ]
}

##############################################################################
# Main procedure
##############################################################################

d cgi-dispatch "dns" ""
