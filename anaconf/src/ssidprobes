#!/usr/local/bin/tclsh8.4


#
# $Id: ssidprobes,v 1.1 2008-07-29 13:24:20 pda Exp $
#
# Prend sur l'entrée standard un fichier d'entrée compatible "buildgraph",
# ajoute les points de métrologie wifi spécifiques à la politique Osiris,
# et renvoie sur la sortie standard un fichier prêt à être confié à nouveau
# à "buildgraph".
#
# Syntaxe :
#	ssidprobes		(aucun argument)
#
# Exemple :
#	ssidprobes
#
# Historique :
#   2008/07/29 : pda/boggia : conception
#


#
# Procédure principale
#
# Historique :
#   2008/07/29 : pda/boggia : conception
#


proc usage {argv0} {
    puts stderr "usage: $argv0"
    exit 1
}

proc main {argv0 argv} {

    #
    # Vérification des arguments
    #

    if {[llength $argv] != 0} then {
	usage $argv0
	return 1
    }

    #
    # Lecture des informations sur l'entrée standard et stockage
    # intermédiaire
    #

    while {[gets stdin ligne] >= 0} {
	#
	# Afficher la ligne vue en premier
	#

	puts stdout $ligne

	#
	# Ne retenir que les lignes de type "node ... L1" qui ont
	# des paramètres radio
	#

	if {[regexp {^node (\S+) type L1 eq (\S+) .*radio [0-9]+ [0-9]+\s+(.*)} \
				$ligne \
				bidon \
				node eq ssids]} then {

	    #
	    # Parcourir les ssid, en vérifiant que le premier mot
	    # est bien à chaque fois "ssid"
	    #

	    foreach {ssid name mode} $ssids {
		if {[string equal $ssid "ssid"]} then {
		    switch $mode {
			open {
			    set id "M$eq.assocwifi.$name"
			    puts stdout "ssidprobe $id eq $eq iface $node ssidname $name mode assoc"

			    set id "M$eq.authwifi.$name"
			    puts stdout "ssidprobe $id eq $eq iface $node ssidname $name mode auth"
			}
			auth {
			    set id "M$eq.authwifi.$name"
			    puts stdout "ssidprobe $id eq $eq iface $node ssidname $name mode auth"
			}
			default {
			    puts stderr "Inconsistency: invalid ssid mode '$mode' in '$ligne'"
			}
		    }
		} else {
		    puts stderr "Inconsistency: bad ssid in '$ligne'"
		}
	    }
	}
    }

    return 0
}

exit [main $argv0 $argv]
