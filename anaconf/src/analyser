#!/usr/local/bin/tclsh8.4

#
# $Id: analyser,v 1.3 2007-07-13 08:15:37 pda Exp $
#
# Analyse un fichier de configuration d'un équipement réseau
# et renvoie la modélisation de cet équipement sous forme de
# la représentation comprise par buildgraph & co.
#
# Syntaxe :
#   analyser <libdir> <cisco|juniper> <model> <fichier conf> <eq name> [<debug>]
#
# Exemple :
#   analyser $PWD cisco 4506 \
#		/local/idr/conf/osiris/configs/crc-ce1.u-strasbg.fr crc-ce1
#
# Historique :
#   2007/01/05 : pda : intégration dans le CVS
#   2007/07/13 : pda : documentation
#   2007/07/13 : pda : ajout syntaxe debug
#

proc parse-desc {desc _linkname _statname _descname _msg} {
    upvar $_linkname linkname
    upvar $_statname statname
    upvar $_descname descname
    upvar $_msg msg

    # exemples de syntaxe admises :
    # Lnnn vers toto 			ancienne syntaxe
    # <Lnnn> vers toto			nouvelle syntaxe
    # <Lnnn MLnnn.crc> vers toto	nouvelle syntaxe avec métrologie
    # X rch ulp bidule			ancienne syntaxe
    # <X> rch ulp bidule		nouvelle syntaxe
    # <X MXnnn> rch ulp bidule		nouvelle syntaxe avec métrologie

    set linkname ""
    set statname ""
    set descname ""

    set r 1
    if {[regexp {([^<]*)<\s*([^<>]+)>(.*)} $desc bidon p1 liste p2]} then {
	while {[regexp {^(\S+)(\s+(.*))?$} $liste bidon premier bidon liste]} {
	    switch -glob -- $premier {
		X* -
		L* {
		    if {[string equal $linkname ""]} then {
			set linkname $premier
		    } else {
			set msg "duplicate link name"
			set r 0
			break
		    }
		}
		M* {
		    if {[string equal $statname ""]} then {
			set statname $premier
		    } else {
			set msg "duplicate stat name"
			set r 0
			break
		    }
		}
		* {
		    set msg "invalid interface description '<$premier>'"
		    set r 0
		    break
		}
	    }
	}
	set descname [string trim "[string trim $p1] [string trim $p2]"]
    } elseif {[regexp {^(\S+)(\s+.*)?$} $desc bidon linkname p1]} {
	set descname [string trim $p1]
    } else {
	set msg "invalid link name"
	set r 0
    }

    #
    # Conversion de la description en chaîne de chiffres hexa
    # pour éviter d'avoir à quoter les éléments.
    # Cette chaîne sera propagée dans le graphe, et chaque outil
    # utilisant le graphe devra faire la conversion inverse
    # avec une commande comme par exemple : "binary format H* $desc"
    #

    binary scan $descname H* descname

    return $r
}

proc parse {debug libdir type model fdin fdout tab eq} {
    upvar $tab t

    global loadedfiles

    set error 0
    if {[string equal $libdir ""]} then {
	set file "parse-$type.tcl"
    } else {
	set file "$libdir/parse-$type.tcl"
    }

    if {! [info exists loadedfiles($file)]} then {
	if {[file exists $file]} then {
	    uplevel #0 source $file
	    set loadedfiles($file) 1
	} else {
	    puts stderr "Fichier '$file' inexistant"
	    set error 1
	}
    }

    if {! $error} then {
	set error [$type-parse $debug $model $fdin $fdout t $eq]
    }

    return $error
}

proc usage {argv0} {
    puts stderr \
	"$argv0 libdir cisco|juniper modele fichier-conf eq-name \[debug\]"
}

proc main {argv0 argv} {
    set debug 0

    switch [llength $argv] {
	5 {
	    # rien
	}
	6 {
	    set debug [lindex $argv 5]
	}
	default {
	    usage $argv0
	    return 1
	}
    }

    set libdir  [lindex $argv 0]
    set type    [lindex $argv 1]
    set modele  [lindex $argv 2]
    set fichier [lindex $argv 3]
    set eq      [lindex $argv 4]

    set fd [open $fichier "r"]
    set error [parse $debug $libdir $type $modele $fd stdout tab $eq]
    close $fd

    return 0
}


exit [main $argv0 $argv]
