#!/usr/local/bin/tclsh8.4

#
# $Id: analyser,v 1.6 2008-04-28 19:31:58 pda Exp $
#
# Analyse un fichier de configuration d'un équipement réseau
# et renvoie la modélisation de cet équipement sous forme de
# la représentation comprise par buildgraph & co.
#
# Syntaxe :
#   analyser <libdir> <cisco|juniper> <modele> <fichier conf> <eq name> [<debug>]
#
# Exemple :
#   analyser $PWD cisco 4506 \
#		/local/idr/conf/osiris/configs/crc-ce1.u-strasbg.fr crc-ce1 15
#
# Flags de debug : combinaison binaire de :
#   0x01 (1)   : analyse de syntaxe
#   0x02 (2)   : affichage du tableau intermédiaire
#   0x04 (4)   : -
#   0x08 (8)   : -
#   0x10 (16)  : -
#   0x20 (32)  : -
#
# Historique :
#   2007/01/05 : pda : intégration dans le CVS
#   2007/07/13 : pda : documentation
#   2007/07/13 : pda : ajout syntaxe debug
#

set debug 0

# inspiré de parray.tcl dans la lib tcl
# la seule différence est la sortie sur stderr (et non sur stdout)
proc debug-array {a {pattern *}} {
    upvar 1 $a array
    if {![array exists array]} {
	error "\"$a\" isn't an array"
    }
    set maxl 0
    foreach name [lsort [array names array $pattern]] {
	if {[string length $name] > $maxl} {
	    set maxl [string length $name]
	}
    }
    set maxl [expr {$maxl + [string length $a] + 2}]
    foreach name [lsort [array names array $pattern]] {
	set nameString [format %s(%s) $a $name]
	puts stderr [format "%-*s = %s" $maxl $nameString $array($name)]
    }
}

proc parse-desc {desc _linkname _statname _descname _msg} {
    upvar $_linkname linkname
    upvar $_statname statname
    upvar $_descname descname
    upvar $_msg msg

    # exemples de syntaxe admises :
    # Lnnn vers toto 			ancienne syntaxe
    # <Lnnn> vers toto			nouvelle syntaxe
    # <Lnnn MLnnn.crc> vers toto	nouvelle syntaxe avec métrologie
    # X rch ulp bidule			ancienne syntaxe
    # <X> rch ulp bidule		nouvelle syntaxe
    # <X MXnnn> rch ulp bidule		nouvelle syntaxe avec métrologie

    set linkname ""
    set statname ""
    set descname ""

    set r 1
    if {[regexp {([^<]*)<\s*([^<>]+)>(.*)} $desc bidon p1 liste p2]} then {
	while {[regexp {^(\S+)(\s+(.*))?$} $liste bidon premier bidon liste]} {
	    switch -glob -- $premier {
		X* -
		L* {
		    if {[string equal $linkname ""]} then {
			set linkname $premier
		    } else {
			set msg "duplicate link name"
			set r 0
			break
		    }
		}
		M* {
		    if {[string equal $statname ""]} then {
			set statname $premier
		    } else {
			set msg "duplicate stat name"
			set r 0
			break
		    }
		}
		* {
		    set msg "invalid interface description '<$premier>'"
		    set r 0
		    break
		}
	    }
	}
	set descname [string trim "[string trim $p1] [string trim $p2]"]
    } elseif {[regexp {^".*"$} $desc bidon linkname p1]} {
	set msg "description must not be quoted"
    } elseif {[regexp {^(\S+)(\s+.*)?$} $desc bidon linkname p1]} {
	set descname [string trim $p1]
    } else {
	set msg "invalid link name"
	set r 0
    }

    #
    # Conversion de la description en chaîne de chiffres hexa
    # pour éviter d'avoir à quoter les éléments.
    # Cette chaîne sera propagée dans le graphe, et chaque outil
    # utilisant le graphe devra faire la conversion inverse
    # avec une commande comme par exemple : "binary format H* $desc"
    #

    binary scan $descname H* descname

    return $r
}

proc parse {libdir type modele fdin fdout tab eq} {
    upvar $tab t

    global loadedfiles

    set error 0
    if {[string equal $libdir ""]} then {
	set file "parse-$type.tcl"
    } else {
	set file "$libdir/parse-$type.tcl"
    }

    if {! [info exists loadedfiles($file)]} then {
	if {[file exists $file]} then {
	    uplevel #0 source $file
	    set loadedfiles($file) 1
	} else {
	    puts stderr "Fichier '$file' inexistant"
	    set error 1
	}
    }

    if {! $error} then {
	set error [$type-parse $modele $fdin $fdout t $eq]
    }

    return $error
}

proc initnode {eq} {
    global numnode fmtnode

    set fmtnode "$eq:%d"
    set numnode 0
}

proc newnode {} {
    global numnode fmtnode

    return [format $fmtnode [incr numnode]]
}

proc usage {argv0} {
    puts stderr \
	"$argv0 libdir cisco|juniper modele fichier-conf eq-name \[debug\]"
}

proc main {argv0 argv} {
    global debug

    switch [llength $argv] {
	5 {
	    # rien
	}
	6 {
	    set debug [lindex $argv 5]
	}
	default {
	    usage $argv0
	    return 1
	}
    }

    set libdir  [lindex $argv 0]
    set type    [lindex $argv 1]
    set modele  [lindex $argv 2]
    set fichier [lindex $argv 3]
    set eq      [lindex $argv 4]

    initnode $eq

    set fd [open $fichier "r"]
    set error [parse $libdir $type $modele $fd stdout tab $eq]
    close $fd

    return 0
}


exit [main $argv0 $argv]
