#!%TCLSH%


#
# $Id$
#
# Prend sur l'entrée standard une liste des points de collecte
# (telle que générée par extractcoll -s -w), et la présente au
# métrologiseur par l'intermédiaire du service Web.
#
# Syntaxe :
#	sendcoll [-v] <url>
#
# Exemple :
#	sendcoll http://metro.u-strasbg.fr/bin/setgraph
#
# Historique :
#   2006/06/19 : pda/boggia : conception
#   2006/08/09 : pda        : paramétrisation de l'emplacement de wget
#   2008/07/24 : pda        : envoi des data via un fichier (et non plus argv)
#   2008/07/28 : pda/boggia : recodage en tcl
#   2008/07/30 : pda        : nouveau format de données en entrée
#

# nb de sondes envoyées par requête HTTP
set conf(httplimit)	1000

# verbose (cf option -v)
set conf(verbose)	0


package require http

#
# Lit les lignes issues de "extractcoll -s -w" et en extrait la liste
# des sondes à métrologiser.
#
# Entrée :
#   - fd : descripteur de fichier en entrée
#   - _tab : tableau contenant en sortie les informations
# Sortie :
#   - valeur de retour : message d'erreur ou chaîne vide
#   - paramètre tab : tableau, indexé par les noms de points de métrologie,
#	contenant pour chaque case une liste de la forme :
#	{<type> <eq> <communaute> [<param1> [<param2>]]}
#
# Note :
#   Le format attendu en entrée est composé de trois types de ligne :
#	trafic      <id coll> <eq> <community> <phys iface> <vlan|->
#	nbassocwifi <id coll> <eq> <community> <phys iface> <ssid>
#	nbauthwifi  <id coll> <eq> <community> <phys iface> <ssid>
#
# Historique :
#   2008/07/28 : pda/boggia : conception
#   2008/07/30 : pda        : adaptation au nouveau format d'entrée
#

proc read-coll {fd _tab} {
    upvar $_tab tab

    set r ""
    while {[gets $fd ligne] >= 0} {
	set l [split $ligne]

	set kw [lindex $l 0]
	switch $kw {
	    trafic {
		set id    [lindex $l 1]
		set eq    [lindex $l 2]
		set comm  [lindex $l 3]
		set iface [lindex $l 4]
		set vlan  [lindex $l 5]

		if {! [string equal $vlan "-"]} then {
		    set iface "$iface.$vlan"
		}

		set sonde [list $kw $eq $comm $iface]
	    }
	    nbassocwifi -
	    nbauthwifi {
		set id    [lindex $l 1]
		set eq    [lindex $l 2]
		set comm  [lindex $l 3]
		set iface [lindex $l 4]
		set ssid  [lindex $l 5]

		set sonde [list $kw $eq $comm $iface $ssid]
	    }
	    default {
		return "Type de sonde inconnu ($l)"
	    }
	}

	if {[info exists tab($id)]} then {
	    return "Sonde '$id' présente plusieurs fois"
	}
	set tab($id) $sonde
    }

    return ""
}

#
# Envoi d'une requête HTTP
#
# Entrée :
#   - url : url pour l'envoi
#   - query : les données à POSTer
# Sortie :
#   - valeur de retour : message d'erreur ou chaîne vide
#
# Historique :
#   2008/07/28 : pda/boggia : conception
#   2008/10/05 : pda        : meilleur message d'erreur
#

proc send-http {url query} {
    global conf

    if {[catch {set token [::http::geturl $url -query $query]} m]} then {
	set msg "Erreur de connexion vers $url\n$m"
    } else {
	switch [::http::status $token] {
	    ok {
		set data [::http::data $token]
		switch -glob -- $data {
		    OK* {
			set msg ""
		    }
		    default {
			set msg $data
		    }
		}
	    }
	    default {
		set msg [::http::code $token]
	    }
	}
	::http::cleanup $token
	if {$conf(verbose)} then {
	    puts stderr "$query\n-> '$msg'"
	}
    }
    return $msg
}

#
# Envoi la liste des sondes au métrologiseur
#
# Entrée :
#   - url : url pour l'envoi
#   - _tab : tableau contenant les points de métrologie (voir read-coll)
# Sortie :
#   - valeur de retour : message d'erreur ou chaîne vide
#
# Historique :
#   2008/07/28 : pda/boggia : conception
#

proc send-coll {url _tab} {
    global conf
    upvar $_tab tab

    set n 0
    set larg {}
    foreach id [array names tab] {
	# {<type> <eq> <communaute> [<param1> [<param2>]]}
	set l $tab($id)
	set type   [lindex $l 0]
	set eq     [lindex $l 1]
	set comm   [lindex $l 2]
	set param1 [lindex $l 3]
	set param2 [lindex $l 4]

	lappend larg [::http::formatQuery \
				"sonde_${n}_nom"	$id \
				"sonde_${n}_type"	$type \
				"sonde_${n}_ip"		$eq \
				"sonde_${n}_community"	$comm \
				"sonde_${n}_param_1"	$param1 \
				"sonde_${n}_param_2"	$param2 \
			    ]
	incr n
	if {$n % $conf(httplimit) == 0} then {
	    set query [join $larg "&"]
	    set msg [send-http $url $query]
	    if {! [string equal $msg ""]} then {
		return $msg
	    }
	    set larg {}
	}
    }

    if {$n % $conf(httplimit) != 0} then {
	set query [join $larg "&"]
	set msg [send-http $url $query]
	if {! [string equal $msg ""]} then {
	    return $msg
	}
    }

    return ""
}

#
# Procédure principale
#
# Historique :
#   2008/07/28 : pda/boggia : conception
#


proc usage {argv0} {
    puts stderr "usage: $argv0 url"
    exit 1
}

proc main {argv0 argv} {
    global conf

    #
    # Vérification des arguments
    #

    set conf(verbose) 0

    while {[llength $argv] > 0} {
	switch -- [lindex $argv 0] {
	    -v {
		set conf(verbose) 1
		set argv [lreplace $argv 0 0]
	    }
	    default {
		break
	    }
	}
    }

    if {[llength $argv] != 1} then {
	usage $argv0
	return 1
    }
    set url [lindex $argv 0]

    #
    # Lecture des informations sur l'entrée standard et stockage
    # intermédiaire
    #

    set msg [read-coll stdin tab]
    if {! [string equal $msg ""]} then {
	puts stderr "Erreur lors de la lecture des données\n$msg"
	return 1
    }

    #
    # Envoi des données au métrologiseur et récupération du résultat
    #

    set msg [send-coll $url tab]
    if {! [string equal $msg ""]} then {
	puts stderr "Erreur lors de l'envoi des données à $url\n$msg"
	return 1
    }

    return 0
}

exit [main $argv0 $argv]
