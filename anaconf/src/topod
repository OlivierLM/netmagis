#! %TCLSH%

#  
#  Recette pour accélérer le déroulement de rancid+topo pour permettre
#  la modification de conf par interface Web topo
#  
#  Il faut trois spools (répertoires) différents :
#      - spool des modifications à propager
#      - spool des modifications effectuées
#      - spool des détections de modification
#  
#  Lorsqu'une modification est effectuée sur l'interface Web :
#  
#      Un fichier est généré par modification effectuée (ex: chgt
#      d'affectation d'un port dans un vlan) avec une ligne :
#
#  	eq <eq> iface <iface> [vlan <vlanid>] [desc <desc en hexa>]
#
#      Le fichier est mis dans un spool (i.e. répertoire) des modifications
#      à propager. Le nom du fichier est au format nomeq.YYYYmmddHHMMSS
#  
#      Lorsque la modification est propagée sur l'équipement, le fichier
#      est déplacé dans un spool différent contenant les modifications
#      effectuées (mais pas encore enregistrées par topo).
#  
#  Lorsqu'une modification sur un équipement est détectée :
#  
#      La modification peut être soit une modification automatique
#      poussée à partir de l'interface Web, soit une modification
#      manuelle par un très doué ingénieur réseau.
#  
#      La détection peut-être réalisée via une trappe SNMP ou via
#      l'analyse des fichiers de log. Un fichier doit être généré,
#      dont le nom correspond au nom de l'équipement, dans un spool
#      (différent du précédent).  La présence du fichier toto.u-strasbg.fr
#      indique que l'équipement toto a été modifié.
#  
#  Rancid est remplacé par le programme, constitué d'une boucle infinie
#  (démon), dont le corps est :
#  
#      - une fois par nuit, faire une récupération des confs (rancid original)
#  	et une analyse des confs (topo) complètes
#  
#      - analyser le spool de modifications à effectuer, en regroupant
#  	les modifications par équipement (mais en conservant la
#  	séquence des modifications)
#  
#  	- tester si l'équipement est accessible (fping)
#  	    => l'idée est de ne pas attendre le timeout TCP si
#  		l'équipement est éteint/crashé/etc
#  
#  	- propager ces modifications sur l'équipement s'il est
#  	    accessible (normalement, ces modifications entrainent
#  	    l'apparition d'une entrée dans le spool des modifications
#  	    détectées)
#  
#  	- si la propagation s'est passée sans problème, déplacer les
#  	    fichiers dans le spool des modifications effectuées.
#  
#  	- conserver la liste des équipements pour lesquels la
#  	    propagation des modifications s'est effectuée sans
#  	    problème.
#  
#      - analyser le spool des détections de modifications
#  
#  	- si l'équipement n'est pas dans routers.db, alors râler
#  
#  	- si l'équipement est accessible, alors lancer rancid pour
#  	    récupérer sa configuration
#  
#      - si la configuration d'un équipement a été modifiée/propagée
#  	avec succès, mais que cet équipement n'apparaît pas dans
#  	le spool des détections de modifications, alors râler
#  
#      - lancer topo en restreignant l'analyse aux seuls équipements
#  	modifiés
#  
#      - supprimer les fichiers du spool des modifications effectuées
#  
#
# Historique :
#  2010/02/16 : pda/jean : création
#

set conf(spooldir) "%TOPODIR%/spool"

set conf(spoolmodifies) "$conf(spooldir)/modifies"
set conf(spoolapropager) "$conf(spooldir)/apropager"
set conf(spooleffectues) "$conf(spooldir)/effectues"

#set conf(fping) "%FPING% -q %s"
set conf(fping) "%FPING% %s"

set conf(dumpgraph)	"%TOPODIR%/bin/dumpgraph < %GRAPH%"

#
# Commandes de modification à envoyer pour chaque équipement
#

array set confcmd {
    cisco:*:exec /usr/local/libexec/rancid/clogin
    cisco:*:prologue {
	{configure terminal}
    }
    cisco:*:configifvlan {
	{interface %1$s}
	{switchport access vlan %2$s}
	{exit}
    }
    cisco:*:configifdesc {
	{interface %1$s}
	{description "%2$s}
	{exit}
    }
    cisco:*:epilogue {
	{exit}
	{write memory}
    }

    juniper:*:exec /usr/local/libexec/rancid/jlogin
    juniper:*:prologue {
	{configure}
    }
    juniper:*:configifvlan {
	{top set interface %1$s unit 0 family ethernet-switching vlan members %2$s}
    }
    juniper:*:configifdesc {
	{top set interface %1$s description "%2$s"}
    }
    juniper:*:epilogue {
	{exit configuration}
	{commit}
    }

    hp:*:exec /usr/local/libexec/rancid/hlogin
    hp:*:prologue {
	{configure terminal}
    }
    hp:*:configifvlan {
	{vlan %2$s}
	{untagged %1$s}
	{exit}
    }
    hp:*:configifdesc {
	{interface %1$s}
	{name "%2$s"}
	{exit}
    }
    hp:*:epilogue {
	{exit}
	{write memory}
    }
}

#
# Lit le spool des modifications à propager
#
# Entrée :
#  _tab : nom du tableau à remplir
#  dir : répertoire du spool
# Sortie :
#   tab : tableau indexé suivant le nom de l'équipement contenant
#          la liste des fichiers de modification à propager
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc lire-apropager {_tab dir} {
    upvar $_tab tab
    
    set lfile [glob -nocomplain -directory $dir "*"]
    foreach file [lsort $lfile] {
	if {[regexp {([^/]+)\.(\d+)$} $file bidon eq date]} then {
	    lappend tab($eq) $file
	}
    }
}

#
# Propage un ensemble de modifications sur un équipement
#
# Entrée :
#  eq : nom de l'équipement
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  lfile : liste triée de fichiers de modifications à appliquer
# Sortie :
#   valeur de retour : liste de fichiers correctement appliqués
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc propager {eq type model lfile} {
    global conf
    
    set r {}

    # 
    # Teste si l'équipement est joignable
    # 

    set cmd [format $conf(fping) $eq]

    if {! [catch {exec sh -c $cmd} m]} then {
	foreach file $lfile {
	    if {[catch {set fd [open $file "r"]} msg]} then {
		puts stderr "cannot open $file ($msg)"
		# XXXXXXXXXXXXXXXXXXXXXX affiner le traitement des erreurs
		exit 1
	    } else {
		set line [read $fd]
		close $fd

		set msg [envoyer-cmd $eq $type $model $line]
		if {! [string equal $msg ""]} then {
		    puts stderr "envoi de la modification impossible ($msg)"
		    exit 1
		}
		
		lappend r $file
	    }
	}
    } else {
	puts stderr "équipement $eq injoignable (fping) ($m)"
    }

    return $r
}

#
# Envoi une commande a un equipement
#
# Entrée :
#  eq : nom de l'équipement
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  line : modification au format 
#	  	eq <eq> iface <iface> [vlan <vlanid>] [desc <desc en hexa>]
# Sortie :
#   valeur de retour : message d'erreur ou chaîne vide si ok
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc envoyer-cmd {eq type model line} {
    global conf 

    set msg ""
    array set t $line

    #
    # Vérification de la syntaxe
    #

    if {[info exists t(eq)] &&
	    [info exists t(iface)] &&
	    ([info exists t(vlan)] || [info exists t(desc)])} then {
	
	#
	# Constituer la liste de commandes à envoyer
	#

	set lcmd {}

	set prologue [fetch-conf $type $model "prologue"]

	set lcmd [concat $lcmd $prologue]

	if {[info exists t(vlan)]} then {

	    foreach fmt [fetch-conf $type $model "configifvlan"] {
		lappend lcmd [format $fmt $t(iface) $t(vlan)]
	    }
	}
	if {[info exists t(desc)]} then {
	    foreach fmt [fetch-conf $type $model "configifdesc"] {
		lappend lcmd [format $fmt $t(iface) [binary format "H*" $t(desc)]
	    }
	}
	set epilogue [fetch-conf $type $model "epilogue"]
	set lcmd [concat $lcmd $epilogue]

	#
	# Envoyer la commande
	#

	set msg [execute-cmd $eq $type $model $lcmd]
	
    } else {
	set msg "bad format for $file"
    }

    return $msg
}

#
# Execute une séquence de commandes sur un équipement
#
# Entrée :
#  eq : nom de l'équipement
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  lcmd : liste des commandes à exécuter
# Sortie
#  valeur de retour : message d'erreur éventuel, ou chaîne vide
#
# Historique : 
#  2010/02/18 : pda/jean : création
#

proc execute-cmd {eq type model lcmd} {
    global conf

    set r ""

    set cmd [join $lcmd ";"]
    
    set time [clock format [clock seconds] -format "%Y%m%d%H%M%S"]
    set file "$conf(spooleffectues)/$eq.log.$time"

    set exec [fetch-conf $type $model "exec"]

    if {[catch {exec $exec -c $cmd $eq > $file} m]} then {
	set r "erreur interne d'exécution de la commande '$exec -c $cmd $eq>$file' ($m)"
    }

    #
    # XXXXXXXXXX : interpréter le fichier résultant de l'exécution
    #

    return $r
}

#
# Renvoie la commande associée à un type d'équipement
# et un type de configuration
#
# Entrée :
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  context : prologue, configifvlan, configifdesc, epilogue
# Sortie
#  valeur de retour : commande à exécuter
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc fetch-conf {type model context} {
    global confcmd
    
    set r ""
    if {[info exists confcmd($type:*:$context)]} then {
	set r $confcmd($type:*:$context)
    } elseif {[info exists confcmd($type:$model:$context)]} then {
	set r $confcmd($type:$model:$context)
    } else {
	puts stderr "type de configuration non trouvé : $type:$model:$context"
	exit 1
    }

    return $r
}

#
# Recherche le type et le modèle des équipements connus dans le graphe
#
# Entrée :
#  _tabtype : nom du tableau contenant en retour les types
# Sortie :
#  tabtype : tableau, indexé par nom court de l'équipement, contenant
#	tabtype(<eq>) {<type> <model>}
#  valeur de retour : message d'erreur ou chaîne vide si ok
# 
# Historique : 
#  2010/02/25 : pda/jean : création
#

proc lire-type-eq {_tabtype} {
    global conf
    upvar $_tabtype tabtype

    set msg ""

    set cmd $conf(dumpgraph)
    if {! [catch {set fd [open "|$cmd" "r"]} msg]} then {
	while {[gets $fd ligne] > -1} {
	    switch [lindex $ligne 0] {
		eq {
		    array set t $ligne
		    set eq $t(eq)
		    set type $t(type)
		    set model $t(model)

		    set tabtype($eq) [list $type $model]
		    array unset t
		}
	    }
	}
	close $fd
    }

    return $msg
}

#
# Programme principal
#

proc main {argv0 argv} {
    global conf

    lire-apropager tab $conf(spoolapropager)
    lire-type-eq tabtype

    foreach eq [array names tab] {
	# supprimer le nom de domaine pour ne garder que le nom court
	regsub {\..*} $eq "" eqcourt
	if {[info exists tabtype($eqcourt)]} then {
	    set type  [lindex $tabtype($eqcourt) 0]
	    set model [lindex $tabtype($eqcourt) 1]
	    set lf [propager $eq $type $model $tab($eq)]
	} else {
	    puts stderr "Type/model inconnus pour l'équipement '$eq'"
	}
    }

    return 0
}

exit [main $argv0 $argv]
