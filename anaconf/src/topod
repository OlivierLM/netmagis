#! %TCLSH%

#  
#  Recette pour accélérer le déroulement de rancid+topo pour permettre
#  la modification de conf par interface Web topo
#  
#  Il faut trois spools (répertoires) différents :
#      - spool des modifications à propager
#      - spool des modifications effectuées
#      - spool des détections de modification
#  
#  Lorsqu'une modification est effectuée sur l'interface Web :
#  
#      Un fichier est généré par modification effectuée (ex: chgt
#      d'affectation d'un port dans un vlan) avec une ligne :
#
#  	eq <eq> iface <iface> [desc <desc en hexa>] 
#               [ether <vlanid>] [voice <vlanid>]
#
#      Le fichier est mis dans un spool (i.e. répertoire) des modifications
#      à propager. Le nom du fichier est au format nomeq.YYYYmmddHHMMSS
#  
#      Lorsque la modification est propagée sur l'équipement, le fichier
#      est déplacé dans un spool différent contenant les modifications
#      effectuées (mais pas encore enregistrées par topo).
#  
#  Lorsqu'une modification sur un équipement est détectée :
#  
#      La modification peut être soit une modification automatique
#      poussée à partir de l'interface Web, soit une modification
#      manuelle par un très doué ingénieur réseau.
#  
#      La détection peut-être réalisée via une trappe SNMP ou via
#      l'analyse des fichiers de log. Un fichier doit être généré,
#      dont le nom correspond au nom de l'équipement, dans un spool
#      (différent du précédent).  La présence du fichier toto.u-strasbg.fr
#      indique que l'équipement toto a été modifié.
#  
#  Rancid est remplacé par le programme, constitué d'une boucle infinie
#  (démon), dont le corps est :
#  
#      - une fois par nuit, faire une récupération des confs (rancid original)
#  	et une analyse des confs (topo) complètes
#  
#      - analyser le spool de modifications à effectuer, en regroupant
#  	les modifications par équipement (mais en conservant la
#  	séquence des modifications)
#  
#  	- tester si l'équipement est accessible (fping)
#  	    => l'idée est de ne pas attendre le timeout TCP si
#  		l'équipement est éteint/crashé/etc
#  
#  	- propager ces modifications sur l'équipement s'il est
#  	    accessible (normalement, ces modifications entrainent
#  	    l'apparition d'une entrée dans le spool des modifications
#  	    détectées)
#  
#  	- si la propagation s'est passée sans problème, déplacer les
#  	    fichiers dans le spool des modifications effectuées.
#  
#  	- conserver la liste des équipements pour lesquels la
#  	    propagation des modifications s'est effectuée sans
#  	    problème.
#  
#      - analyser le spool des détections de modifications
#  
#  	- si l'équipement n'est pas dans routers.db, alors râler
#  
#  	- si l'équipement est accessible, alors lancer rancid pour
#  	    récupérer sa configuration
#  
#      - si la configuration d'un équipement a été modifiée/propagée
#  	avec succès, mais que cet équipement n'apparaît pas dans
#  	le spool des détections de modifications, alors râler
#  
#      - lancer topo en restreignant l'analyse aux seuls équipements
#  	modifiés
#  
#      - supprimer les fichiers du spool des modifications effectuées
#  
#
# Historique :
#  2010/02/16 : pda/jean : création
#

set conf(spooldir) "%TOPODIR%/spool"

set conf(spoolmodifies) "$conf(spooldir)/modifies"
set conf(spoolapropager) "$conf(spooldir)/apropager"
set conf(spooleffectues) "$conf(spooldir)/effectues"

#set conf(fping) "%FPING% -q %s"
set conf(fping) "%FPING% %s"

set conf(dumpgraph)	"%TOPODIR%/bin/dumpgraph < %GRAPH%"
set conf(extracteq)	{%TOPODIR%/bin/extracteq %1$s %2$s < %GRAPH%}

#
# Commandes de modification à envoyer pour chaque équipement
#
# Ces quatre actions doivent être paramétrées en fonction du
# type d'équipement. Pour cela, le tableau confcmd contient
# les commandes à passer sur chaque type d'équipement.
#
# La clef est de la forme :
#   type:modele:action
# Le modèle peut être "*"
# Exemple :
#   confcmd(cisco:3750:ifaccess) ...
#   confcmd(cisco:*:ifaccess) ...
#
# La valeur est une liste de lignes à passer sur l'équipement.
# Ces lignes sont paramétrés.
#
# Les différentes actions sont :
#   
#   exec
#	commande shell a appeler pour envoyer des commandes à exécuter sur
#	l'équipement. Les autres actions sont exécutées sur l'équipement
#	lui-même.
#   prologue
#	entrer en mode configuration sur l'équipement
#   ifreset
#	remettre l'interface dans un mode connu (la plupart du temps par
#	suppression de tous les vlans sur l'interface).
#	Paramètres :
#	    %1$ : nom de l'interface
#   resetvlans
#	dans le cas où on ne peut pas remettre l'interface dans un mode
#	connu (par exemple sur HP), commande à passer pour tous les vlans
#	pour retirer l'interface de ces vlans.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : numéro de vlan
#   ifaccess
#	positionner un vlan d'accès donné sur une interface.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : numéro de vlan
#   ifvoice
#	positionner un voice vlan donné sur une interface.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : numéro de vlan
#   ifdesc
#	positionner la description sur une interface.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : description
#   epilogue
#	quitter le mode de configuration et enregistrer la configuration saisie
#
#

array set confcmd {
    cisco:*:exec /usr/local/libexec/rancid/clogin

    cisco:*:prologue {
	  {configure terminal}
    }
    cisco:*:ifreset {
	  {interface %1$s}
	  {no switchport}
	  {switchport}
    }
    cisco:*:ifdisable {
	{interface %1$s}
	{shutdown}
    }
    cisco:*:ifenable {
	{interface %1$s}
	{no shutdown}
    }
    cisco:*:ifaccess {
	      {interface %1$s}
	      {switchport access vlan %2$s}
	  }
    cisco:*:ifvoice {
	      {interface %1$s}
	      {switchport voice vlan %2$s}
	  }
    cisco:*:ifdesc {
	      {interface %1$s}
	      {description %2$s}
	  }
    cisco:*:epilogue {
	      {line con 0}
	      {exit}
	      {exit}
	      {write memory}
	  }

    juniper:*:exec /usr/local/libexec/rancid/jlogin

    juniper:*:prologue {
	{configure}
    }
    juniper:*:ifreset {
	{delete interfaces %1$s unit 0 family ethernet-switching}
	{delete ethernet-switching-options voip interface %1$s}
    }
    juniper:*:ifdisable {
	{set interfaces %1$s disable}
    }
    juniper:*:ifenable {
	{delete interfaces %1$s disable}
    }
    juniper:*:ifaccess {
	{set interfaces %1$s unit 0 family ethernet-switching port-mode access}
	{set interfaces %1$s unit 0 family ethernet-switching vlan members %2$s}
    }
    juniper:*:ifdesc {
	{set interfaces %1$s description "%2$s"}
    }
    juniper:*:ifvoice {
	{set ethernet-switching-options voip interface %1$s vlan %2$s}
    }
    juniper:*:epilogue {
	{commit}
	{exit configuration}
    }

    hp:*:exec /usr/local/libexec/rancid/hlogin
    hp:*:prologue {
	{configure terminal}
    }
    hp:*:resetvlans {
	{vlan %2$s}
	{no tagged %1$s}
	{no untagged %1$s}
    }

    hp:*:ifenable {
	{interface %1$s}
	{enable}
    }
    hp:*:ifdisable {
	{interface %1$s}
	{disable}
    }
    hp:*:ifaccess {
	{vlan %2$s}
	{untagged %1$s}
    }
    hp:*:ifvoice {
	{vlan %2$s}
	{tagged %1$s}
    }
    hp:*:ifdesc {
	{interface %1$s}
	{name "%2$s"}
    }
    hp:*:epilogue {
	{vlan 1}
	{exit}
	{exit}
	{write memory}
    }
}

#
# Lit le spool des modifications à propager
#
# Entrée :
#  _tab : nom du tableau à remplir
#  dir : répertoire du spool
# Sortie :
#   tab : tableau indexé suivant le nom de l'équipement contenant
#          la liste des fichiers de modification à propager
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc lire-apropager {_tab dir} {
    upvar $_tab tab
    
    set lfile [glob -nocomplain -directory $dir "*"]
    foreach file [lsort $lfile] {
	if {[regexp {([^/]+)\.(\d+)$} $file bidon eq date]} then {
	    lappend tab($eq) $file
	}
    }
}

#
# Propage un ensemble de modifications sur un équipement
#
# Entrée :
#  eq : nom de l'équipement
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  lfile : liste triée de fichiers de modifications à appliquer
# Sortie :
#   valeur de retour : liste de fichiers correctement appliqués
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc propager {eq type model lfile} {
    global conf
    
    set r {}

    # 
    # Teste si l'équipement est joignable
    # 

    set cmd [format $conf(fping) $eq]

    if {! [catch {exec sh -c $cmd} m]} then {
	foreach file $lfile {
	    if {[catch {set fd [open $file "r"]} msg]} then {
		puts stderr "cannot open $file ($msg)"
		# XXXXXXXXXXXXXXXXXXXXXX affiner le traitement des erreurs
		exit 1
	    } else {
		set line [read $fd]
		close $fd

		set msg [envoyer-modif $eq $type $model $line]
		if {! [string equal $msg ""]} then {
		    puts stderr "envoi de la modification impossible ($msg)"
		    exit 1
		}
		
		lappend r $file
	    }
	}
    } else {
	puts stderr "équipement $eq injoignable (fping) ($m)"
    }

    return $r
}

#
# Envoi une modification a un equipement
#
# Entrée :
#  eq : nom de l'équipement
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  line : modification au format spécifié au début de ce fichier
# Sortie :
#   valeur de retour : message d'erreur ou chaîne vide si ok
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc envoyer-modif {eq type model line} {
    global conf 

    set msg ""
    array set t $line

    #
    # Vérification de la syntaxe
    #

    if {[info exists t(eq)] && [info exists t(iface)] &&
	    (	[info exists t(ether)] ||
		[info exists t(voice)] ||
		[info exists t(desc)])} then {
	
	#
	# Constituer la liste de commandes à envoyer
	#

	set lcmd {}

	set prologue [fetch-conf $type $model "prologue"]

	set lcmd [concat $lcmd $prologue]

	if {[info exists t(desc)]} then {
	    foreach fmt [fetch-conf $type $model "ifdesc"] {
		lappend lcmd [format $fmt $t(iface) [binary format "H*" $t(desc)]]
	    }
	}

	#
	# On remet l'interface dans un état connu dans tous les cas
	#

	set lcmd [concat $lcmd [resetif $eq $type $model $t(iface)]]

	# 
	# En fonction de ce qui se trouve dans le fichier spool, on 
	# execute des commandes sur l'équipement. 
	# 
	#   Ether	    Voice	Opération
	#   -----------------------------------------------------
	#   Non		    Non		Désactiver l'interface
	#   Non		    Oui		Voice vlan uniquement
	#   Oui		    Non		Vlan d'accès uniquement
	#   Oui		    Oui		Vlan d'accès + Voice Vlan
	#

	set ether [info exists t(ether)]
	set voice [info exists t(voice)]
	
	switch -- "$ether$voice" {
	    00	{
		# Rien
	    }
	    01	{
		foreach fmt [fetch-conf $type $model "ifvoice"] {
		    lappend lcmd [format $fmt $t(iface) $t(voice)]
		}
	    }
	    10	{
		foreach fmt [fetch-conf $type $model "ifaccess"] {
		    lappend lcmd [format $fmt $t(iface) $t(ether)]
		}
	    }
	    11  {
		foreach fmt [fetch-conf $type $model "ifvoice"] {
		    lappend lcmd [format $fmt $t(iface) $t(voice)]
		}
		foreach fmt [fetch-conf $type $model "ifaccess"] {
		    lappend lcmd [format $fmt $t(iface) $t(ether)]
		}
	    }
	}

	set epilogue [fetch-conf $type $model "epilogue"]
	set lcmd [concat $lcmd $epilogue]

	#
	# Envoyer la commande
	#

	set msg [execute-cmd $eq $type $model $lcmd]
	
    } else {
	set msg "bad format for '$line'"
    }

    return $msg
}

#
# Genere une liste de commande pour remettre une interface
# dans un état connu et l'activer
#
# Entrée :
#  eq : nom de l'équipement
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  iface : nom de l'interface
#
# Sortie
#  valeur de retour : liste des commandes à passer sur l'équipement
#
# Historique : 
#  2010/09/23 : pda/jean : création
#

proc resetif {eq type model iface} {

    #
    # Cherche la sequence de commande pour remettre l'interface
    # dans un mode connu
    #

    set lcmd {}
    foreach fmt [fetch-conf $type $model "ifreset"] {
	lappend lcmd [format $fmt $iface]
    }

    set l2 [fetch-conf $type $model "resetvlans"]
    if {[llength $l2]>0} then {
	foreach vlan [get-vlans $eq $iface] {
	    foreach fmt $l2 {
		lappend lcmd [format $fmt $iface $vlan]
	    }
	}
    }

    #
    # Active l'interface
    #

    foreach fmt [fetch-conf $type $model "ifenable"] {
	lappend lcmd [format $fmt $iface]
    }
    
    return $lcmd
}

#
# Liste les vlans pour un équipement et une interface donnée
#
# Entrée :
#  eq : nom de l'équipement
#  iface : nom de l'interface
# Sortie
#  valeur de retour : liste des vlans trouvés
#

proc get-vlans {eq iface} {
    global conf

    set lvlans {}

    # supprimer le nom de domaine pour ne garder que le nom court
    regsub {\..*} $eq "" eqcourt

    set cmd [format $conf(extracteq) $eqcourt $iface]
    if {! [catch {set fd [open "|$cmd" "r"]} msg]} then {
	while {[gets $fd ligne] > -1} {
	    foreach vlan [lreplace $ligne 0 7] {
		lappend lvlans [lindex $vlan 0]
	    }
	}
	close $fd
    } else {
	puts stderr "extracteq : $msg"
    }

    return $lvlans
}

#
# Execute une séquence de commandes sur un équipement
#
# Entrée :
#  eq : nom de l'équipement
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  lcmd : liste des commandes à exécuter
# Sortie
#  valeur de retour : message d'erreur éventuel, ou chaîne vide
#
# Historique : 
#  2010/02/18 : pda/jean : création
#

proc execute-cmd {eq type model lcmd} {
    global conf

    set r ""

    set cmd [join $lcmd ";"]
    
    set time [clock format [clock seconds] -format "%Y%m%d%H%M%S"]
    set file "$conf(spooleffectues)/$eq.log.$time"

    set exec [fetch-conf $type $model "exec"]

    if {[catch {exec $exec -c $cmd $eq > $file} m]} then {
	set r "erreur interne d'exécution de la commande '$exec -c $cmd $eq>$file' ($m)"
    }

    #
    # XXXXXXXXXX : interpréter le fichier résultant de l'exécution
    #

    return $r
}

#
# Renvoie la commande associée à un type d'équipement
# et un type de configuration
#
# Entrée :
#  type : type d'équipement (ex: cisco, juniper etc.)
#  model : modèle d'équipement (ex: 3750, M20 etc.)
#  context : prologue, ifaccess, ifdesc, epilogue
# Sortie
#  valeur de retour : commande à exécuter ou liste vide si non trouvé
#
# Historique : 
#  2010/02/16 : pda/jean : création
#

proc fetch-conf {type model context} {
    global confcmd
    
    set r {}
    if {[info exists confcmd($type:*:$context)]} then {
	set r $confcmd($type:*:$context)
    } elseif {[info exists confcmd($type:$model:$context)]} then {
	set r $confcmd($type:$model:$context)
    }

    return $r
}

#
# Recherche le type et le modèle des équipements connus dans le graphe
#
# Entrée :
#  _tabtype : nom du tableau contenant en retour les types
# Sortie :
#  tabtype : tableau, indexé par nom court de l'équipement, contenant
#	tabtype(<eq>) {<type> <model>}
#  valeur de retour : message d'erreur ou chaîne vide si ok
# 
# Historique : 
#  2010/02/25 : pda/jean : création
#

proc lire-type-eq {_tabtype} {
    global conf
    upvar $_tabtype tabtype

    set msg ""

    set cmd $conf(dumpgraph)
    if {! [catch {set fd [open "|$cmd" "r"]} msg]} then {
	while {[gets $fd ligne] > -1} {
	    switch [lindex $ligne 0] {
		eq {
		    array set t $ligne
		    set eq $t(eq)
		    set type $t(type)
		    set model $t(model)

		    set tabtype($eq) [list $type $model]
		    array unset t
		}
	    }
	}
	close $fd
    }

    return $msg
}

#
# Programme principal
#

proc main {argv0 argv} {
    global conf

    lire-apropager tab $conf(spoolapropager)
    lire-type-eq tabtype

    foreach eq [array names tab] {
	# supprimer le nom de domaine pour ne garder que le nom court
	regsub {\..*} $eq "" eqcourt
	if {[info exists tabtype($eqcourt)]} then {
	    set type  [lindex $tabtype($eqcourt) 0]
	    set model [lindex $tabtype($eqcourt) 1]
	    set lf [propager $eq $type $model $tab($eq)]
	} else {
	    puts stderr "Type/model inconnus pour l'équipement '$eq'"
	}
    }

    return 0
}

exit [main $argv0 $argv]
