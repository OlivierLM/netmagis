#!/usr/local/bin/tclsh8.5

#
# Script de génération d'une configuration DHCP
#
# Syntaxe :
#		generer-dhcp [test|gen]
#
#   avec "test" pour tester si la configuration doit être générée, ou "gen"
#		pour générer la zone.
#		Code de retour = 0 (rien à générer), 1 (erreur), 2 (génération)
#
# Historique
#   2004/08/05 : pda/jean : spécification
#   2004/08/06 : pda/jean : conception
#   2005/03/31 : pda	  : ajout des groupes DHCP
#   2008/07/12 : jean	 : integration des profils dans les intervalles
#   2008/07/16 : jean	 : integration du failover pour les intervalles
#   2011/04/21 : jean	 : generalisation des groupes
#


#
# Valeurs par défaut du script
#
set conf(base)			{host=crc.u-strasbg.fr dbname=devdns 
						user=dns password=mot-de-passe-de-dns}

#
# Chaine de configuration pour la redondance dhcp
#
# Pour un serveur isc-dhcp sans redondance
#set conf(failover)		{}
# Pour un serveur isc-dhcp avec redondance
set conf(failover)		{failover peer "dhcp"; }

package require Pgtcl

#
# Neutralise les caractères spéciaux figurant dans une chaîne,
# de façon à pouvoir la passer au moteur SQL.
# - double toutes les apostrophes
#
# Entrée :
#   - paramètres
#		- chaine : chaîne à traiter
#		- maxindex (optionnel) : taille maximum de la chaîne
# Sortie :
#   - valeur de retour : la chaîne traitée
#
# Historique
#   1999/07/14 : pda : conception et codage
#   1999/10/24 : pda : mise en package
#

proc quote {chaine {maxindex 99999}} {
	set chaine [string range $chaine 0 $maxindex]
	regsub -all {'} $chaine {&&} chaine
	regsub -all {\\} $chaine {&&} chaine
	return $chaine
}

#
# Exécute une commande sql, et affiche une erreur et sort
# en cas de problème. Retourne le résultat de la commande
# (résultat pour pg_result).
#
# Entrée :
#   - paramètres
#		- dbfd : la base
#		- cmd : la commande à passer
#		- result : contient en retour le nom de la variable contenant l'erreur
# Sortie :
#   - valeur de retour : 1 si tout est ok, 0 sinon
#   - variable result :
#		- si erreur, la variable contient le message d'erreur
#
# Historique
#   1999/07/14 : pda : conception et codage
#   1999/10/24 : pda : mise en package
#

proc execsql {dbfd cmd result} {
	upvar $result rmsg

	set res [pg_exec $dbfd $cmd]
	if {! [string equal [pg_result $res -status] PGRES_COMMAND_OK]} then {
		set ok 0
		set rmsg "$cmd : [pg_result $res -error]"
	} else {
		set ok 1
		set rmsg {}
	}
	pg_result $res -clear
	return $ok
}

#
# Teste si la configuration DHCP a été modifiée
#
# Entrée :
#   - dbfd : accès à la base
# Sortie :
#   - valeur de retour : 0 ou 1
#
# Historique :
#   2004/08/05 : pda/jean : conception
#

proc tester-dhcp {dbfd} {
	set r 0
	pg_select $dbfd "SELECT generer FROM dns.dhcp" tab {
		if {$tab(generer) > 0} then {
			set r 1
		}
	}
	return $r
}

#
# Indente un profil DHCP
#
# Entrée :
#   - profil : chaine contenant le profil
#   - n : niveau d'indentation
# Sortie :
#   - valeur de retour : chaine identée
#
proc indent-profile {profil n} {
	set indent [string repeat "\t" $n]
	
	set lprofil [split $profil "\n"]
	set p [join $lprofil "\n$indent"]

	return "$indent$p"
}

#
# Renvoie sur la sortie standard la configuration DHCP
#
# Entrée :
#   - dbfd : accès à la base
# Sortie :
#   - valeur de retour : 1 si ok, 0 si erreur
#   - sortie standard : la configuration DHCP
#   - sortie d'erreur : les erreurs s'il y en a
#
# Historique :
#   2004/08/05 : pda/jean : conception
#   2005/03/31 : pda	  : ajout des groupes DHCP
#

proc generer-dhcp {dbfd} {

	global conf

	#
	# Cosmétique
	#

	set accg "\{"
	set accd "\}"

	#
	# Récupérer les valeurs de paramètres DHCP par défaut stockées
	# dans la configuration générale de l'application
	#

	foreach clef {default_lease_time max_lease_time min_lease_time dhcpdefdomain dhcpdefdnslist} {
		set dhcpdef($clef) -1
		set sql "SELECT valeur FROM global.config WHERE clef = '$clef'"
		pg_select $dbfd $sql tab {
			set dhcpdef($clef) $tab(valeur)
		}
	}

	#
	# Récupérer les attributs de chaque intervalle d'allocation dynamique
	# et les stocker avec comme clef l'adresse du réseau auquel il
	# appartient.
	#
	set sql "SELECT HOST (reseau.adr4) AS adr, domaine.nom AS dom, dhcprange.*
			FROM dns.reseau, dns.dhcprange, dns.domaine
			WHERE reseau.dhcp > 0
				AND domaine.iddom = dhcprange.iddom
				AND dhcprange.min <<= reseau.adr4
				AND dhcprange.max <<= reseau.adr4
			"
	pg_select $dbfd $sql tab {
		if {$tab(default_lease_time) == 0} then {
			set tab(default_lease_time) $dhcpdef(default_lease_time)
		}
		if {$tab(max_lease_time) == 0} then {
			set tab(max_lease_time) $dhcpdef(max_lease_time)
		}
		lappend range($tab(adr)) \
				[list $tab(dom) \
					$tab(min) $tab(max) \
					$tab(default_lease_time) $tab(max_lease_time) \
					$tab(iddhcpprofil) \
				]
	}

	#
	# Récupérer les profils DHCP
	#

	set sql "SELECT iddhcpprofil, nom, texte FROM dns.dhcpprofil"
	pg_select $dbfd $sql tab {
		set dhcpprofil($tab(iddhcpprofil)) $tab(texte)
		set dhcpprofil($tab(iddhcpprofil):nom) $tab(nom)
	}
	# Profil par defaut
	set dhcpprofil(default)		"option domain-name \"$dhcpdef(dhcpdefdomain)\";\n"
	append dhcpprofil(default)	"option domain-name-servers $dhcpdef(dhcpdefdnslist);"
	set dhcpprofil(default:nom)	"hosts without a profile"

	#
	# Générer chaque réseau trouvé
	#

	set sql "SELECT HOST (adr4) AS reseau, MASKLEN (adr4) AS masklen,
				NETMASK (adr4) AS netmask, gw4, nom
			FROM dns.reseau
			WHERE dhcp > 0 AND gw4 IS NOT NULL
			ORDER BY reseau
			"
	pg_select $dbfd $sql tab {
		set reseau  $tab(reseau)
		set masklen $tab(masklen)
		puts stdout "# $tab(nom)"
		puts stdout "subnet $reseau netmask $tab(netmask) $accg"
		puts stdout "\toption routers $tab(gw4) ;"
		if {[info exists range($reseau)]} then {
			foreach pool $range($reseau) {
			    lassign $pool dom min max default_lease_time max_lease_time iddhcpprofil

				puts stdout "\tpool $accg"
				if {[info exists conf(failover)] &&
					![string equal $conf(failover) ""] } then {
					puts stdout "\t\t$conf(failover)"
				}
				set addprofile ""
				if {[info exists dhcpprofil($iddhcpprofil)]} then {
					set addprofile $dhcpprofil($iddhcpprofil)
					puts stdout [indent-profile $addprofile 2]
				}
				puts stdout "\t\trange $min $max ;"
				puts stdout "\t\tdeny dynamic bootp clients;"
				# Ajout du domaine si le profile n'en contient pas
				if {! [regexp {option domain-name } $addprofile]} {
					if {![string equal $dom ""]} {
						puts stdout "\t\toption domain-name \"$dom\" ;"
					} else {
						puts stdout "\t\toption domain-name \"$dhcpdef(dhcpdefdomain)\" ;"
					}
				}
				# Ajout des serveur de nom par defaut si le profile n'en contient pas
				if {! [regexp {option domain-name-servers } $addprofile]} {
					puts stdout "\t\toption domain-name-servers $dhcpdef(dhcpdefdnslist) ;"
				}
				if {$max_lease_time < $dhcpdef(min_lease_time)} then {
					puts stdout "\t\t# max-lease-time $max_lease_time ;"
					puts stderr "Max-lease-time trop petit ($max_lease_time) pour <$min,$max>"
				} else {
					puts stdout "\t\tmax-lease-time $max_lease_time ;"
				}
				if {$default_lease_time < $dhcpdef(min_lease_time)} then {
					puts stderr "Default-lease-time trop petit ($default_lease_time) pour <$min,$max>"
					puts stdout "\t\t# default-lease-time $default_lease_time ;"
				} else {
					puts stdout "\t\tdefault-lease-time $default_lease_time ;"
				}
				puts stdout "\t$accd"
			}
		}

		#
		# Générer tous les groupes de hosts :
		# recuperer les hosts qui ont une adresse MAC valide dans
		# le réseau courant
		#

		array unset groups
		set sql2 "SELECT rr.nom || '.' || domaine.nom AS host,
				rr.mac,
				rr_ip.adr,
				rr.iddhcpprofil
				FROM dns.rr, dns.domaine, dns.rr_ip, dns.reseau
				WHERE rr.iddom = domaine.iddom
				AND rr.idrr = rr_ip.idrr
				AND rr_ip.adr <<= '$reseau/$masklen'
				AND reseau.adr4 = '$reseau/$masklen'
				AND reseau.dhcp > 0
				AND rr.mac IS NOT NULL
				ORDER BY rr.iddhcpprofil
				"
		pg_select $dbfd $sql2 tab2 {
			set ip $tab2(adr)
			set host $tab2(host)
			# Vide si pas de profil
			set id $tab2(iddhcpprofil)
			if {[string equal $id ""]} then {
				set id "default"
			}

			# Genere un nom unique si le host a plusieurs adresses
			set nocc ""
			if {[info exists occur($host)]} then {
				set nocc $occur($host)
				incr occur($host)
			} else {
				set occur($host) 1
			}
			
			append groups($id) "\t\thost $host$nocc $accg\n"
			append groups($id) "\t\t\tstash-agent-options true ;\n"

			append groups($id) "\t\t\thardware ethernet $tab2(mac) ;\n"
			append groups($id) "\t\t\tfixed-address $tab2(adr) ;\n"
			append groups($id) "\t\t\toption host-name \"$host\" ;\n"
			append groups($id) "\t\t$accd\n"
		}

		# Produit les groupes pour ce sous-réseau
		foreach id [array names groups] {
			puts stdout "\tgroup $accg # start group for $dhcpprofil($id:nom)"
			if {[info exists dhcpprofil($id)]} then {
				set addprofile $dhcpprofil($id)
				puts stdout [indent-profile $addprofile 2]
				# Ajout du domaine si le profile n'en contient pas
				if {! [regexp {option domain-name } $addprofile]} {
					puts stdout "\t\toption domain-name \"$dhcpdef(dhcpdefdomain)\" ;"
				}
				# Ajout des serveur de nom par defaut si le profile n'en contient pas
				if {! [regexp {option domain-name-servers } $addprofile]} {
					puts stdout "\t\toption domain-name-servers $dhcpdef(dhcpdefdnslist) ;"
				}
			} else {
				puts stderr "Référence à un profil DHCP inexistant ($id)"
			}
			puts stdout $groups($id)
			puts stdout "\t$accd # end group for $dhcpprofil($id:nom)"
		}

		puts stdout "$accd # end subnet $tab(nom)"
		puts stdout ""
	}

	#
	# Fin de la génération : se rappeler du fait que nous avons
	# généré le fichier
	#

	set sql "UPDATE dns.dhcp SET generer = 0"
	if {! [execsql $dbfd $sql m]} then {
		puts stderr $m
		return 0
	}

	#
	# Tout va bien !
	#

	return 1
}

##############################################################################
# main
##############################################################################

proc main {argv0 argv} {
	global conf

	set arg [lindex $argv 0]
	if {[llength $argv] != 1 ||
		!([string equal $arg "test"] || [string equal $arg "gen"])} then {
		puts stderr "usage: $argv0 <test|gen>"
		return 1
	}

	if {[catch {set dbfd [pg_connect -conninfo $conf(base)]} msg]} then {
		puts stderr "$argv0: cannot access base ($msg)"
		return 1
	}

	set sql "BEGIN WORK ; LOCK dns.dhcp ; LOCK dns.rr ; LOCK dns.reseau ; LOCK dns.dhcprange"
	if {! [execsql $dbfd $sql m]} then { puts stderr $m ; exit 1 }

	switch -- $arg {
		test {
			set r [tester-dhcp $dbfd]
			if {$r} then {
				puts stdout "La configuration DHCP doit être regénérée"
				set r 2
			}
			return $r
		}
		gen {
			if {! [generer-dhcp $dbfd]} then {
				set sql "ABORT WORK"
				execsql $dbfd $sql m
				return 1
			}
		}
	}

	set sql "COMMIT WORK"
	if {! [execsql $dbfd $sql m]} then { puts stderr $m ; exit 1 }

	pg_disconnect $dbfd

	return 0
}

#
# Tout démarre ici...
#

exit [main $argv0 $argv]
