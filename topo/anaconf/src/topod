#! %TCLSH%

#
#  
# Recette pour accélérer le déroulement de rancid+topo pour permettre
# la modification de conf par interface Web topo
#  
# Il faut deux spools différents :
#	- spool des détections de modification d'équipement
#	- spool des modifications (à propager, puis ensuite effectuées)
#  
# Lorsqu'une modification est effectuée sur l'interface Web :
#
#	Une entrée est générée par modification effectuée (ex: chgt
#	d'affectation d'un port dans un vlan) avec les attributs
#	suivants :
#	- login de l'utilisateur
#	- date de la requête de modification
#	- équipement (RR)
#	- interface
#	- description d'interface
#	- vlan d'accès
#	- vlan voix
#	L'entrée est une ligne dans la table topo.ifchanges de la base
#	WebDNS.
#
#	Lorsque la modification est propagée sur l'équipement, les
#	attributs suivants sont actualisés :
#	- date de modification
#	- log de la modification (sortie de la commande de modification)
#  
#  Lorsqu'une modification sur un équipement est détectée :
#  
#	La modification peut être soit une modification automatique
#	poussée à partir de l'interface Web, soit une modification
#	manuelle par un très doué ingénieur réseau.
#  
#	La détection peut-être réalisée via une trappe SNMP, via
#	l'analyse des fichiers de log ou via l'accounting Radius.
#	Dans tous les cas, une entrée est générée par modification
#	détectée, avec les attributs suivants :
#	- équipement (fqdn ou nom incomplet)
#	- login
#	- date de détection de l'événement
#	L'entrée est une ligne dans la table topo.modeq de la base
#	WebDNS.
#
#	Lorsque l'entrée est traitée, l'attribut suivant est actualisé :
#	- booléen "traité"
#  
#  Rancid est remplacé par le programme, constitué d'une boucle infinie
#  (démon), dont le corps est :
#  
#   1- une fois par nuit, faire une récupération des confs
#	(rancid original) et une analyse des confs (topo) complètes
#  
#   2- analyser le spool de modifications à effectuer, en regroupant
#	les modifications par équipement (mais en conservant la
#  	séquence des modifications)
#  
#	a- tester si l'équipement est accessible (fping)
#  	    => l'idée est de ne pas attendre le timeout TCP si
#  		l'équipement est éteint/crashé/etc
#  
#	b- propager ces modifications sur l'équipement s'il est
#  	    accessible (normalement, ces modifications entrainent
#  	    l'apparition d'une entrée dans le spool des modifications
#  	    détectées)
#  
#	c- si la propagation s'est passée sans problème, déplacer les
#  	    fichiers dans le spool des modifications effectuées.
#  
#	d- conserver la liste des équipements pour lesquels la
#  	    propagation des modifications s'est effectuée sans
#  	    problème.
#  
#   3- analyser le spool des détections de modifications
#  
#  	a- si l'équipement n'est pas dans routers.db, alors râler
#  
#  	b- si l'équipement est accessible, alors lancer rancid pour
#  	    récupérer sa configuration
#  
#	c- si la configuration d'un équipement a été modifiée/propagée
#  	    avec succès, mais que cet équipement n'apparaît pas dans
#  	    le spool des détections de modifications, alors râler
#  
#	d- lancer topo en restreignant l'analyse aux seuls équipements
#  	    modifiés
#  
#	e- supprimer les fichiers du spool des modifications effectuées
#  
#
# Historique :
#  2010/02/16 : pda/jean : création
#

set conf(fping) "%FPING% %s"

set conf(dumpgraph)	"%TOPODIR%/bin/dumpgraph < %GRAPH%"
set conf(extracteq)	{%TOPODIR%/bin/extracteq %1$s %2$s < %GRAPH%}
set conf(extractcoll)	{%TOPODIR%/bin/extractcoll -s -w < %GRAPH%}
set conf(rancid)	{%TOPODIR%/bin/start-rancid %1$s}
set conf(anaconf)	{%TOPODIR%/bin/anaconf}
set conf(logger)	%LOGGER%

set conf(delay)		%DELAY%

set conf(pkg)		%PKGTCL%
set conf(libdns)	%LIBDNS%

set conf(base)		%BASE%

set conf(maxstatus)	100

set conf(sensorexpire)	"30 days"

lappend auto_path $conf(pkg)

package require pgsql
package require webapp

source $conf(libdns)

#
# Commandes de modification à envoyer pour chaque équipement
#
# Ces quatre actions doivent être paramétrées en fonction du
# type d'équipement. Pour cela, le tableau confcmd contient
# les commandes à passer sur chaque type d'équipement.
#
# La clef est de la forme :
#   type:modele:action
# Le modèle peut être "*"
# Exemple :
#   confcmd(cisco:3750:ifaccess) ...
#   confcmd(cisco:*:ifaccess) ...
#
# La valeur est une liste de lignes à passer sur l'équipement.
# Ces lignes sont paramétrés.
#
# Les différentes actions sont :
#   
#   exec
#	commande shell a appeler pour envoyer des commandes à exécuter sur
#	l'équipement. Les autres actions sont exécutées sur l'équipement
#	lui-même.
#   prologue
#	entrer en mode configuration sur l'équipement
#   ifreset
#	remettre l'interface dans un mode connu (la plupart du temps par
#	suppression de tous les vlans sur l'interface).
#	Paramètres :
#	    %1$ : nom de l'interface
#   resetvlans
#	dans le cas où on ne peut pas remettre l'interface dans un mode
#	connu (par exemple sur HP), commande à passer pour tous les vlans
#	pour retirer l'interface de ces vlans.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : numéro de vlan
#   ifaccess
#	positionner un vlan d'accès donné sur une interface.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : numéro de vlan
#   ifvoice
#	positionner un voice vlan donné sur une interface.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : numéro de vlan
#   ifdesc
#	positionner la description sur une interface.
#	Paramètres :
#	    %1$ : nom de l'interface
#	    %2$ : description
#   epilogue
#	quitter le mode de configuration et enregistrer la configuration saisie
#
#

array set confcmd {
    cisco:*:exec {/usr/local/libexec/rancid/clogin -autoenable -u %RANCIDMODUSER% -p %RANCIDMODPASS%}

    cisco:*:prologue {
	  {configure terminal}
    }
    cisco:*:ifreset {
	  {interface %1$s}
	  {no switchport}
	  {switchport}
    }
    cisco:*:ifdisable {
	{interface %1$s}
	{shutdown}
    }
    cisco:*:ifenable {
	{interface %1$s}
	{no shutdown}
    }
    cisco:*:ifaccess {
	      {interface %1$s}
	      {switchport access vlan %2$s}
	  }
    cisco:*:ifvoice {
	      {interface %1$s}
	      {switchport voice vlan %2$s}
	  }
    cisco:*:ifdesc {
	      {interface %1$s}
	      {description %2$s}
	  }
    cisco:*:epilogue {
	      {line con 0}
	      {exit}
	      {exit}
	      {write memory}
	  }

    juniper:*:exec {/usr/local/libexec/rancid/jlogin -autoenable -u %RANCIDMODUSER% -p %RANCIDMODPASS%}

    juniper:*:prologue {
	{configure}
    }
    juniper:*:ifreset {
	{delete interfaces %1$s unit 0 family ethernet-switching}
	{delete ethernet-switching-options voip interface %1$s}
    }
    juniper:*:ifdisable {
	{set interfaces %1$s disable}
    }
    juniper:*:ifenable {
	{delete interfaces %1$s disable}
    }
    juniper:*:ifaccess {
	{set interfaces %1$s unit 0 family ethernet-switching port-mode access}
	{set interfaces %1$s unit 0 family ethernet-switching vlan members %2$s}
    }
    juniper:*:ifdesc {
	{set interfaces %1$s description "%2$s"}
    }
    juniper:*:ifvoice {
	{set ethernet-switching-options voip interface %1$s vlan %2$s}
    }
    juniper:*:epilogue {
	{commit}
	{exit configuration}
    }

    hp:*:exec {/usr/local/libexec/rancid/hlogin -autoenable -u %RANCIDMODUSER% -p %RANCIDMODPASS%}
    hp:*:prologue {
	{configure terminal}
    }
    hp:*:resetvlans {
	{vlan %2$s}
	{no tagged %1$s}
	{no untagged %1$s}
    }

    hp:*:ifenable {
	{interface %1$s}
	{enable}
    }
    hp:*:ifdisable {
	{interface %1$s}
	{disable}
    }
    hp:*:ifaccess {
	{vlan %2$s}
	{untagged %1$s}
    }
    hp:*:ifvoice {
	{vlan %2$s}
	{tagged %1$s}
    }
    hp:*:ifdesc {
	{interface %1$s}
	{name "%2$s"}
    }
    hp:*:epilogue {
	{vlan 1}
	{exit}
	{exit}
	{write memory}
    }
}


##############################################################################
# Debug
##############################################################################

proc report-enter {cmd enter} {
    puts "> $cmd"
}

proc report-leave {cmd code result leave} {
    puts "< $cmd -> $code/$result"
}


##############################################################################
# Fonctions utilitaires
##############################################################################

#
# Génère un message d'erreur dans le log
#
# Entrée : 
#   - msg : message d'erreur
# Sortie : aucune
#
# Historique
#   2010/10/20 : pda/jean : conception minimale
#

proc log-error {msg} {
    global conf

    if {[catch {open "|$conf(logger)" "w"} fd]} then {
	puts stderr "$msg (log to syslog: $fd)"
    } else {
	puts $fd $msg
	close $fd
    }
}

#
# Positionne le niveau de verbosité
#
# Entrée : 
#   - niveau : niveau de verbosité maximum à afficher
# Sortie :
#   - valeur de retour : aucune
#   - ctxt(verbose) : niveau de "verbosité" maximum à afficher
#
# Historique
#   2010/10/21 : pda/jean : conception
#

proc set-verbose {niveau} {
    global ctxt

    set ctxt(verbose) $niveau
}

#
# Affichage de debug suivant le niveau de verbosité
#
# Entrée : 
#   - msg : message d'erreur
#   - niveau : niveau de verbosité du message
#   - ctxt(verbose) : niveau de "verbosité" maximum à afficher
# Sortie : aucune
#
# Historique
#   2010/10/21 : pda/jean : conception
#

proc verbositer {msg niveau} {
    global ctxt

    if {$niveau < $ctxt(verbose)} then {
	puts stderr $msg
    }
}

#
# Actualise le statut donnant les derniers niveaux de progression
# du démon topod, afin de donner une visibilité sur les actions
# entreprises.
#
# Entrée : 
#   - status : statut actuel
# Sortie : aucune
#
# Note : le statut est dans la table keepstate, sous forme d'une
# liste {{date1 msg1} {date2 msg2} ...} où 1 est l'entrée la plus
# récente. On ne garde que les 10 dernières entrées (valeur codée
# en dur)
#
# Historique
#   2010/11/05 : pda/jean : conception
#

proc reset-status {} {
    set sql "DELETE FROM topo.keepstate WHERE type = 'status'"
    myexec $sql
}

proc set-status {status} {
    global conf

    set cur {}
    set sql "SELECT message FROM topo.keepstate WHERE type = 'status'"
    if {! [myselect $sql tab { set cur $tab(message) }]} then {
	return
    }

    # retirer l'entrée la plus vieille, s'il y a plus de maxstatus entrées
    set last [expr $conf(maxstatus)-1]
    catch {set cur [lreplace $last $last]}

    # introduire la nouvelle entrée en tête
    set date [clock format [clock seconds]]
    set cur [linsert $cur 0 [list $date $status]]

    set qcur [::pgsql::quote $cur]

    set sql "DELETE FROM topo.keepstate WHERE type = 'status' ;
		INSERT INTO topo.keepstate (type, message)
			VALUES ('status', '$qcur')"
    myexec $sql
}

##############################################################################
# Accès à la base
##############################################################################

#
# Réalise la connexion à la base de données si nécessaire.
#
# Entrée :
#   - ctxt(dbfd) : accès à la base
# Sortie :
#   - ctxt(dbfd) : accès réactualisé
#
# Historique
#   2010/10/20 : pda/jean : documentation
#

proc lazy-connect {} {
    global ctxt
    global conf

    set r 1
    if {[string equal $ctxt(dbfd) ""]} then {
	set d [catch {set ctxt(dbfd) [pg_connect -conninfo $conf(base)]} msg]
	if {$d} then {
	    set r 0
	} else {
	    ::dnsconfig setdb $ctxt(dbfd)
	    log-error "Connexion to database succeeded"
	}
    }
    return $r
}

#
# Exécute une requête SELECT et gère la reconnexion à la base
#
# Entrée : 
#   - sql : requete SQL à exécuter
#   - arrayname : tableau utilisé dans le script
#   - script : procédure ou script
# Sortie : 
#   - valeur de retour : 1 si réussi, 0 si erreur
#
# Historique
#   2010/10/20 : pda/jean : conception (woaw !)
#

proc myselect {sql arrayname script {iferror {}} {errscript {}}} {
    global ctxt

    if {[lazy-connect]} {
	set cmd [list pg_select $ctxt(dbfd) $sql $arrayname $script]
	if {[catch {uplevel 1 $cmd} err]} then {
	    log-error "Connexion to database lost in myselect ($err)"
	    catch {pg_disconnect $ctxt(dbfd)}
	    set ctxt(dbfd) ""
	    set r 0
	} else {
	    set r 1
	}
    } else {
	set r 0
    }
    return $r
}

#
# Exécute une requête de modification (INSERT, UPDATE ou DELETE)
# et gère la reconnexion à la base
#
# Entrée : 
#   - sql : requete SQL à exécuter
# Sortie : 
#   - valeur de retour : 1 si réussi, 0 si erreur
#
# Historique
#   2010/10/20 : pda/jean : conception
#

proc myexec {sql} {
    global ctxt

    if {[lazy-connect]} {
	if {[catch {pg_exec $ctxt(dbfd) $sql} res]} then {
	    log-error "Connexion to database lost in myexec ($res)"
	    catch {pg_disconnect $ctxt(dbfd)}
	    set ctxt(dbfd) ""
	    set r 0
	} else {
	    switch -- [pg_result $res -status] {
		PGRES_COMMAND_OK -
		PGRES_TUPLES_OK -
		PGRES_EMPTY_QUERY {
		    set r 1
		}
		default {
		    set err [pg_result $res -error]
		    log-error "Internal error in myexec. Connexion to database lost ($err)"
		    catch {pg_disconnect $ctxt(dbfd)}
		    set ctxt(dbfd) ""
		    set r 0
		}
	    }
	    pg_result $res -clear
	}
    } else {
	set r 0
    }
    return $r
}

#
# Exécute une requête de début de transaction
# et gère la reconnexion à la base
#
# Entrée : 
#   - aucune
# Sortie : 
#   - valeur de retour : 1 si réussi, 0 si erreur
#
# Historique
#   2010/10/21 : pda/jean : conception
#

proc mylock {} {
    return [myexec "START TRANSACTION"]
}

#
# Exécute une requête de début de transaction
# et gère la reconnexion à la base
#
# Entrée : 
#   - commit : "commit" ou "abort"
# Sortie : 
#   - valeur de retour : 1 si réussi, 0 si erreur
#
# Historique
#   2010/10/21 : pda/jean : conception
#

proc myunlock {commit} {
    switch $commit {
	commit { set sql "COMMIT WORK" }
	abort  { set sql "ABORT WORK" }
    }
    return [myexec $sql]
}


##############################################################################
# Gestion des mails
##############################################################################

#
# Envoie un mail si le message produit par un événement a changé par
# rapport au précédent événement
#
# Entrée :
#   - ev : événement considéré ("rancid", "anaconf")
#   - msg : message de l'événement
#   - ctxt(dbfd) : accès à la base
# Sortie :
#   - aucune
#
# Historique
#   2010/10/21 : pda/jean : conception
#

proc keep-state-mail {ev msg} {
    #
    # Récupérer l'ancien message
    #

    set oldmsg ""
    set qev [::pgsql::quote $ev]
    set sql "SELECT message FROM topo.keepstate WHERE type = '$qev'"
    if {! [myselect $sql tab { set oldmsg $tab(message) }]} then {
	# on ne sait pas quoi faire...
	return
    }

    if {! [string equal $msg $oldmsg]} then {
	#
	# Le nouveau message est différent de l'ancien. Il faut l'envoyer
	# par mail et l'enregistrer dans le keepstate.
	#
	# Parti pris : si l'accès à la base est HS et qu'on ne peut
	# donc pas avoir accès au keepstate de l'événement, on
	# n'envoie plus de mail. Le risque est de ne pas avoir
	# connaissance par mail des événements lorsque la base est
	# HS, mais le gain est ne pas avoir un nouveau mail identique
	# toutes les X secondes... D'un autre côté, on ne risque rien
	# puisqu'il n'y aura pas de changement détecté ou traité tant
	# que la base est HS.
	#

	set qmsg [::pgsql::quote $msg]
	set sql "DELETE FROM topo.keepstate WHERE type = '$qev' ;
		    INSERT INTO topo.keepstate (type, message)
			    VALUES ('$qev', '$qmsg')"
	if {[myexec $sql]} then {
	    #
	    # Si on arrive ici, c'est que la base est vivante.
	    # Envoyer le mail.
	    #

	    set from    [::dnsconfig get "topofrom"]
	    set to	[::dnsconfig get "topoto"]
	    set replyto	""
	    set cc	""
	    set bcc	""
	    set subject	"\[auto\] topod status changed for $ev"
	    ::webapp::mail $from $replyto $to $cc $bcc $subject $msg
	}
    }
}


##############################################################################
# Mise à jour du graphe
##############################################################################

#
# Détermine si un passage complet de rancid est nécessaire
#
# Entrée : aucune
# Sortie : 
#   - valeur de retour :
#	-1 : erreur
#	0 : pas de passage nécessaire
#	1 : passage nécessaire
#
# Historique : 
#   2010/10/15 : pda/jean : création
#

proc full-rancid-needed {} {
    set sql "SELECT topo.lastrun.date IS NULL
		    OR (
			(date_trunc('day',topo.lastrun.date)
			    <> date_trunc('day',now())
			AND extract(hour from now())>=2
			AND extract(hour from now())<=4)
		    )
	       AS result
	       FROM topo.lastrun"

    # by default, this is an error
    set r -1

    # if selects succeeds, returns the result of SQL query,
    # while translating it to 1 (true) or 0 (false)
    # There is no need to test the return value of next command
    myselect $sql tab { set r [expr $tab(result) ? 1 : 0]}

    return $r
}

#
# Mise à jour du graphe topo à partir des configuration des équipements
#
# Entrée :
#   - _tabeq : tableau contenant en retour les types/modèles des équipements
#   - leq : liste des équipements (optionnel)
# Sortie :
#   - valeur de retour : 1 si ok, 0 en cas d'erreur
#
# Historique : 
#   2010/10/15 : pda/jean : conception
#   2010/10/20 : pda/jean : codage
#

proc update-graph {_tabeq {leq {}}} {
    upvar $_tabeq tabeq
    global conf

    #
    # Remettre à zéro les équipements marqués comme modifiés
    # dans le spool
    #

    if {! [mylock]} then {
	return 0
    }

    if {[llength $leq] == 0} then {
	set sql "UPDATE topo.modeq SET processed = 1"
    } else {
	set inlist [join $leq "', '"]
	set sql "UPDATE topo.modeq SET processed = 1 WHERE eq IN ('$inlist')"
    }
    if {! [myexec $sql]} then {
	return 0
    }

    #
    # Lancer rancid et envoyer un mail si nécessaire
    #

    if {! [rancid $leq]} then {
	myunlock "abort"
	return 0
    }

    #
    # Mettre à jour le graphe et envoyer un mail si nécessaire
    #

    if {! [anaconf $leq]} then {
	myunlock "abort"
	return 0
    }

    #
    # Mettre à jour la liste des points de collecte
    #

    if {! [sensors]} then {
	myunlock "abort"
	return 0
    }

    #
    # Mettre à jour la date du dernier passage complet
    # (si c'est un passage complet bien sûr)
    #

    if {[llength $leq] == 0} then {
	set sql "DELETE FROM topo.lastrun ;
		    INSERT INTO topo.lastrun (date) VALUES (NOW ())"
	if {! [myexec $sql]} then {
	    return 0
	}
    }
    myunlock "commit"

    #
    # Relire les équipements et leur type/modèle
    #

    set msg [read-eq-type tabeq]
    if {! [string equal $msg ""]} then {
	keep-state-mail "read-eq-type" "Cannot read equipment types ($msg)"
	return 0
    }

    return 1
}

#
# Appelle rancid
#
# Entrée :
#   - leq : liste d'équipements modifiés, à interroger (optionnel)
# Sortie : 
#   - valeur de retour : 1 si ok, 0 si erreur
#
# Historique : 
#   2010/10/20 : pda/jean : création
#

proc rancid {{leq {}}} {
    global conf

    if {[llength $leq] == 0} then {
	set-status "Ranciding all equipements"
    } else {
	set-status "Ranciding $leq"
    }

    #
    # Appeler rancid
    #

    set cmd [format $conf(rancid) $leq]
    verbositer "rancid : cmd=<$cmd>" 2

    if {[catch {exec sh -c $cmd} msg]} then {
	# erreur
	set msg "Erreur dans l'exécution de $cmd\n$msg"
	set r 0
    } else {
	# pas d'erreur
	set r 1
    }

    #
    # Envoyer le mail si nécessaire
    #

    if {[llength $leq] == 0} then {
	set ev "fullrancid"
    } else {
	set ev "rancid"
    }

    keep-state-mail $ev $msg

    return $r
}

#
# Appelle anaconf pour reconstruire le graphe
#
# Entrée :
#   - leq : liste d'équipements modifiés (optionnel)
# Sortie : 
#   - valeur de retour : 1 si ok, 0 si erreur
#
# Historique : 
#   2010/10/20 : pda/jean : création
#

proc anaconf {{leq {}}} {
    global conf

    if {[llength $leq] == 0} then {
	set-status "Rebuild graph for all equipements"
    } else {
	set-status "Rebuild graph for $leq"
    }

    set text ""

    set cmd $conf(anaconf)

    set r 1
    foreach eq $leq {
	append cmd " $eq"
    }

    verbositer "anaconf : cmd=<$cmd>" 2
    if {[catch {exec sh -c $cmd} msg]} then {
	# erreur
	set msg "Erreur dans l'exécution de $cmd\n$msg"
	set r 0
    } else {
	# pas d'erreur
    }
    set text $msg

    #
    # Envoyer le mail si nécessaire
    #

    keep-state-mail "anaconf" $msg

    return $r
}

#
# Lit les points de collecte et les met à jour dans la base
#
# Entrée : aucune
# Sortie : 
#   - valeur de retour : 1 si ok, 0 si erreur
#
# Historique : 
#   2010/11/09 : pda/jean : création
#

proc sensors {} {
    global conf

    set-status "Updating sensor list"

    #
    # Lecture des points de collecte existants dans la base
    #

    set sql "SELECT * FROM topo.sensor"
    set r [myselect $sql tab {
				set id $tab(id)
				set told($id) [list $tab(type) $tab(eq) \
					$tab(comm) $tab(param1) $tab(param2)]
			    } ]
    if {! $r} then {
	keep-state-mail "sensors" "Cannot read sensor list from database"
	return 0
    }

    #
    # Lecture des nouveaux points de collecte à partir du graphe
    #

    set msg [read-coll tnew]
    if {$msg ne ""} then {
	keep-state-mail "sensors" "Cannot read sensor list from graph\n$msg"
	return 0
    }

    #
    # Analyse des différences
    #

    set lunmod {}
    set sql {}

    foreach id [array names tnew] {
	lassign $tnew($id) type eq comm param1 param2
	set qid [::pgsql::quote $id]
	set qeq [::pgsql::quote $eq]
	set qcomm [::pgsql::quote $comm]
	set qparam1 [::pgsql::quote $param1]
	set qparam2 [::pgsql::quote $param2]

	if {[info exists told($id)]} then {
	    #
	    # Mise à jour des sondes communes
	    #

	    if {$tnew($id) eq $told($id)} then {
		#
		# identique : on ne fait qu'actualiser la date de dernière
		# lecture
		#
		lappend lunmod "'$qid'"
	    } else {
		#
		# différente : on met à jour (y compris les dates)
		#
		lappend sql "UPDATE topo.sensor
				    SET type = $type,
					eq = '$qeq',
					comm = '$qcomm',
					param1 = '$qparam1',
					param2 = '$qparam2',
					lastmod = DEFAULT,
					lastseen = DEFAULT
				    WHERE id = '$qid'"
	    }

	    unset told($id)
	} else {
	    #
	    # Nouvelle sonde
	    #
	    lappend sql \
		"INSERT INTO topo.sensor (id, type, eq, comm, param1, param2)
		    VALUES ('$qid',$type,'$qeq','$qcomm','$qparam1','$qparam2')"
	}
    }

    #
    # Mise à jour de la date des sondes vues, mais non modifiées
    #

    if {[llength $lunmod] > 0} then {
	set l [join $lunmod ","]
	lappend sql "UPDATE topo.sensor SET lastseen = DEFAULT WHERE id IN ($l)"
    }

    #
    # Suppression des anciennes sondes au bout d'un certain délai
    #

    lappend sql "DELETE FROM topo.sensor
			WHERE lastseen + interval '$conf(sensorexpire)' < now()"

    #
    # Passer la groooooooosse commande SQL
    # 

    if {[llength $sql] > 0} then {
	set sql [join $sql ";"]
	if {! [myexec $sql]} then {
	    keep-state-mail "sensors" "Cannot write sensors in database"
	    return 0
	}
    }

    #
    # Envoyer le mail si nécessaire
    #

    keep-state-mail "sensors" ""

    return 1
}

#
# Lit les lignes issues de "extractcoll -s -w" et en extrait la liste
# des sondes à métrologiser.
#
# Entrée :
#   - _tab : tableau contenant en sortie les informations
# Sortie :
#   - valeur de retour : message d'erreur ou chaîne vide
#   - paramètre tab : tableau, indexé par les noms de points de métrologie,
#	contenant pour chaque case une liste de la forme :
#	{<type> <eq> <communaute> [<param1> [<param2>]]}
#
# Note :
#   Le format attendu en entrée est composé de trois types de ligne :
#	trafic      <id coll> <eq> <community> <phys iface> <vlan|->
#	nbassocwifi <id coll> <eq> <community> <phys iface> <ssid>
#	nbauthwifi  <id coll> <eq> <community> <phys iface> <ssid>
#
# Historique :
#   2008/07/28 : pda/boggia : conception
#   2008/07/30 : pda        : adaptation au nouveau format d'entrée
#   2010/11/09 : pda/jean   : intégration dans topod
#

proc read-coll {_tab} {
    global conf
    upvar $_tab tab

    set cmd $conf(extractcoll)
    if {! [catch {set fd [open "|$cmd" "r"]} msg]} then {
	set msg ""

	set r ""
	while {[gets $fd ligne] >= 0} {
	    set l [split $ligne]

	    set kw [lindex $l 0]
	    switch $kw {
		trafic {
		    set id    [lindex $l 1]
		    set eq    [lindex $l 2]
		    set comm  [lindex $l 3]
		    set iface [lindex $l 4]
		    set vlan  [lindex $l 5]
		    set type  1

		    if {! [string equal $vlan "-"]} then {
			set iface "$iface.$vlan"
		    }

		    set sonde [list $type $eq $comm $iface {}]
		}
		nbassocwifi -
		nbauthwifi {
		    set id    [lindex $l 1]
		    set eq    [lindex $l 2]
		    set comm  [lindex $l 3]
		    set iface [lindex $l 4]
		    set ssid  [lindex $l 5]
		    if {$kw eq "nbassocwifi"} then {
			set type 2
		    } else {
			set type 3
		    }

		    set sonde [list $type $eq $comm $iface $ssid]
		}
		default {
		    return "Type de sonde inconnu ($l)"
		}
	    }

	    if {[info exists tab($id)]} then {
		return "Sonde '$id' présente plusieurs fois"
	    }
	    set tab($id) $sonde
	}
	close $fd
    }

    return $msg
}


#
# Recherche le type et le modèle des équipements connus dans le graphe
#
# Entrée :
#   - _tabeq : nom du tableau contenant en retour les types
# Sortie :
#   - valeur de retour : message d'erreur ou chaîne vide si ok
#   - tabeq : tableau, indexé par nom complet de l'équipement, contenant
#	tabeq(<eq>) {<type> <model>}
# 
# Historique : 
#   2010/02/25 : pda/jean : création
#   2010/10/21 : pda/jean : modification pour ne gérer que des noms complets
#

proc read-eq-type {_tabeq} {
    global conf
    upvar $_tabeq tabeq

    set-status "Reading equipement types"

    set msg ""

    set cmd $conf(dumpgraph)
    if {! [catch {set fd [open "|$cmd" "r"]} msg]} then {
	set msg ""
	while {[gets $fd ligne] > -1} {
	    switch [lindex $ligne 0] {
		eq {
		    array set t $ligne
		    set eq $t(eq)
		    set type $t(type)
		    set model $t(model)

		    #### BEQUILLE
		    append eq ".u-strasbg.fr"

		    set tabeq($eq) [list $type $model]

		    array unset t
		}
	    }
	}
	close $fd
    }

    return $msg
}


##############################################################################
# Propagation des modifications sur les équipements
##############################################################################

#
# Propage les modifications demandées (dans le spool) vers les
# équipements
#
# Entrée :
#   - _tabeq : nom du tableau contenant les types d'équipements
# Sortie :
#   - valeur de retour : 1 si ok, 0 si erreur
# 
# Historique : 
#   2010/10/14 : pda/jean : création
#

proc send-changes {_tabeq} {
    upvar $_tabeq tabeq

    #
    # Trouver les équipements modifiés
    # et constituer une liste de couples {{idrr fqdn} ...}
    #

    set lc {}
    set sql "SELECT DISTINCT (c.idrr) AS idrr,
			rr.nom || '.' || d.nom AS fqdn
		    FROM topo.ifchanges c, dns.rr, dns.domaine d
		    WHERE c.processed = 0
			AND c.idrr = rr.idrr
			AND rr.iddom = d.iddom"
    if {! [myselect $sql tab { lappend lc [list $tab(idrr) $tab(fqdn)] }]} then {
	return 0
    }

    foreach c $lc {
	lassign $c idrr eq

	#
	# Rechercher le type et le modèle de l'équipement à partir
	# du fqdn
	#

	if {! [info exists tabeq($eq)]} then {
	    update-modlog $idrr "Unknown equipement type for '$eq'"
	    continue
	}
	lassign $tabeq($eq) type model

	#
	# Test d'accessibilité
	#

	set msg [test-ping $eq]
	if {! [string equal $msg ""]} then {
	    update-modlog $idrr $msg
	    continue
	}

	#
	# L'équipement est accessible.
	# Récupérer toutes les modifications non traitées pour
	# cet équipement, les traduire en lignes de configuration,
	# les envoyer sur l'équipement, et marquer les modifications
	# comme étant traitées
	#

	set lcmd [mod-to-conf $idrr $eq $type $model lreqdate]
	if {[llength $lcmd] == 0} then {
	    continue
	}

	if {[execute-cmd $eq $type $model $lcmd msg]} then {
	    mark-processed $idrr $lreqdate $msg
	} else {
	    update-modlog $idrr $msg
	}
    }

    return 1
}

#
# Traduit les changements demandés dans le spool en une suite
# de lignes pour l'équipement donné
#
# Entrée :
#   - idrr : id de l'équipement
#   - eq : nom complet (fqdn) de l'équipement
#   - type : type d'équipement (ex: cisco, juniper etc.)
#   - model : modèle d'équipement (ex: 3750, M20 etc.)
#   - lreqdate : en retour, liste des demandes trouvées (i.e. les dates)
# Sortie :
#   - valeur de retour : liste des lignes de commandes à passer sur l'équipement
#		ou liste vide en cas d'erreur
#   - paramètre lreqdate : cf ci-dessus
# 
# Historique : 
#   2010/10/14 : pda/jean : création
#

proc mod-to-conf {idrr eq type model _lreqdate} {
    upvar $_lreqdate lreqdate

    set lreqdate {}
    set lcmd {}

    #
    # prologue
    #

    set prologue [fetch-conf $type $model "prologue"]
    set lcmd [concat $lcmd $prologue]

    #
    # Chercher toutes les modifications
    #

    set sql "SELECT c.*
		FROM topo.ifchanges c
		WHERE c.idrr = $idrr AND c.processed = 0
		ORDER BY c.reqdate ASC"

    set l {}
    if {! [myselect $sql tab { lappend l [list $tab(reqdate) $tab(iface) \
			$tab(ifdesc) $tab(ethervlan) $tab(voicevlan)] }]} then {
	return {}
    }

    foreach e $l {
	lassign $e reqdate iface ifdesc ethervlan voicevlan

	lappend lreqdate $reqdate

	#
	# Description de l'interface
	#

	if {! [string equal $ifdesc ""]} then {
	    foreach fmt [fetch-conf $type $model "ifdesc"] {
		lappend lcmd [format $fmt $iface $ifdesc]
	    }
	}

	#
	# On remet l'interface dans un état connu dans tous les cas
	#

	set lcmd [concat $lcmd [resetif $eq $type $model $iface]]

	# 
	# En fonction de ce qui se trouve dans le fichier spool, on 
	# execute des commandes sur l'équipement. 
	# 
	#   Ether	    Voice	Opération
	#   -----------------------------------------------------
	#   Non		    Non		Désactiver l'interface
	#   Non		    Oui		Voice vlan uniquement
	#   Oui		    Non		Vlan d'accès uniquement
	#   Oui		    Oui		Vlan d'accès + Voice Vlan
	#

	set ether [expr ![string equal $ethervlan ""]]
	set voice [expr ![string equal $voicevlan ""]]
	
	switch -- "$ether$voice" {
	    00	{
		# Rien
	    }
	    01	{
		foreach fmt [fetch-conf $type $model "ifvoice"] {
		    lappend lcmd [format $fmt $iface $voicevlan]
		}
	    }
	    10	{
		foreach fmt [fetch-conf $type $model "ifaccess"] {
		    lappend lcmd [format $fmt $iface $ethervlan]
		}
	    }
	    11  {
		foreach fmt [fetch-conf $type $model "ifvoice"] {
		    lappend lcmd [format $fmt $iface $voicevlan]
		}
		foreach fmt [fetch-conf $type $model "ifaccess"] {
		    lappend lcmd [format $fmt $iface $ethervlan]
		}
	    }
	}
    }

    #
    # Épilogue
    #

    set epilogue [fetch-conf $type $model "epilogue"]
    set lcmd [concat $lcmd $epilogue]

    return $lcmd
}

#
# Exécute une séquence de commandes sur un équipement
#
# Entrée :
#   - fqdn : nom complet de l'équipement
#   - type : type d'équipement (ex: cisco, juniper etc.)
#   - model : modèle d'équipement (ex: 3750, M20 etc.)
#   - lcmd : liste des commandes à exécuter
#   - _msg : en retour, message d'erreur ou sortie de la commande
# Sortie
#   - valeur de retour : 1 si ok, 0 si erreur
#
# Historique : 
#   2010/02/18 : pda/jean : création
#

proc execute-cmd {fqdn type model lcmd _msg} {
    global conf
    upvar $_msg msg

    set-status "Sending command to $fqdn"

    set tmp "/tmp/topod.[pid]"
    set fd [open $tmp "w"]
    puts $fd [join $lcmd "\n"]
    close $fd
    
    set exec [fetch-conf $type $model "exec"]

    if {[catch {exec sh -c "$exec -x $tmp $fqdn"} msg]} then {
	set r 0
    } else {
	set r 1
    }

    file delete -force $tmp

    #
    # Interpréter le fichier résultant de l'exécution
    #
    # Pistes :
    # 1- analyser le fichier en supprimant toutes les lignes connues
    #	(ex: "cisco(Fa1/0)# switchport blablabla" -> supprimer)
    #	ce qui reste est une erreur
    #	-> pb : stratégie peu maintenable dans le temps
    # 2- chercher des patterns d'erreur
    #	-> pb : le nombre d'erreurs non connues est non dénombrable
    # 3- ignorer le résultat de l'exécution, et détecter les modifications
    #	non prises en compte dans le graphe reconstruit après
    #	-> pb : délai entre la modif et la vérification
    #	-> pb : complexité du code de vérification
    # 4- ignorer le résultat de l'exécution, et laisser l'être humain
    #	détecter les problèmes (par ex: affichage de l'erreur dans une
    #	page web de diagnostic, ou la page web de l'équipement)
    #	-> pb : codage dans l'appli web
    #
    # On privilégie la piste 4 pour le moment. L'expérience nous dira
    # si c'est une bonne idée ou non.
    #

    return $r
}

#
# Renvoie la commande associée à un type d'équipement
# et un type de configuration
#
# Entrée :
#   - type : type d'équipement (ex: cisco, juniper etc.)
#   - model : modèle d'équipement (ex: 3750, M20 etc.)
#   - context : voir description du tableau confcmd
# Sortie
#   - valeur de retour : commande à exécuter ou liste vide si non trouvé
#
# Historique : 
#   2010/02/16 : pda/jean : création
#

proc fetch-conf {type model context} {
    global confcmd
    
    set r {}
    if {[info exists confcmd($type:*:$context)]} then {
	set r $confcmd($type:*:$context)
    } elseif {[info exists confcmd($type:$model:$context)]} then {
	set r $confcmd($type:$model:$context)
    }

    return $r
}


#
# Génère une liste de commande pour remettre une interface
# dans un état connu et l'activer
#
# Entrée :
#   - eq : nom de l'équipement
#   - type : type d'équipement (ex: cisco, juniper etc.)
#   - model : modèle d'équipement (ex: 3750, M20 etc.)
#   - iface : nom de l'interface
# Sortie :
#   - valeur de retour : liste des commandes à passer sur l'équipement
#
# Historique : 
#   2010/09/23 : pda/jean : création
#

proc resetif {eq type model iface} {

    #
    # Cherche la sequence de commande pour remettre l'interface
    # dans un mode connu
    #

    set lcmd {}
    foreach fmt [fetch-conf $type $model "ifreset"] {
	lappend lcmd [format $fmt $iface]
    }

    set l2 [fetch-conf $type $model "resetvlans"]
    if {[llength $l2]>0} then {
	foreach vlan [get-vlans $eq $iface] {
	    foreach fmt $l2 {
		lappend lcmd [format $fmt $iface $vlan]
	    }
	}
    }

    #
    # Active l'interface
    #

    foreach fmt [fetch-conf $type $model "ifenable"] {
	lappend lcmd [format $fmt $iface]
    }
    
    return $lcmd
}

#
# Liste les vlans pour un équipement et une interface donnée
#
# Entrée :
#   - eq : nom complet de l'équipement
#   - iface : nom de l'interface
# Sortie
#   - valeur de retour : liste des vlans trouvés
#
# Historique : 
#   2010/09/23 : pda/jean : création
#

proc get-vlans {eq iface} {
    global conf

    set lvlans {}

    # BEQUILLE supprimer le nom de domaine pour ne garder que le nom court
    regsub {\..*} $eq "" eqcourt

    set cmd [format $conf(extracteq) $eqcourt $iface]
    if {! [catch {set fd [open "|$cmd" "r"]} msg]} then {
	while {[gets $fd ligne] > -1} {
	    foreach vlan [lreplace $ligne 0 7] {
		lappend lvlans [lindex $vlan 0]
	    }
	}
	close $fd
    } else {
	puts stderr "extracteq : $msg"
    }

    return $lvlans
}

#
# Teste l'accessibilité d'un équipement
#
# Entrée :
#   - eq : nom complet de l'équipement
# Sortie :
#   - valeur de retour : vide si ok, ou message d'erreur si pas accessible
#
# Historique
#   2010/10/14 : pda/jean : fonction séparée
#

proc test-ping {eq} {
    global conf

    # 
    # Teste si l'équipement est joignable
    # 

    set cmd [format $conf(fping) $eq]

    if {[catch {exec sh -c $cmd} msg]} then {
	set r $msg
    } else {
	set r ""
    }

    return $r
}

#
# Conserve une trace de l'échec d'une tentative de configuration
# d'un équipement
#
# Entrée :
#   - idrr : id de l'équipement
#   - msg : message d'erreur suite à la tentative
#   - ctxt(dbfd) : accès à la base
# Sortie :
#   - aucune
# 
# Historique : 
#   2010/10/14 : pda/jean : création
#

proc update-modlog {idrr msg} {
    global ctxt

    set qmsg [::pgsql::quote $msg]
    set sql "UPDATE topo.ifchanges
		    SET modlog = '$qmsg', moddate = now ()
		    WHERE idrr = $idrr AND processed = 0"
    if {! [myexec $sql]} then {
	log-error "Cannot update modlog for idrr=$idrr"
    }

    return
}

#
# Marquer les changements comme étant traités, en y inscrivant 
# le log des lignes envoyées à l'équipement
#
# Entrée :
#   - idrr : id de l'équipement
#   - lreqdate : liste des dates des changements
#   - msg : message de log
#   - ctxt(dbfd) : accès à la base
# Sortie :
#   - aucune
# 
# Historique : 
#   2010/10/14 : pda/jean : création
#

proc mark-processed {idrr lreqdate msg} {
    global ctxt

    set reqdate [join $lreqdate "', '"]

    set qmsg [::pgsql::quote $msg]
    set sql "UPDATE topo.ifchanges
		    SET processed = 1, modlog = '$qmsg', moddate = now ()
		    WHERE idrr = $idrr AND reqdate IN ('$reqdate')"
    if {! [$myexec $sql]} then {
	log-error "Cannot update 'processed' flag for idrr=$idrr"
    }
}

##############################################################################
# Détection des modifications effectuées sur les équipements
##############################################################################

#
# Détecter les modifications effectuées sur les équipements afin de
# provoquer la reconstruction partielle du graphe.
#
# Entrée :
#   - tabeq : tableau des types d'équipements, indexé par fqdn d'équipement
# Sortie :
#   - valeur de retour : liste d'équipements modifiés, ou liste vide
# 
# Historique : 
#   2010/10/21 : pda/jean : création
#

proc detect-mod {_tabeq} {
    upvar $_tabeq tabeq

    set l {}
    set sql "SELECT DISTINCT(eq) AS eq FROM topo.modeq WHERE processed = 0"
    if {! [myselect $sql tab { lappend l $tab(eq) }]} then {
	return {}
    }

    #
    # Vérifier que l'équipement est bien un équipement géré par notre
    # rancid.
    # Note : selon les types d'équipements, les versions de syslogd,
    # et les configurations de ces équipements, les noms récupérés
    # peuvent être des noms courts. Dans ces cas, on considère que
    # l'équipement n'est pas géré (c'est sans doute une erreur dans
    # le script de détection des équipements modifiés).
    #

    set leq {}
    set lunk {}
    foreach eq $l {
	if {[info exists tabeq($eq)]} then {
	    lappend leq $eq
	} else {
	    lappend lunk $eq
	}
    }

    if {[llength $lunk] > 0} then {
	keep-state-mail "detectunknw" \
			"Change detected on unknown equipments ($lunk)"
    }

    return $leq
}

##############################################################################
# Programme principal
##############################################################################

set usage {usage: %1$s [-h][-v <n>]
    -h         : affiche ce texte
    -v <n>     : niveau de verbosité (0 = aucun, 1 = minimum, 99 = max)
}

proc usage {argv0} {
    global usage

    puts stderr [format $usage $argv0]
}

#
# Programme principal
#

proc main {argv0 argv} {
    global conf
    global ctxt

    set ctxt(dbfd) ""
    set verbose 0

    config ::dnsconfig

    set delay [expr $conf(delay)*1000]

    #
    # Analyse des arguments
    #

    while {[llength $argv] > 0} {
	switch -glob -- [lindex $argv 0] {
	    -h {
		usage $argv0
		return 0
	    }
	    -v {
		set verbose [lindex $argv 1]
		set argv [lreplace $argv 0 1]

	    }
	    -* {
		usage $argv0
		return 1
	    }
	    default {
		break
	    }
	}
    }

    if {[llength $argv] != 0} then {
	usage $argv0
	return 1
    }

    reset-status
    set-status "Starting"

    #
    # Valeurs par défaut
    #

    set-verbose $verbose

    if {$verbose > 0} then {
	foreach c {
			myselect myexec mylock myunlock
			keep-state-mail
			full-rancid-needed update-graph
			rancid anaconf read-eq-type send-changes mod-to-conf
			execute-cmd fetch-conf resetif get-vlans test-ping
			update-modlog mark-processed detect-mod
		} {
	    trace add execution $c enter report-enter
	    trace add execution $c leave report-leave
	}
    }

    #
    # Initialiser la liste des équipements (qui sera réactualisée à chaque
    # mise à jour du graphe)
    #

    set msg [read-eq-type tabeq]
    if {! [string equal $msg ""]} then {
	#
	# C'est une erreur fatale qui empêche le démon de démarrer.
	#

	puts stderr "Cannot read equipment types. Abort. ($msg)"
	exit 1
    }

    #
    # Boucle principale du démon
    #

    set first 1

    while {true} {
	#
	# Gestion de l'attente : avant chaque tour de boucle, sauf
	# la première fois, attendre le délai demandé.
	#

	verbositer "delay : first=$first delay=$delay" 10
	if {! $first} then {
	    after $delay
	}
	set first 0

	#
	# Détecter s'il faut faire un passage complet sur toutes
	# les conf (i.e. si on n'a pas encore fait de lecture complète
	# depuis cette nuit à 2h du matin par ex).
	#
    
	switch [full-rancid-needed] {
	    -1 {
		# error
		continue
	    }
	    0 {
		# not needed
		# rien à faire
	    }
	    1 {
		# il faut mettre à jour le graphe complet
		# et (re-)lire la liste des types d'équipements
		if {! [update-graph tabeq]} then {
		    continue
		}
	    }
	}

	#
	# Chercher les modifications demandées par l'interface Web
	# et les propager
	#

	send-changes tabeq

	#
	# Chercher les modifications des équipements et reconstituer
	# le graphe
	#

	set leq [detect-mod tabeq]
	if {[llength $leq] > 0} then {
	    update-graph tabeq $leq
	}
    }

    return 0
}

exit [main $argv0 $argv]
