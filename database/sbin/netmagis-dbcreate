#!/bin/sh

#
# Netmagis database creation
#
# Syntax :
#	netmagis-dbcreate [-d database][-u user][-w password]
# (no argument)
#
# History
#   2002/02/11 : pda        : design
#   2002/02/12 : pda/jean   : adapt to new data model
#   2002/04/19 : pda/jean   : unique constraint on nom+domain
#   2002/04/19 : pda        : unique constraint on domain name
#   2002/04/23 : pda        : add priority in domain permissions
#   2002/04/23 : pda/jean   : add zone generation management
#   2002/05/02 : pda/jean   : use PG objects for zone tables
#   2002/05/06 : pda        : id for zone table
#   2002/05/21 : pda        : add communaute table
#   2004/01/22 : pda        : use new data model
#   2005/04/08 : pda        : use new data model (v 1.3)
#   2007/11/27 : pda/jean   : pgsql 8.2
#   2007/11/27 : pda/jean   : add log table
#   2011/01/21 : pda        : i18n
#   2011/01/21 : pda        : use new config file
#

usage ()
{
    (
	echo "usage: $0 [-d database][-u user][-w password]"
	echo "	-d: database (default: 'dnsdbname' parameter)"
	echo "	-u: user who owns the database (default: first 'rootusers')"
	echo "	-w: password (default: ask in each PostgreSQL command)"
    ) >&2
    exit 1
}

##############################################################################
# Configuration file read
##############################################################################

init-env ()
{
    varlist="dnsdbhost dnsdbport dnsdbname dnsdbuser rootusers"
    eval `%CONFPROG% -c $varlist`

    if [ $? != 0 ]
    then
	usage
	exit 1
    fi

    PGHOST="$dnsdbhost"
    PGPORT="$dnsdbport"
    PGDATABASE="$dnsdbname"
    export PGHOST PGPORT PGDATABASE
}

##############################################################################
# Database creation
##############################################################################

db-exists ()
{
    if psql -c "" 2> /dev/null
    then r=0
    else r=1
    fi
    return $r
}

db-create ()
{
    createdb -E unicode || exit 1
    createlang pltcl
}

db-fill ()
{
    psql --quiet <<'EOF'

    -- domains

    CREATE SEQUENCE seq_domaine START 1 ;
    CREATE TABLE domaine (
	iddom		INT		-- domain id
		DEFAULT NEXTVAL ('seq_domaine'),
	nom		TEXT,		-- domain name (ex: "mycompany.com")

	UNIQUE (nom),
	PRIMARY KEY (iddom)
    ) ;

    -- users and groups

    CREATE SEQUENCE seq_groupe START 1 ;
    CREATE TABLE groupe (
	idgrp		INT		-- group id
		DEFAULT NEXTVAL ('seq_groupe'),
	nom		TEXT,		-- group name
	admin		INT DEFAULT 0,	-- 1 if root, 0 if normal user
	droitsmtp	INT DEFAULT 0,	-- 1 if right to manage SMTP senders
	droitttl	INT DEFAULT 0,	-- 1 if right to edit TTL for a host

	UNIQUE (nom),
	PRIMARY KEY (idgrp)
    ) ;

    CREATE SEQUENCE seq_corresp START 1 ;
    CREATE TABLE corresp (
	idcor		INT		-- user id
		DEFAULT NEXTVAL ('seq_corresp'),
	login		TEXT,		-- user name
	present		INT,		-- 1 if present, 0 if no longer here
	idgrp		INT,		-- group

	UNIQUE (login),
	FOREIGN KEY (idgrp) REFERENCES groupe (idgrp),
	PRIMARY KEY (idcor)
    ) ;

    -- network, communities and organization descriptions

    CREATE SEQUENCE seq_etablissement START 1 ;
    CREATE TABLE etablissement (
	idetabl		INT		-- organization id
		DEFAULT NEXTVAL ('seq_etablissement'),
	nom		TEXT,		-- "My Company"

	PRIMARY KEY (idetabl)
    ) ;

    CREATE SEQUENCE seq_communaute START 1 ;
    CREATE TABLE communaute (
	idcommu		INT		-- community id
		DEFAULT NEXTVAL ('seq_communaute'),
	nom		TEXT,		-- "Administration"

	PRIMARY KEY (idcommu)
    ) ;

    CREATE SEQUENCE seq_reseau START 1 ;
    CREATE TABLE reseau (
	idreseau	INT		-- network id
		DEFAULT NEXTVAL ('seq_reseau'),
	nom		TEXT,		-- name (ex: "Servers")
	localisation	TEXT,		-- location if any
	adr4		CIDR,		-- IPv4 address range
	adr6		CIDR,		-- IPv6 address range
	idetabl		INT,		-- organization this network belongs to
	idcommu		INT,		-- administration, R&D, etc.
	commentaire	TEXT,		-- comment
	dhcp		INT DEFAULT 0,	-- activete DHCP (1) or no (0)
	gw4		INET,		-- default network IPv4 gateway
	gw6		INET,		-- default network IPv6 gateway

	CONSTRAINT au_moins_un_prefixe_v4_ou_v6
	    CHECK (adr4 IS NOT NULL OR adr6 IS NOT NULL),
	CONSTRAINT gw4_in_net CHECK (gw4 <<= adr4),
	CONSTRAINT gw6_in_net CHECK (gw6 <<= adr6),
	CONSTRAINT dhcp_needs_ipv4_gateway
	    CHECK (dhcp = 0 OR (dhcp != 0 AND gw4 IS NOT NULL)),
	FOREIGN KEY (idetabl) REFERENCES etablissement (idetabl),
	FOREIGN KEY (idcommu) REFERENCES communaute    (idcommu),
	PRIMARY KEY (idreseau)
    ) ;


    -- host types

    CREATE SEQUENCE seq_hinfo MINVALUE 0 START 0 ;
    CREATE TABLE hinfo (
	idhinfo		INT		-- host type id
		DEFAULT NEXTVAL ('seq_hinfo'),
	texte		TEXT,		-- type as text
	tri		INT,		-- sort class
	present		INT,		-- present or not
	PRIMARY KEY (idhinfo)
    ) ;

    -- ranges allowed to groups

    CREATE TABLE dr_reseau (
	idgrp		INT,		-- the group which manages this network
	idreseau	INT,		-- the network
	tri		INT,		-- sort class
	dhcp		INT DEFAULT 0,	-- perm to manage DHCP ranges
	acl		INT DEFAULT 0,	-- perm to manage ACL (later...)

	FOREIGN KEY (idgrp)    REFERENCES groupe (idgrp),
	FOREIGN KEY (idreseau) REFERENCES reseau (idreseau),
	PRIMARY KEY (idgrp, idreseau)
    ) ;

    -- domains allowed to groups

    CREATE TABLE dr_dom (
	idgrp		INT,		-- group
	iddom		INT,		-- domain id
	tri		INT,		-- sort class
	rolemail	INT DEFAULT 0,	-- perm to manage mail roles
	roleweb		INT DEFAULT 0,	-- perm to manage web roles (later...)

	FOREIGN KEY (idgrp) REFERENCES groupe (idgrp),
	PRIMARY KEY (idgrp, iddom)
    ) ;

    CREATE TABLE dr_ip (
	idgrp		INT,		-- group
	adr		CIDR,		-- network range
	allow_deny	INT,		-- 1 = allow, 0 = deny

	FOREIGN KEY (idgrp) REFERENCES groupe (idgrp),
	PRIMARY KEY (idgrp, adr)
    ) ;

    -- DHCP profiles

    CREATE SEQUENCE seq_dhcpprofil START 1 ;
    CREATE TABLE dhcpprofil (
	iddhcpprofil	INT		-- DHCP profile id
		DEFAULT NEXTVAL ('seq_dhcpprofil'),
	nom 		TEXT UNIQUE,	-- DHCP profile name
	texte		TEXT,		-- text to add before host declarations

	CHECK (iddhcpprofil >= 1),
	PRIMARY KEY (iddhcpprofil)
    ) ;

    -- DHCP profiles allowed to groups

    CREATE TABLE dr_dhcpprofil (
	idgrp		INT,		-- group
	iddhcpprofil	INT,		-- DHCP profil
	tri		INT,		-- sort class

	FOREIGN KEY (idgrp)        REFERENCES groupe     (idgrp),
	FOREIGN KEY (iddhcpprofil) REFERENCES dhcpprofil (iddhcpprofil),
	PRIMARY KEY (idgrp, iddhcpprofil)
    ) ;

    -- DHCP dynamic ranges

    CREATE SEQUENCE seq_dhcprange START 1 ;
    CREATE TABLE dhcprange (
	iddhcprange	INT		-- for store-tabular use
		DEFAULT NEXTVAL ('seq_dhcprange'),
	min 		INET UNIQUE,	-- min address of range
	max		INET UNIQUE,	-- max address of range
	iddom		INT,		-- domain returned by DHCP server
	default_lease_time INT DEFAULT 0, -- unit = second
	max_lease_time	INT DEFAULT 0,	-- unit = second
	iddhcpprofil	INT,		-- DHCP profile for this range

	CHECK (min <= max),
	FOREIGN KEY (iddom) REFERENCES domaine (iddom),
	FOREIGN KEY (iddhcpprofil) REFERENCES dhcpprofil(iddhcpprofil),
	PRIMARY KEY (iddhcprange)
    ) ;


    -- Resource records

    CREATE SEQUENCE seq_rr START 1 ;
    CREATE TABLE rr (
	idrr		INT		-- RR id
		DEFAULT NEXTVAL ('seq_rr'),
	nom		TEXT,		-- name of RR (first component)
	iddom		INT,		-- domain name of RR

	mac		MACADDR UNIQUE,	-- MAC address or NULL
	iddhcpprofil	INT,		-- DHCP profile or NULL

	idhinfo		INT DEFAULT 0,	-- host type
	commentaire	TEXT,		-- comment
	respnom		TEXT,		-- name of responsible person
	respmel		TEXT,		-- mail address of responsible person

	idcor		INT,		-- last mod author
	date		TIMESTAMP (0) WITHOUT TIME ZONE	-- last mod date
			    DEFAULT CURRENT_TIMESTAMP,
	droitsmtp	INT DEFAULT 0,	-- 1 if this host may emit with SMTP
	ttl		INT DEFAULT -1,	-- TTL if different from zone TTL

	FOREIGN KEY (idcor)        REFERENCES corresp    (idcor),
	FOREIGN KEY (iddom)        REFERENCES domaine    (iddom),
	FOREIGN KEY (iddhcpprofil) REFERENCES dhcpprofil (iddhcpprofil),
	FOREIGN KEY (idhinfo)      REFERENCES hinfo      (idhinfo),
	UNIQUE (nom, iddom),
	PRIMARY KEY (idrr)
    ) ;

    CREATE TABLE rr_ip (
	idrr		INT,		-- RR
	adr		INET,		-- IP (v4 or v6) address

	FOREIGN KEY (idrr) REFERENCES rr (idrr),
	PRIMARY KEY (idrr, adr)
    ) ;

    CREATE TABLE rr_cname (
	idrr		INT,		-- RR
	cname		INT,		-- pointed RR id

	FOREIGN KEY (idrr)  REFERENCES rr (idrr),
	FOREIGN KEY (cname) REFERENCES rr (idrr),
	PRIMARY KEY (idrr, cname)
    ) ;

    CREATE TABLE rr_mx (
	idrr		INT,		-- RR
	priorite	INT,		-- priority
	mx		INT,		-- pointed RR id

	FOREIGN KEY (idrr) REFERENCES rr (idrr),
	FOREIGN KEY (mx)   REFERENCES rr (idrr),
	PRIMARY KEY (idrr, mx)
    ) ;

    -- Web roles (not used at this time)
    CREATE TABLE role_web (
	idrr		INT,		-- Web server id

	FOREIGN KEY (idrr) REFERENCES rr (idrr),
	PRIMARY KEY (idrr)
    ) ;

    -- Mail roles
    CREATE TABLE role_mail (
	idrr		INT,		-- id of "mail address"
	heberg		INT,		-- id of RR holding mboxes for this address

	FOREIGN KEY (idrr)   REFERENCES rr (idrr),
	FOREIGN KEY (heberg) REFERENCES rr (idrr),
	PRIMARY KEY (idrr)
    ) ;

    -- Groups having right to manage mail boxes (not used at this time)
    CREATE TABLE dr_mbox (
	idgrp		INT,		-- group id
	idmail		INT,		-- id of "mail adress"

	FOREIGN KEY (idgrp)  REFERENCES groupe (idgrp),
	FOREIGN KEY (idmail) REFERENCES role_mail (idrr),
	PRIMARY KEY (idgrp, idmail)
    ) ;

    -- Mail relays for a domain
    CREATE TABLE relais_dom (
	iddom		INT,		-- domain id
	priorite	INT,		-- MX priority
	mx		INT,		-- relay host for this domain

	FOREIGN KEY (iddom) REFERENCES domaine (iddom),
	FOREIGN KEY (mx)    REFERENCES rr      (idrr),
	PRIMARY KEY (iddom, mx)
    ) ;


    -- DNS zone generation

    CREATE SEQUENCE seq_zone START 1 ;
    CREATE TABLE zone (
	idzone		INT		-- zone id
		DEFAULT NEXTVAL ('seq_zone'),
	domaine		TEXT,		-- domain of zone (may be in in-addr.arpa)
	version		INT,		-- version number
	prologue	TEXT,		-- zone prologue (with %ZONEVERSION% pattern)
	rrsup		TEXT,		-- added to each generated host
	generer		INT,		-- modified since last generation

	UNIQUE (domaine),
	PRIMARY KEY (idzone)
    ) ;

    CREATE TABLE zone_normale (
	selection	TEXT		-- criterion to select names
    ) INHERITS (zone) ;

    CREATE TABLE zone_reverse4 (
	selection	CIDR		-- criterion to select addresses
    ) INHERITS (zone) ;

    CREATE TABLE zone_reverse6 (
	selection	CIDR		-- criterion to select addresses
    ) INHERITS (zone) ;

    -- To force generation of dhcpd.conf

    CREATE TABLE dhcp (
	generer INTEGER			-- 1 if dhcpd.conf must be generated
    ) ;

    INSERT INTO dhcp (generer) VALUES (0) ;

    -- Netmagis configuration parameters (those which are not in the
    -- configuration file)
    CREATE TABLE config (
	clef		TEXT,		-- configuration key
	valeur		TEXT,		-- key value

	PRIMARY KEY (clef)
    ) ;


    -- log
    CREATE TABLE log (
	date		TIMESTAMP (0) WITHOUT TIME ZONE
				    DEFAULT CURRENT_TIMESTAMP
				    NOT NULL,
	subsys		TEXT NOT NULL,	-- subsystem ("dns", "topo", etc.)
	event		TEXT NOT NULL,	-- "addhost", "delalias", etc.
	login		TEXT,		-- user login
	ip		INET,		-- IP address
	msg		TEXT		-- log message
    ) ;

    -- fonctions

    -- check a DHCP range against group permissions
    -- $1 : idgrp
    -- $2 : dhcp min
    -- $3 : dhcp max
    CREATE OR REPLACE FUNCTION valide_dhcprange_grp (INTEGER, INET, INET)
		    RETURNS BOOLEAN AS '
	set min {}
	foreach o [split $2 "."] {
	    lappend min [format "%02x" $o]
	}
	set min [join $min ""]
	set min [expr 0x$min]
	set ipbin [expr 0x$min]

	set max {}
	foreach o [split $3 "."] {
	    lappend max [format "%02x" $o]
	}
	set max [join $max ""]
	set max [expr 0x$max]

	set r t
	for {set ipbin $min} {$ipbin <= $max} {incr ipbin} {
	    # Prepare the new IP address
	    set ip {}
	    set o $ipbin
	    for {set i 0} {$i < 4} {incr i} {
		set ip [linsert $ip 0 [expr $o & 0xff]]
		set o [expr $o >> 8]
	    }
	    set ip [join $ip "."]

	    # Check validity
	    spi_exec "SELECT valide_ip_grp (''$ip'', $1) AS v"

	    if {! [string equal $v "t"]} then {
		set r f
		break
	    }
	}
	return $r
	' LANGUAGE pltcl ;


    --------------------------------------------------------------------------
    -- Mark addresses in a CIDR: characterize each IPv4 address with:
    --   0 : unavailable (broadcast addr, no right on addr, etc.)
    --   1 : not declared and not in a dhcp range
    --   2 : declared and not in a dhcp range
    --   3 : not declared and in a dhcp range
    --   4 : declared and in a dhcp range
    -- This function creates a temporary table (allip) which only exists
    -- during the postgresql session lifetime. This table is internal to
    -- the session (other sessions cannot see it).
    -- Since this function performs a sequential traversal of IP range,
    -- a limit value must be given to not overload the PostgreSQL engine.
    --------------------------------------------------------------------------

    CREATE OR REPLACE FUNCTION markcidr (reseau CIDR, lim INTEGER, grp INTEGER)
	RETURNS void AS $$
	DECLARE
	    min INET ;
	    max INET ;
	    a INET ;
	BEGIN
	    min := INET (HOST (reseau)) ;
	    max := INET (HOST (BROADCAST (reseau))) ;

	    IF max - min - 2 > lim THEN
		RAISE EXCEPTION 'Too many addresses' ;
	    END IF ;

	    -- All this exception machinery is here since we can't use :
	    --    DROP TABLE IF EXISTS allip ;
	    -- It raises a notice exception, which prevents
	    -- script "ajout" to function
	    BEGIN
		DROP TABLE allip ;
	    EXCEPTION
		WHEN OTHERS THEN -- nothing
	    END ;

	    CREATE TEMPORARY TABLE allip (
		adr INET,
		avail INTEGER,
		    -- 0 : unavailable (broadcast addr, no right on addr, etc.)
		    -- 1 : not declared and not in a dhcp range
		    -- 2 : declared and not in a dhcp range
		    -- 3 : not declared and in a dhcp range
		    -- 4 : declared and in a dhcp range
		fqdn TEXT		-- if 2 or 4, then fqdn else NULL
	    ) ;

	    a := min ; 
	    WHILE a <= max LOOP
		INSERT INTO allip VALUES (a, 1) ;
		a := a + 1 ;
	    END LOOP ;

	    UPDATE allip
		SET fqdn = rr.nom || '.' || domaine.nom,
		    avail = 2
		FROM rr_ip, rr, domaine
		WHERE allip.adr = rr_ip.adr
		    AND rr_ip.idrr = rr.idrr
		    AND rr.iddom = domaine.iddom
		    ;

	    UPDATE allip
		SET avail = CASE
				WHEN avail = 1 THEN 3
				WHEN avail = 2 THEN 4
			    END
		FROM dhcprange
		WHERE (avail = 1 OR avail = 2)
		    AND adr >= dhcprange.min
		    AND adr <= dhcprange.max
		;

	    UPDATE allip SET avail = 0
		WHERE adr = min OR adr = max OR NOT valide_ip_grp (adr, grp) ;

	    RETURN ;

	END ;
	$$ LANGUAGE plpgsql ;

    --------------------------------------------------------------------------
    -- Search IP(v4) available blocks. PostgreSQL 8.3 version (the 8.4
    -- version would have been more elegant)
    --------------------------------------------------------------------------

    CREATE TYPE iprange_t AS (a INET, n INTEGER) ;

    CREATE OR REPLACE FUNCTION ipranges (reseau CIDR, lim INTEGER, grp INTEGER)
	RETURNS SETOF iprange_t AS $$
	DECLARE
	    inarange BOOLEAN ;
	    r RECORD ;
	    q iprange_t%ROWTYPE ;
	BEGIN
	    PERFORM markcidr (reseau, lim, grp) ;
	    inarange := FALSE ;
	    FOR r IN (SELECT adr, avail FROM allip ORDER BY adr)
	    LOOP
		IF inarange THEN
		    -- (q.a, q.n) is already a valid range
		    IF r.avail = 1 THEN
			q.n := q.n + 1 ;
		    ELSE
			RETURN NEXT q ;
			inarange := FALSE ;
		    END IF ;
		ELSE
		    -- not inside a range
		    IF r.avail = 1 THEN
			-- start a new range (q.a, q.n)
			q.a := r.adr ;
			q.n := 1 ;
			inarange := TRUE ;
		    END IF ;
		END IF ;
	    END LOOP ;
	    IF inarange THEN
		RETURN NEXT q ;
	    END IF ;
	    DROP TABLE allip ;
	    RETURN ;
	END ;
	$$ LANGUAGE plpgsql ;
EOF
}

##############################################################################
# Database permissions
##############################################################################

grant-root ()
{
    user=$1
    psql --quiet <<EOF
	GRANT ALL
	    ON 
		seq_domaine, domaine,
		seq_groupe, groupe, seq_corresp, corresp,
		seq_reseau, reseau, dr_reseau,
		seq_etablissement, etablissement,
		seq_communaute, communaute,
		dr_dom, dr_ip,
		seq_dhcprange, dhcprange,
		seq_dhcpprofil, dhcpprofil, dr_dhcpprofil,
		seq_rr, rr,
		rr_ip, rr_cname, rr_mx,
		seq_hinfo, hinfo,
		role_web, role_mail, dr_mbox, relais_dom,
		seq_zone, zone, zone_normale, zone_reverse4, zone_reverse6,
		dhcp,
		config, log
	    TO $user ;
EOF
}

grant-www ()
{
    user=$1
    psql --quiet <<EOF
	GRANT SELECT
	    ON
		seq_domaine, domaine,
		seq_groupe, groupe, seq_corresp, corresp,
		seq_reseau, reseau, dr_reseau,
		seq_etablissement, etablissement,
		seq_communaute, communaute,
		dr_dom, dr_ip,
		seq_dhcprange, dhcprange,
		seq_dhcpprofil, dhcpprofil, dr_dhcpprofil,
		seq_rr, rr,
		rr_ip, rr_cname, rr_mx,
		seq_hinfo, hinfo,
		role_web, role_mail, dr_mbox, relais_dom,
		seq_zone, zone, zone_normale, zone_reverse4, zone_reverse6,
		dhcp,
		config, log
	    TO $user ;
	GRANT INSERT
	    ON
		domaine,
		groupe, corresp,
		reseau, dr_reseau,
		etablissement,
		communaute,
		dr_dom, dr_ip,
		dhcprange,
		dhcpprofil, dr_dhcpprofil,
		rr,
		rr_ip, rr_cname, rr_mx,
		hinfo,
		role_web, role_mail, dr_mbox, relais_dom,
		zone, zone_normale, zone_reverse4, zone_reverse6,
		dhcp,
		config, log
	    TO $user ;
	GRANT UPDATE
	    ON
		seq_domaine, domaine,
		seq_groupe, groupe, seq_corresp, corresp,
		seq_reseau, reseau, dr_reseau,
		seq_etablissement, etablissement,
		seq_communaute, communaute,
		dr_dom, dr_ip,
		seq_dhcprange, dhcprange,
		seq_dhcpprofil, dhcpprofil, dr_dhcpprofil,
		seq_rr, rr,
		rr_ip, rr_cname, rr_mx,
		seq_hinfo, hinfo,
		role_web, role_mail, dr_mbox, relais_dom,
		seq_zone, zone, zone_normale, zone_reverse4, zone_reverse6,
		dhcp,
		config, log
	    TO $user ;
	GRANT DELETE
	    ON
		domaine,
		corresp,
		reseau, dr_reseau,
		etablissement,
		communaute,
		dr_dom, dr_ip,
		dhcprange,
		dhcpprofil, dr_dhcpprofil,
		rr,
		rr_ip, rr_cname, rr_mx,
		hinfo,
		role_web, role_mail, dr_mbox, relais_dom,
		zone, zone_normale, zone_reverse4, zone_reverse6,
		dhcp,
		config, log
	    TO $user ;
EOF
}

##############################################################################
# Main program
##############################################################################

#
# Initialize environnement
#

init-env

#
# Syntax checking
#       
 
args=`getopt hd:u:w: $*`

if [ $? != 0 ]
then usage
fi

set -- $args

PGUSER="`echo $rootusers | sed 's/[ 	].*//'`" ; export PGUSER

while true
do
    case "$1" in
	-d) PGDATABASE="$2" ; export PGDATABASE
	    shift 2
	    ;;
	-u) PGUSER="$2" ; export PGUSER
	    shift 2
	    ;;
	-w) PGPASSWORD="$2" ; export PGPASSWORD
	    shift 2
	    ;;
	-h) usage
	    exit 0
	    ;;
	--) shift
	    break
	    ;;
    esac
done

if db-exists
then
    echo "Database '$PGDATABASE' already exists" >&2
    echo "Use 'dropdb' command to destroy database first" >&2
    exit 1
fi

db-create

db-fill

for u in $rootusers
do
    grant-root $u
done

grant-www $dnsdbuser

exit 0
