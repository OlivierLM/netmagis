#!/bin/sh

#
# Netmagis database creation
#
# Syntax :
#	netmagis-dbcreate [netmagis] [mac]
#
# History
#   2002/02/11 : pda        : design
#   2002/02/12 : pda/jean   : adapt to new data model
#   2002/04/19 : pda/jean   : unique constraint on nom+domain
#   2002/04/19 : pda        : unique constraint on domain name
#   2002/04/23 : pda        : add priority in domain permissions
#   2002/04/23 : pda/jean   : add zone generation management
#   2002/05/02 : pda/jean   : use PG objects for zone tables
#   2002/05/06 : pda        : id for zone table
#   2002/05/21 : pda        : add communaute table
#   2004/01/22 : pda        : use new data model
#   2005/04/08 : pda        : use new data model (v 1.3)
#   2007/11/27 : pda/jean   : pgsql 8.2
#   2007/11/27 : pda/jean   : add log table
#   2011/01/21 : pda        : i18n
#   2011/01/21 : pda        : use new config file
#   2011/07/17 : pda        : defuser is given a value and created
#   2011/12/28 : pda        : add dotattr table
#   2012/01/21 : jean       : add droitgenl attribute
#   2012/04/08 : pda        : simplify users
#   2012/04/08 : pda        : mac database creation
#   2012/06/15 : pda/jean   : drop -u/-w for an obsolete privileged user
#   2012/06/19 : pda        : don't create copy database
#   2012/09/20 : pda/jean   : remove dnsupdateperiod
#   2012/09/27 : pda/jean   : rename dns.zone.domaine
#

usage ()
{
    (
	echo "usage: $0 [netmagis] [mac]"
	echo "  netmagis : create netmagis database and schemas"
	echo "  mac      : create mac database and schema"
    ) >&2
    exit 1
}

# defuser is used for initial database migration
defuser="nobody"

##############################################################################
# Configuration file read
##############################################################################

init_env ()
{
    # Main netmagis database parameters (dnsdb*)
    varlist="dnsdbhost dnsdbport dnsdbname dnsdbuser dnsdbpassword rootusers"
    eval `%CONFPROG% -c $varlist`

    if [ $? != 0 ]
    then
	usage
	exit 1
    fi

    # Mac database parameters (macdb*)
    varlist="macdbhost macdbport macdbname macdbuser macdbpassword"
    eval `%CONFPROG% -c $varlist`

    if [ $? != 0 ]
    then
	usage
	exit 1
    fi

    # These variables are searched in a second pass, since they can be empty
    # (the first pass used the "-c" flag) 
    varlist="pwgen crypt"
    eval `%CONFPROG% $varlist`
}

##############################################################################
# Generic database creation
##############################################################################

# returns an error if creation failed
db_create_if_not_exists ()
{
    r=0
    if psql --no-psqlrc -c "" 2> /dev/null
    then :
    else
	# black magic: use template0 to avoid encoding incompatibility
	createdb -E unicode --template=template0
	r=$?
    fi
    return $r
}

# $* = schemas to test
# returns true if schema exists
db_test_schemas ()
{
    schemas=`psql --quiet --no-psqlrc --tuples-only --no-align \
		    -c "SELECT nspname FROM pg_catalog.pg_namespace"`
    r=1
    for i
    do
	if echo "$schemas" | grep "^$i$" > /dev/null
	then
	    (
		echo "Error: schema '$i' already exists in database '$PGDATABASE'"
		echo "Use either 'DROP SCHEMA $i' SQL command to destroy schema"
		echo "or 'dropdb $PGDATABASE' shell command to destroy database"
	    ) >&2
	    r=0
	    break
	fi
    done
    return $r
}

##############################################################################
# Language creation
##############################################################################

# $1 = language
# exits if creation failed
create_language ()
{
    if psql --quiet --no-psqlrc -c "CREATE EXTENSION IF NOT EXISTS $1"
    then :
    else
	echo "Unable to create language "$1" in database '$PGDATABASE'" >&2
	exit 1
    fi
}

##############################################################################
# Create netmagis database
##############################################################################

create_netmagis ()
{
    echo "Creating main Netmagis database as '$dnsdbname'"

    PGHOST="$dnsdbhost"
    PGPORT="$dnsdbport"
    PGDATABASE="$dnsdbname"
    PGUSER="$dnsdbuser"
    PGPASSWORD="$dnsdbpassword"
    export PGHOST PGPORT PGDATABASE PGUSER PGPASSWORD

    ###############################
    # Create main netmagis database
    ###############################

    if db_create_if_not_exists
    then :
    else
	echo "Erreur while creating database '$PGDATABASE'" 2>&1
	exit 1
    fi

    # exit if schema already exist
    if db_test_schemas "global" "dns" "topo" "pgauth"
    then
	exit 1
    fi

    ###############################
    # Initialize main netmagis database schemas and contents
    ###############################

    create_language plpgsql
    create_language pltcl

    create_netmagis_schemas

    netmagis_insert_config

    ###############################
    # Create netmagis application users
    ###############################

    for u in $rootusers
    do
	netmagis_create_user $u
    done

    netmagis_create_user $defuser

    if [ "$pwgen" = "" -o "$crypt" = "" ]
    then
	echo "Netmagis configuration parameter 'pwgen' and/or 'crypt' uninitialized" >&2
	echo "Users $rootusers have been created" >&2
    else
	echo "You can change passwords within netmagis application" >&2
    fi
}

##############################################################################
# Netmagis schema creation
##############################################################################

create_netmagis_schemas ()
{
    PGCLIENTENCODING=utf8
    export PGCLIENTENCODING

    psql --no-psqlrc --quiet --file - <<'EOF' 2>&1 | grep -v 'NOTICE: .* will create implicit'

    CREATE SCHEMA global ;
    CREATE SCHEMA dns ;
    CREATE SCHEMA topo ;
    CREATE SCHEMA pgauth ;

    ---------------------------------------------------------------------------
    -- global schema
    ---------------------------------------------------------------------------

    -- users and groups

    CREATE SEQUENCE global.seq_groupe START 1 ;
    CREATE TABLE global.groupe (
	idgrp		INT		-- group id
		DEFAULT NEXTVAL ('global.seq_groupe'),
	nom		TEXT,		-- group name
	admin		INT DEFAULT 0,	-- 1 if root, 0 if normal user
	droitsmtp	INT DEFAULT 0,	-- 1 if right to manage SMTP senders
	droitttl	INT DEFAULT 0,	-- 1 if right to edit TTL for a host
	droitmac	INT DEFAULT 0,	-- 1 if right to access MAC module
	droitgenl	INT DEFAULT 0,	-- 1 if right to generate a link number

	UNIQUE (nom),
	PRIMARY KEY (idgrp)
    ) ;

    CREATE SEQUENCE global.seq_corresp START 1 ;
    CREATE TABLE global.corresp (
	idcor		INT		-- user id
		DEFAULT NEXTVAL ('global.seq_corresp'),
	login		TEXT,		-- user name
	present		INT,		-- 1 if present, 0 if no longer here
	idgrp		INT,		-- group

	UNIQUE (login),
	FOREIGN KEY (idgrp) REFERENCES global.groupe (idgrp),
	PRIMARY KEY (idcor)
    ) ;

    -- Netmagis configuration parameters (those which are not in the
    -- configuration file)
    CREATE TABLE global.config (
	clef		TEXT,		-- configuration key
	valeur		TEXT,		-- key value

	PRIMARY KEY (clef)
    ) ;

    -- log
    CREATE TABLE global.log (
	date		TIMESTAMP (0) WITHOUT TIME ZONE
				    DEFAULT CURRENT_TIMESTAMP
				    NOT NULL,
	subsys		TEXT NOT NULL,	-- subsystem ("dns", "topo", etc.)
	event		TEXT NOT NULL,	-- "addhost", "delalias", etc.
	login		TEXT,		-- user login
	ip		INET,		-- IP address
	msg		TEXT		-- log message
    ) ;

    ---------------------------------------------------------------------------
    -- dns schema
    ---------------------------------------------------------------------------

    -- domains

    CREATE SEQUENCE dns.seq_domaine START 1 ;
    CREATE TABLE dns.domaine (
	iddom		INT		-- domain id
		DEFAULT NEXTVAL ('dns.seq_domaine'),
	nom		TEXT,		-- domain name (ex: "example.com")

	UNIQUE (nom),
	PRIMARY KEY (iddom)
    ) ;

    -- network, communities and organization descriptions

    CREATE SEQUENCE dns.seq_etablissement START 1 ;
    CREATE TABLE dns.etablissement (
	idetabl		INT		-- organization id
		DEFAULT NEXTVAL ('dns.seq_etablissement'),
	nom		TEXT,		-- "Example Corp."

	PRIMARY KEY (idetabl)
    ) ;

    CREATE SEQUENCE dns.seq_communaute START 1 ;
    CREATE TABLE dns.communaute (
	idcommu		INT		-- community id
		DEFAULT NEXTVAL ('dns.seq_communaute'),
	nom		TEXT,		-- "Administration"

	PRIMARY KEY (idcommu)
    ) ;

    CREATE SEQUENCE dns.seq_reseau START 1 ;
    CREATE TABLE dns.reseau (
	idreseau	INT		-- network id
		DEFAULT NEXTVAL ('dns.seq_reseau'),
	nom		TEXT,		-- name (ex: "Servers")
	localisation	TEXT,		-- location if any
	adr4		CIDR,		-- IPv4 address range
	adr6		CIDR,		-- IPv6 address range
	idetabl		INT,		-- organization this network belongs to
	idcommu		INT,		-- administration, R&D, etc.
	commentaire	TEXT,		-- comment
	dhcp		INT DEFAULT 0,	-- activate DHCP (1) or no (0)
	gw4		INET,		-- default network IPv4 gateway
	gw6		INET,		-- default network IPv6 gateway

	CONSTRAINT au_moins_un_prefixe_v4_ou_v6
	    CHECK (adr4 IS NOT NULL OR adr6 IS NOT NULL),
	CONSTRAINT gw4_in_net CHECK (gw4 <<= adr4),
	CONSTRAINT gw6_in_net CHECK (gw6 <<= adr6),
	CONSTRAINT dhcp_needs_ipv4_gateway
	    CHECK (dhcp = 0 OR (dhcp != 0 AND gw4 IS NOT NULL)),
	FOREIGN KEY (idetabl) REFERENCES dns.etablissement (idetabl),
	FOREIGN KEY (idcommu) REFERENCES dns.communaute    (idcommu),
	PRIMARY KEY (idreseau)
    ) ;


    -- host types

    CREATE SEQUENCE dns.seq_hinfo MINVALUE 0 START 0 ;
    CREATE TABLE dns.hinfo (
	idhinfo		INT		-- host type id
		DEFAULT NEXTVAL ('dns.seq_hinfo'),
	texte		TEXT,		-- type as text
	tri		INT,		-- sort class
	present		INT,		-- present or not
	PRIMARY KEY (idhinfo)
    ) ;

    -- ranges allowed to groups

    CREATE TABLE dns.dr_reseau (
	idgrp		INT,		-- the group which manages this network
	idreseau	INT,		-- the network
	tri		INT,		-- sort class
	dhcp		INT DEFAULT 0,	-- perm to manage DHCP ranges
	acl		INT DEFAULT 0,	-- perm to manage ACL (later...)

	FOREIGN KEY (idgrp)    REFERENCES global.groupe (idgrp),
	FOREIGN KEY (idreseau) REFERENCES dns.reseau (idreseau),
	PRIMARY KEY (idgrp, idreseau)
    ) ;

    -- domains allowed to groups

    CREATE TABLE dns.dr_dom (
	idgrp		INT,		-- group
	iddom		INT,		-- domain id
	tri		INT,		-- sort class
	rolemail	INT DEFAULT 0,	-- perm to manage mail roles
	roleweb		INT DEFAULT 0,	-- perm to manage web roles (later...)

	FOREIGN KEY (idgrp) REFERENCES global.groupe (idgrp),
	PRIMARY KEY (idgrp, iddom)
    ) ;

    CREATE TABLE dns.dr_ip (
	idgrp		INT,		-- group
	adr		CIDR,		-- network range
	allow_deny	INT,		-- 1 = allow, 0 = deny

	FOREIGN KEY (idgrp) REFERENCES global.groupe (idgrp),
	PRIMARY KEY (idgrp, adr)
    ) ;

    -- DHCP profiles

    CREATE SEQUENCE dns.seq_dhcpprofil START 1 ;
    CREATE TABLE dns.dhcpprofil (
	iddhcpprofil	INT		-- DHCP profile id
		DEFAULT NEXTVAL ('dns.seq_dhcpprofil'),
	nom 		TEXT UNIQUE,	-- DHCP profile name
	texte		TEXT,		-- text to add before host declarations

	CHECK (iddhcpprofil >= 1),
	PRIMARY KEY (iddhcpprofil)
    ) ;

    -- DHCP profiles allowed to groups

    CREATE TABLE dns.dr_dhcpprofil (
	idgrp		INT,		-- group
	iddhcpprofil	INT,		-- DHCP profil
	tri		INT,		-- sort class

	FOREIGN KEY (idgrp)        REFERENCES global.groupe  (idgrp),
	FOREIGN KEY (iddhcpprofil) REFERENCES dns.dhcpprofil (iddhcpprofil),
	PRIMARY KEY (idgrp, iddhcpprofil)
    ) ;

    -- DHCP dynamic ranges

    CREATE SEQUENCE dns.seq_dhcprange START 1 ;
    CREATE TABLE dns.dhcprange (
	iddhcprange	INT		-- for store-tabular use
		DEFAULT NEXTVAL ('dns.seq_dhcprange'),
	min 		INET UNIQUE,	-- min address of range
	max		INET UNIQUE,	-- max address of range
	iddom		INT,		-- domain returned by DHCP server
	default_lease_time INT DEFAULT 0, -- unit = second
	max_lease_time	INT DEFAULT 0,	-- unit = second
	iddhcpprofil	INT,		-- DHCP profile for this range

	CHECK (min <= max),
	FOREIGN KEY (iddom) REFERENCES dns.domaine (iddom),
	FOREIGN KEY (iddhcpprofil) REFERENCES dns.dhcpprofil(iddhcpprofil),
	PRIMARY KEY (iddhcprange)
    ) ;

    -- Resource records

    CREATE SEQUENCE dns.seq_rr START 1 ;
    CREATE TABLE dns.rr (
	idrr		INT		-- RR id
		DEFAULT NEXTVAL ('dns.seq_rr'),
	nom		TEXT,		-- name of RR (first component)
	iddom		INT,		-- domain name of RR

	mac		MACADDR UNIQUE,	-- MAC address or NULL
	iddhcpprofil	INT,		-- DHCP profile or NULL

	idhinfo		INT DEFAULT 0,	-- host type
	commentaire	TEXT,		-- comment
	respnom		TEXT,		-- name of responsible person
	respmel		TEXT,		-- mail address of responsible person

	idcor		INT,		-- last mod author
	date		TIMESTAMP (0) WITHOUT TIME ZONE	-- last mod date
			    DEFAULT CURRENT_TIMESTAMP,
	droitsmtp	INT DEFAULT 0,	-- 1 if this host may emit with SMTP
	ttl		INT DEFAULT -1,	-- TTL if different from zone TTL

	FOREIGN KEY (idcor)        REFERENCES global.corresp (idcor),
	FOREIGN KEY (iddom)        REFERENCES dns.domaine    (iddom),
	FOREIGN KEY (iddhcpprofil) REFERENCES dns.dhcpprofil (iddhcpprofil),
	FOREIGN KEY (idhinfo)      REFERENCES dns.hinfo      (idhinfo),
	UNIQUE (nom, iddom),
	PRIMARY KEY (idrr)
    ) ;

    CREATE TABLE dns.rr_ip (
	idrr		INT,		-- RR
	adr		INET,		-- IP (v4 or v6) address

	FOREIGN KEY (idrr) REFERENCES dns.rr (idrr),
	PRIMARY KEY (idrr, adr)
    ) ;

    CREATE TABLE dns.rr_cname (
	idrr		INT,		-- RR
	cname		INT,		-- pointed RR id

	FOREIGN KEY (idrr)  REFERENCES dns.rr (idrr),
	FOREIGN KEY (cname) REFERENCES dns.rr (idrr),
	PRIMARY KEY (idrr, cname)
    ) ;

    CREATE TABLE dns.rr_mx (
	idrr		INT,		-- RR
	priorite	INT,		-- priority
	mx		INT,		-- pointed RR id

	FOREIGN KEY (idrr) REFERENCES dns.rr (idrr),
	FOREIGN KEY (mx)   REFERENCES dns.rr (idrr),
	PRIMARY KEY (idrr, mx)
    ) ;

    -- Web roles (not used at this time)
    CREATE TABLE dns.role_web (
	idrr		INT,		-- Web server id

	FOREIGN KEY (idrr) REFERENCES dns.rr (idrr),
	PRIMARY KEY (idrr)
    ) ;

    -- Mail roles
    CREATE TABLE dns.role_mail (
	idrr		INT,		-- id of "mail address"
	heberg		INT,		-- id of RR holding mboxes for this address

	FOREIGN KEY (idrr)   REFERENCES dns.rr (idrr),
	FOREIGN KEY (heberg) REFERENCES dns.rr (idrr),
	PRIMARY KEY (idrr)
    ) ;

    -- Mail relays for a domain
    CREATE TABLE dns.relais_dom (
	iddom		INT,		-- domain id
	priorite	INT,		-- MX priority
	mx		INT,		-- relay host for this domain

	FOREIGN KEY (iddom) REFERENCES dns.domaine (iddom),
	FOREIGN KEY (mx)    REFERENCES dns.rr      (idrr),
	PRIMARY KEY (iddom, mx)
    ) ;

    -- DNS zone generation

    CREATE SEQUENCE dns.seq_zone START 1 ;
    CREATE TABLE dns.zone (
	idzone		INT		-- zone id
		DEFAULT NEXTVAL ('dns.seq_zone'),
	name		TEXT,		-- zone name and name of generated file
	version		INT,		-- version number
	prologue	TEXT,		-- zone prologue (with %ZONEVERSION% pattern)
	rrsup		TEXT,		-- added to each generated host
	generer		INT,		-- modified since last generation
    ) ;

    CREATE TABLE dns.zone_normale (
	selection	TEXT		-- criterion to select names

	UNIQUE (name),
	PRIMARY KEY (idzone)
    ) INHERITS (dns.zone) ;

    CREATE TABLE dns.zone_reverse4 (
	selection	CIDR		-- criterion to select addresses

	UNIQUE (name),
	PRIMARY KEY (idzone)
    ) INHERITS (dns.zone) ;

    CREATE TABLE dns.zone_reverse6 (
	selection	CIDR		-- criterion to select addresses

	UNIQUE (name),
	PRIMARY KEY (idzone)
    ) INHERITS (dns.zone) ;

    -- To force generation of dhcpd.conf

    CREATE TABLE dns.dhcp (
	generer INTEGER			-- 1 if dhcpd.conf must be generated
    ) ;

    ---------------------------------------------------------------------------
    -- topo schema
    ---------------------------------------------------------------------------
    
    -- Modified equipement spool

    CREATE TABLE topo.modeq (
	eq		TEXT,		-- fully qualified equipement name
	date		TIMESTAMP (0)	-- detection date
		    		WITHOUT TIME ZONE
				DEFAULT CURRENT_TIMESTAMP,
	login		TEXT,		-- detected user
	processed	INT DEFAULT 0
    ) ;

    CREATE INDEX modeq_index ON topo.modeq (eq) ;

    -- Interface change request spool

    CREATE TABLE topo.ifchanges (
	login		TEXT,		-- requesting user
	reqdate		TIMESTAMP (0)	-- request date
				WITHOUT TIME ZONE
				DEFAULT CURRENT_TIMESTAMP,
	idrr		INT,		-- equipement id
	iface		TEXT,		-- interface name
	ifdesc		TEXT,		-- interface description
	ethervlan	INT,		-- access vlan id
	voicevlan	INT,		-- voice vlan id
	processed	INT DEFAULT 0,	-- modification processed
	moddate		TIMESTAMP (0)	-- modification (or last attempt) date
			   	 WITHOUT TIME ZONE,
	modlog		TEXT,		-- modification (or last attempt) log
	FOREIGN KEY (idrr) REFERENCES dns.rr (idrr),
	PRIMARY KEY (idrr, reqdate, iface)
    ) ;

    -- Last rancid run

    CREATE TABLE topo.lastrun (
	    date	TIMESTAMP (0)	-- detection date
				WITHOUT TIME ZONE
    ) ;

    -- Keepstate events

    CREATE TABLE topo.keepstate (
	type		TEXT,		-- "rancid", "anaconf"
	message		TEXT,		-- last message
	date		TIMESTAMP (0)	-- first occurrence of this message
				WITHOUT TIME ZONE
				DEFAULT CURRENT_TIMESTAMP,

	PRIMARY KEY (type)
    ) ;

    -- Users to ignore : don't log any event in the modified equipement spool
    -- for these users because we know they have only a read-only access to the
    -- equipements

    CREATE TABLE topo.ignoreequsers (
	    login	TEXT UNIQUE NOT NULL	-- user login
    ) ;

    -- Access rights to equipements

    CREATE TABLE topo.dr_eq (
	idgrp		INT,		-- group upon which this access right applies
	rw		INT,		-- 0 : read, 1 : write
	pattern		TEXT NOT NULL,	-- regular expression
	allow_deny	INT,		-- 1 = allow, 0 = deny

	FOREIGN KEY (idgrp) REFERENCES global.groupe (idgrp)
    ) ;

    -- Sensor definition

    -- type trafic
    --	iface = iface[.vlan]
    --	param = NULL
    -- type number of assoc wifi
    --	iface = iface
    --	ssid
    -- type number of auth wifi
    --	iface = iface
    --	param = ssid
    -- type broadcast traffic
    --	iface = iface[.vlan]
    --	param = NULL
    -- type multicast traffic
    --	iface = iface[.vlan]
    --	param = NULL

    CREATE TABLE topo.sensor (
	id		TEXT,		-- M1234
	type		TEXT,		-- trafic, nbassocwifi, nbauthwifi, etc.
	eq		TEXT,		-- fqdn
	comm		TEXT,		-- snmp communuity
	iface		TEXT,
	param		TEXT,
	lastmod		TIMESTAMP (0)	-- last modification date
				WITHOUT TIME ZONE
				DEFAULT CURRENT_TIMESTAMP,
	lastseen	TIMESTAMP (0)	-- last detection date
				WITHOUT TIME ZONE
				DEFAULT CURRENT_TIMESTAMP,

	PRIMARY KEY (id)
    ) ;


    -- Topod file monitor

    CREATE TABLE topo.filemonitor (
	    path	TEXT,		-- path to file or directory
	    date	TIMESTAMP (0)	-- last modification date
				WITHOUT TIME ZONE
				DEFAULT CURRENT_TIMESTAMP,

	    PRIMARY KEY (path)
    ) ;

    -- Vlan table

    CREATE TABLE topo.vlan (
	    vlanid	INT,		-- 1..4095
	    descr	TEXT,		-- description
	    voip	INT DEFAULT 0,	-- 1 if VoIP vlan, 0 if standard vlan

	    PRIMARY KEY (vlanid)
    ) ;

    CREATE OR REPLACE FUNCTION modif_vlan () RETURNS trigger AS $$
	BEGIN
	    INSERT INTO topo.modeq (eq) VALUES ('_vlan') ;
	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_mod_vlan
	AFTER INSERT OR UPDATE OR DELETE
	ON topo.vlan
	FOR EACH ROW
	EXECUTE PROCEDURE modif_vlan () ;

    -- Equipment types and equipment list to create rancid router.db file

    CREATE SEQUENCE topo.seq_eqtype START 1 ;

    CREATE TABLE topo.eqtype (
	idtype		INTEGER		-- type id
		    DEFAULT NEXTVAL ('topo.seq_eqtype'),
	type		TEXT,		-- cisco, hp, juniper, etc.

	UNIQUE (type),
	PRIMARY KEY (idtype)
    ) ;

    CREATE SEQUENCE topo.seq_eq START 1 ;

    CREATE TABLE topo.eq (
	ideq		INTEGER		-- equipment id
		DEFAULT NEXTVAL ('topo.seq_eq'),
	eq		TEXT,		-- fqdn
	idtype		INTEGER,
	up		INTEGER,	-- 1 : up, 0 : 0

	FOREIGN KEY (idtype) REFERENCES topo.eqtype (idtype),
	UNIQUE (eq),
	PRIMARY KEY (ideq)
    ) ;

    CREATE SEQUENCE topo.seq_confcmd START 1 ;

    CREATE TABLE topo.confcmd (
	idccmd		INTEGER		-- entry id
		DEFAULT NEXTVAL ('topo.seq_confcmd'),
	idtype		INTEGER,	-- equipment type
	action		TEXT,		-- action selector : prologue, ifreset
	rank		INTEGER,	-- sort order
	model		TEXT,		-- regexp matching equipment model
	command		TEXT,		-- command to send

	FOREIGN KEY (idtype) REFERENCES topo.eqtype (idtype),
	PRIMARY KEY (idccmd)
    ) ;

    -- graphviz attributes for equipements in L2 graphs
    CREATE TABLE topo.dotattr (
	rank		INTEGER,	-- sort order
	type		INTEGER,	-- 2: l2, 3: l3 graph
	regexp		TEXT,		-- regexp
	gvattr		TEXT,		-- graphviz node attributes
	png		BYTEA,		-- PNG generated by graphviz

	PRIMARY KEY (rank)
    ) ;

    -- link number and description
    CREATE SEQUENCE topo.seq_link START 1 ;
    CREATE TABLE topo.link (
	idlink          INT             -- group id
	     DEFAULT NEXTVAL ('topo.seq_link'),
	descr           TEXT,           -- link description
																
	PRIMARY KEY (idlink)
    ) ;

    CREATE OR REPLACE FUNCTION modif_routerdb () RETURNS trigger AS $$
	BEGIN
	    INSERT INTO topo.modeq (eq) VALUES ('_routerdb') ;
	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_mod_eq
	AFTER INSERT OR UPDATE OR DELETE
	ON topo.eq
	FOR EACH ROW
	EXECUTE PROCEDURE modif_routerdb () ;

    ---------------------------------------------------------------------------
    -- Functions
    ---------------------------------------------------------------------------

    -- check a DHCP range against group permissions
    -- $1 : idgrp
    -- $2 : dhcp min
    -- $3 : dhcp max
    CREATE OR REPLACE FUNCTION valide_dhcprange_grp (INTEGER, INET, INET)
		    RETURNS BOOLEAN AS '
	set min {}
	foreach o [split $2 "."] {
	    lappend min [format "%02x" $o]
	}
	set min [join $min ""]
	set min [expr 0x$min]
	set ipbin [expr 0x$min]

	set max {}
	foreach o [split $3 "."] {
	    lappend max [format "%02x" $o]
	}
	set max [join $max ""]
	set max [expr 0x$max]

	set r t
	for {set ipbin $min} {$ipbin <= $max} {incr ipbin} {
	    # Prepare the new IP address
	    set ip {}
	    set o $ipbin
	    for {set i 0} {$i < 4} {incr i} {
		set ip [linsert $ip 0 [expr $o & 0xff]]
		set o [expr $o >> 8]
	    }
	    set ip [join $ip "."]

	    # Check validity
	    spi_exec "SELECT valide_ip_grp (''$ip'', $1) AS v"

	    if {! [string equal $v "t"]} then {
		set r f
		break
	    }
	}
	return $r
	' LANGUAGE pltcl ;


    --------------------------------------------------------------------------
    -- Mark addresses in a CIDR: characterize each IPv4 address with:
    --   0 : unavailable (broadcast addr, no right on addr, etc.)
    --   1 : not declared and not in a dhcp range
    --   2 : declared and not in a dhcp range
    --   3 : not declared and in a dhcp range
    --   4 : declared and in a dhcp range
    -- This function creates a temporary table (allip) which only exists
    -- during the postgresql session lifetime. This table is internal to
    -- the session (other sessions cannot see it).
    -- Since this function performs a sequential traversal of IP range,
    -- a limit value must be given to not overload the PostgreSQL engine.
    --------------------------------------------------------------------------

    CREATE OR REPLACE FUNCTION markcidr (reseau CIDR, lim INTEGER, grp INTEGER)
	RETURNS void AS $$
	DECLARE
	    min INET ;
	    max INET ;
	    a INET ;
	BEGIN
	    min := INET (HOST (reseau)) ;
	    max := INET (HOST (BROADCAST (reseau))) ;

	    IF max - min - 2 > lim THEN
		RAISE EXCEPTION 'Too many addresses' ;
	    END IF ;

	    -- All this exception machinery is here since we can't use :
	    --    DROP TABLE IF EXISTS allip ;
	    -- It raises a notice exception, which prevents
	    -- script "ajout" to function
	    BEGIN
		DROP TABLE allip ;
	    EXCEPTION
		WHEN OTHERS THEN -- nothing
	    END ;

	    CREATE TEMPORARY TABLE allip (
		adr INET,
		avail INTEGER,
		    -- 0 : unavailable (broadcast addr, no right on addr, etc.)
		    -- 1 : not declared and not in a dhcp range
		    -- 2 : declared and not in a dhcp range
		    -- 3 : not declared and in a dhcp range
		    -- 4 : declared and in a dhcp range
		fqdn TEXT		-- if 2 or 4, then fqdn else NULL
	    ) ;

	    a := min ; 
	    WHILE a <= max LOOP
		INSERT INTO allip VALUES (a, 1) ;
		a := a + 1 ;
	    END LOOP ;

	    UPDATE allip
		SET fqdn = rr.nom || '.' || domaine.nom,
		    avail = 2
		FROM dns.rr_ip, dns.rr, dns.domaine
		WHERE allip.adr = rr_ip.adr
		    AND rr_ip.idrr = rr.idrr
		    AND rr.iddom = domaine.iddom
		    ;

	    UPDATE allip
		SET avail = CASE
				WHEN avail = 1 THEN 3
				WHEN avail = 2 THEN 4
			    END
		FROM dns.dhcprange
		WHERE (avail = 1 OR avail = 2)
		    AND adr >= dhcprange.min
		    AND adr <= dhcprange.max
		;

	    UPDATE allip SET avail = 0
		WHERE adr = min OR adr = max OR NOT valide_ip_grp (adr, grp) ;

	    RETURN ;

	END ;
	$$ LANGUAGE plpgsql ;


    --------------------------------------------------------------------------
    -- Search IP(v4) available blocks. PostgreSQL 8.3 version (the 8.4
    -- version would have been more elegant)
    --------------------------------------------------------------------------

    CREATE TYPE iprange_t AS (a INET, n INTEGER) ;

    CREATE OR REPLACE FUNCTION ipranges (reseau CIDR, lim INTEGER, grp INTEGER)
	RETURNS SETOF iprange_t AS $$
	DECLARE
	    inarange BOOLEAN ;
	    r RECORD ;
	    q iprange_t%ROWTYPE ;
	BEGIN
	    PERFORM markcidr (reseau, lim, grp) ;
	    inarange := FALSE ;
	    FOR r IN (SELECT adr, avail FROM allip ORDER BY adr)
	    LOOP
		IF inarange THEN
		    -- (q.a, q.n) is already a valid range
		    IF r.avail = 1 THEN
			q.n := q.n + 1 ;
		    ELSE
			RETURN NEXT q ;
			inarange := FALSE ;
		    END IF ;
		ELSE
		    -- not inside a range
		    IF r.avail = 1 THEN
			-- start a new range (q.a, q.n)
			q.a := r.adr ;
			q.n := 1 ;
			inarange := TRUE ;
		    END IF ;
		END IF ;
	    END LOOP ;
	    IF inarange THEN
		RETURN NEXT q ;
	    END IF ;
	    DROP TABLE allip ;
	    RETURN ;
	END ;
	$$ LANGUAGE plpgsql ;

    -- called when an IPv6 address is modified
    CREATE OR REPLACE FUNCTION gen_rev4 (INET)
	RETURNS INTEGER AS $$
	BEGIN
	    UPDATE dns.zone_reverse4 SET generer = 1 WHERE $1 <<= selection ;
	    RETURN 1 ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    -- called when an IPv6 address is modified
    CREATE OR REPLACE FUNCTION gen_rev6 (INET)
	RETURNS INTEGER AS $$
	BEGIN
	    UPDATE dns.zone_reverse6 SET generer = 1 WHERE $1 <<= selection ;
	    RETURN 1 ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    -- ID du RR
    CREATE OR REPLACE FUNCTION gen_norm_idrr (INTEGER)
	RETURNS INTEGER AS $$
	BEGIN
	    UPDATE dns.zone_normale SET generer = 1
		    WHERE selection = (
			    SELECT domaine.nom
				    FROM dns.domaine, dns.rr
				    WHERE rr.idrr = $1 AND rr.iddom = domaine.iddom
			    ) ;
	    RETURN 1 ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE OR REPLACE FUNCTION gen_norm_iddom (INTEGER)
	RETURNS INTEGER AS $$
	BEGIN
	    UPDATE dns.zone_normale SET generer = 1
		    WHERE selection = (
			    SELECT domaine.nom
				    FROM dns.domaine
				    WHERE domaine.iddom = $1
			    ) ;
	    RETURN 1 ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE OR REPLACE FUNCTION modifier_ip ()
	RETURNS trigger AS $$
	BEGIN
	    IF TG_OP = 'INSERT'
	    THEN
		PERFORM sum (gen_rev4 (NEW.adr)) ;
		PERFORM sum (gen_rev6 (NEW.adr)) ;
		PERFORM sum (gen_norm_idrr (NEW.idrr)) ;

		UPDATE dns.dhcp SET generer = 1
		    FROM dns.rr WHERE rr.idrr = NEW.idrr AND rr.mac IS NOT NULL ;

		UPDATE dns.dhcp SET generer = 1
		    FROM dns.rr WHERE rr.idrr = NEW.idrr AND rr.mac IS NOT NULL ;
	    END IF ;

	    IF TG_OP = 'UPDATE'
	    THEN
		PERFORM sum (gen_rev4 (NEW.adr)) ;
		PERFORM sum (gen_rev4 (OLD.adr)) ;
		PERFORM sum (gen_rev6 (NEW.adr)) ;
		PERFORM sum (gen_rev6 (OLD.adr)) ;
		PERFORM sum (gen_norm_idrr (NEW.idrr)) ;
		PERFORM sum (gen_norm_idrr (OLD.idrr)) ;

		UPDATE dns.dhcp SET generer = 1
		    FROM dns.rr WHERE rr.idrr = OLD.idrr AND rr.mac IS NOT NULL ;
		UPDATE dns.dhcp SET generer = 1
		    FROM dns.rr WHERE rr.idrr = NEW.idrr AND rr.mac IS NOT NULL ;
	    END IF ;

	    IF TG_OP = 'DELETE'
	    THEN
		PERFORM sum (gen_rev4 (OLD.adr)) ;
		PERFORM sum (gen_rev6 (OLD.adr)) ;
		PERFORM sum (gen_norm_idrr (OLD.idrr)) ;

		UPDATE dns.dhcp SET generer = 1
		    FROM dns.rr WHERE rr.idrr = OLD.idrr AND rr.mac IS NOT NULL ;
	    END IF ;

	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_modifier_ip
	AFTER INSERT OR UPDATE OR DELETE
	ON dns.rr_ip
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_ip ()
	;

    CREATE OR REPLACE FUNCTION modifier_mxcname ()
	RETURNS trigger AS $$
	BEGIN
	    IF TG_OP = 'INSERT'
	    THEN
		PERFORM sum (gen_norm_idrr (NEW.idrr)) ;
	    END IF ;

	    IF TG_OP = 'UPDATE'
	    THEN
		PERFORM sum (gen_norm_idrr (NEW.idrr)) ;
		PERFORM sum (gen_norm_idrr (OLD.idrr)) ;
	    END IF ;

	    IF TG_OP = 'DELETE'
	    THEN
		PERFORM sum (gen_norm_idrr (OLD.idrr)) ;
	    END IF ;

	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_modifier_cname
	AFTER INSERT OR UPDATE OR DELETE
	ON dns.rr_cname
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_mxcname ()
	;

    CREATE TRIGGER tr_modifier_mx
	AFTER INSERT OR UPDATE OR DELETE
	ON dns.rr_mx
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_mxcname ()
	;

    -- modify RR and reverse zones for all IP addresses
    CREATE OR REPLACE FUNCTION modifier_rr ()
	RETURNS trigger AS $$
	BEGIN
	    IF TG_OP = 'INSERT'
	    THEN
		PERFORM sum (gen_norm_iddom (NEW.iddom)) ;
		PERFORM sum (gen_rev4 (adr)) FROM dns.rr_ip WHERE idrr = NEW.idrr ;
		PERFORM sum (gen_rev6 (adr)) FROM dns.rr_ip WHERE idrr = NEW.idrr ;

		IF NEW.mac IS NOT NULL
		THEN
		    UPDATE dns.dhcp SET generer = 1 ;
		END IF ;
	    END IF ;

	    IF TG_OP = 'UPDATE'
	    THEN
		PERFORM sum (gen_norm_iddom (NEW.iddom)) ;
		PERFORM sum (gen_rev4 (adr)) FROM dns.rr_ip WHERE idrr = NEW.idrr ;
		PERFORM sum (gen_rev6 (adr)) FROM dns.rr_ip WHERE idrr = NEW.idrr ;
		PERFORM sum (gen_norm_iddom (OLD.iddom)) ;
		PERFORM sum (gen_rev4 (adr)) FROM dns.rr_ip WHERE idrr = OLD.idrr ;
		PERFORM sum (gen_rev6 (adr)) FROM dns.rr_ip WHERE idrr = OLD.idrr ;

		IF OLD.mac IS DISTINCT FROM NEW.mac
		    OR OLD.iddhcpprofil IS DISTINCT FROM NEW.iddhcpprofil
		THEN
		    UPDATE dns.dhcp SET generer = 1 ;
		END IF ;
	    END IF ;

	    IF TG_OP = 'DELETE'
	    THEN
		PERFORM sum (gen_norm_iddom (OLD.iddom)) ;
		PERFORM sum (gen_rev4 (adr)) FROM dns.rr_ip WHERE idrr = OLD.idrr ;
		PERFORM sum (gen_rev6 (adr)) FROM dns.rr_ip WHERE idrr = OLD.idrr ;

		IF OLD.mac IS NOT NULL
		THEN
		    UPDATE dns.dhcp SET generer = 1 ;
		END IF ;
	    END IF ;

	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_modifier_rr
	AFTER INSERT OR UPDATE OR DELETE
	ON dns.rr
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_rr ()
	;

    -- called when a mail relay is modified
    CREATE OR REPLACE FUNCTION gen_relais (INTEGER)
	RETURNS INTEGER AS $$
	BEGIN
	    UPDATE dns.zone_normale SET generer = 1
		WHERE selection = (SELECT nom FROM dns.domaine WHERE iddom = $1) ;
	    RETURN 1 ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE OR REPLACE FUNCTION modifier_relais ()
	RETURNS trigger AS $$
	BEGIN
	    IF TG_OP = 'INSERT'
	    THEN
		PERFORM sum (gen_relais (NEW.iddom)) ;
	    END IF ;

	    IF TG_OP = 'UPDATE'
	    THEN
		PERFORM sum (gen_relais (NEW.iddom)) ;
		PERFORM sum (gen_relais (OLD.iddom)) ;
	    END IF ;

	    IF TG_OP = 'DELETE'
	    THEN
		PERFORM sum (gen_relais (OLD.iddom)) ;
	    END IF ;

	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_modifier_relais
	AFTER INSERT OR UPDATE OR DELETE
	ON dns.relais_dom
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_relais ()
	;

    -- called when a zone is changed
    CREATE OR REPLACE FUNCTION modifier_zone ()
	RETURNS TRIGGER AS $$
	BEGIN
	    IF NEW.prologue <> OLD.prologue
		    OR NEW.rrsup <> OLD.rrsup
		    OR NEW.selection <> OLD.selection
	    THEN
		NEW.generer := 1 ;
	    END IF ;
	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_modifier_zone
	BEFORE UPDATE
	ON dns.zone_normale
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_zone ()
	;

    CREATE TRIGGER tr_modifier_zone4
	BEFORE UPDATE
	ON dns.zone_reverse4
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_zone ()
	;

    CREATE TRIGGER tr_modifier_zone6
	BEFORE UPDATE
	ON dns.zone_reverse6
	FOR EACH ROW
	EXECUTE PROCEDURE modifier_zone ()
	;

    -- called when a DHCP parameter (network, range or profile) is modified
    CREATE OR REPLACE FUNCTION generer_dhcp ()
	RETURNS TRIGGER AS $$
	BEGIN
	    UPDATE dns.dhcp SET generer = 1 ;
	    RETURN NEW ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    CREATE TRIGGER tr_modifier_dhcprange
	BEFORE UPDATE
	ON dns.dhcprange
	FOR EACH ROW
	EXECUTE PROCEDURE generer_dhcp ()
	;

    CREATE TRIGGER tr_modifier_reseau
	BEFORE UPDATE
	ON dns.reseau
	FOR EACH ROW
	EXECUTE PROCEDURE generer_dhcp ()
	;

    CREATE TRIGGER tr_modifier_dhcpprofil
	BEFORE UPDATE
	ON dns.dhcpprofil
	FOR EACH ROW
	EXECUTE PROCEDURE generer_dhcp ()
	;




    CREATE OR REPLACE FUNCTION valide_ip_cor (INET, INTEGER)
	RETURNS BOOLEAN AS $$
	BEGIN
	    RETURN valide_ip_grp ($1, idgrp) FROM global.corresp WHERE idcor = $2 ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    -- arg 1: address to test
    -- arg 2: group id
    CREATE OR REPLACE FUNCTION valide_ip_grp (INET, INTEGER)
	RETURNS BOOLEAN AS $$
	BEGIN
	    RETURN ($1 <<= ANY (SELECT adr FROM dns.dr_ip
				    WHERE allow_deny = 1 AND idgrp = $2)
		AND NOT $1 <<= ANY (SELECT adr FROM dns.dr_ip
				    WHERE allow_deny = 0 AND idgrp = $2)
		) ;
	END ;
	$$ LANGUAGE 'plpgsql' ;

    ---------------------------------------------------------------------------
    -- pgauth schema
    ---------------------------------------------------------------------------

    CREATE TABLE pgauth.user (
	login		TEXT,		-- login name
	password	TEXT,		-- crypted password
	nom		TEXT,		-- name
	prenom		TEXT,		-- christian name
	mel		TEXT,		-- mail address
	tel		TEXT,		-- telephone number
	mobile		TEXT,		-- mobile phone number
	fax		TEXT,		-- facsimile number
	adr		TEXT,		-- postal address
	-- columns automatically managed by triggers
	phnom		TEXT,		-- phonetical name
	phprenom	TEXT,		-- phonetical christian name

	PRIMARY KEY (login)
    ) ;

    CREATE TABLE pgauth.realm (
	realm		TEXT,		-- realm name
	descr		TEXT,		-- realm description
	admin		INT,		-- 1 if admin

	PRIMARY KEY (realm)
    ) ;

    CREATE TABLE pgauth.member (
	login		TEXT,		-- login name
	realm		TEXT,		-- realm of this login

	FOREIGN KEY (login) REFERENCES pgauth.user (login),
	FOREIGN KEY (realm) REFERENCES pgauth.realm (realm),
	PRIMARY KEY (login, realm)
    ) ;

    CREATE FUNCTION pgauth.soundex (TEXT) RETURNS TEXT AS '
	    array set soundexFrenchCode {
		a 0 b 1 c 2 d 3 e 0 f 9 g 7 h 0 i 0 j 7 k 2 l 4 m 5
		n 5 o 0 p 1 q 2 r 6 s 8 t 3 u 0 v 9 w 9 x 8 y 0 z 8
	    }
	    set accentedFrenchMap {
		é e  ë e  ê e  è e   É E  Ë E  Ê E  È E
		 ä a  â a  à a        Ä A  Â A  À A
		 ï i  î i             Ï I  Î I
		 ö o  ô o             Ö O  Ô O
		 ü u  û u  ù u        Ü U  Û U  Ù U
		 ç ss                 Ç SS
	    }
	    set key ""

	    # Map accented characters
	    set TempIn [string map $accentedFrenchMap $1]

	    # Only use alphabetic characters, so strip out all others
	    # also, soundex index uses only lower case chars, so force to lower

	    regsub -all {[^a-z]} [string tolower $TempIn] {} TempIn
	    if {$TempIn eq ""} then {
		return Z000
	    }
	    set last [string index $TempIn 0]
	    set key  [string toupper $last]
	    set last $soundexFrenchCode($last)

	    # Scan rest of string, stop at end of string or when the key is full

	    set count    1
	    set MaxIndex [string length $TempIn]

	    for {set index 1} {(($count < 4) && ($index < $MaxIndex))} {incr index } {
		set chcode $soundexFrenchCode([string index $TempIn $index])
		# Fold together adjacent letters sharing the same code
		if {$last ne $chcode} then {
		    set last $chcode
		    # Ignore code==0 letters except as separators
		    if {$last != 0} then {
			set key $key$last
			incr count
		    }
		}
	    }
	    return [string range ${key}0000 0 3]
	' LANGUAGE 'pltcl' WITH (isStrict) ;

    CREATE FUNCTION pgauth.add_soundex () RETURNS TRIGGER AS '
	BEGIN
	    NEW.phnom    := pgauth.SOUNDEX (NEW.nom) ;
	    NEW.phprenom := pgauth.SOUNDEX (NEW.prenom) ;
	    RETURN NEW ;
	END ;
	' LANGUAGE 'plpgsql' ;

    CREATE TRIGGER phnom
	BEFORE INSERT OR UPDATE
	ON pgauth.user
	FOR EACH ROW
	EXECUTE PROCEDURE pgauth.add_soundex ()
	;
EOF
}

##############################################################################
# Default values for Netmagis config keys
##############################################################################

netmagis_insert_config ()
{
    psql --no-psqlrc --quiet --file - <<'EOF'

    COPY global.config (clef, valeur) FROM stdin;
datefmt	%d/%m/%Y %H:%M:%S
jourfmt	%a %d %b %Y
authmethod	pgsql
pageformat	a4
default_lease_time	600
max_lease_time	3600
min_lease_time	300
topoactive	0
dhcpdefdomain	example.com
defdomain	example.com
topofrom	nobody.topo@example.com
topoto	noc@example.com another@example.com
topographddelay	5
toposendddelay	5
topomaxstatus	100
sensorexpire	30
modeqexpire	30
ifchangeexpire	30
fullrancidmin	2
fullrancidmax	4
macactive	0
ldapurl	ldap://ldap.example.com/
ldapbinddn	cn=admin,ou=accounts,ou=operators,dc=example,dc=com
ldapbindpw	*
ldapbasedn	ou=people,dc=example,dc=com
ldapsearchlogin	(&(objectClass=People)(uid=%s))
ldapattrlogin	uid
ldapattrpassword	userPassword
ldapattrname	sn
ldapattrgivenname	givenName
ldapattrmail	mail
ldapattrphone	telephoneNumber
ldapattrmobile	
ldapattrfax	facsimileTelephoneNumber
ldapattraddr	postalAddress postalCode l
authpgminpwlen	8
authpgmaxpwlen	16
authpgmailfrom	nobody.netmagis@example.com
authpgmailreplyto	nobody.netmagis@example.com
authpgmailcc	
authpgmailbcc	
authpgmailsubject	Password change
authpgmailbody	Password changed (%2$s) for user %1$s. Best regards.
authpggroupes	netmagis
\.

    -- id 0 is used in zone creation script
    COPY dns.hinfo (texte, tri, present) FROM stdin;
Unspecified	0	0
PC/Windows	10	1
PC/Unix	20	1
Macintosh/MacOS	30	1
Other/Unix	50	1
Printer	70	1
Network equipment	100	1
\.

    COPY dns.dhcp (generer) FROM stdin;
0
\.

    COPY topo.lastrun (date) FROM stdin;
\N
\.

    COPY topo.ignoreequsers (login) FROM stdin;
conf
\.

    COPY topo.vlan (vlanid, descr) FROM stdin;
1	default
\.

    COPY topo.eqtype (type) FROM stdin;
cisco
juniper
hp
\.

    COPY topo.confcmd (idtype, action, rank, model, command) FROM stdin;
1	prologue	100	.*	configure terminal
1	ifreset	90	.*29.0.*	interface %1$s\ndefault switchport nonegotiate\ndefault switchport trunk allowed vlan\ndefault switchport trunk native vlan\ndefault switchport access vlan\ndefault switchport mode
1	ifreset	100	.*	interface %1$s\nno switchport\nswitchport voice vlan none\nswitchport
1	ifdisable	100	.*	interface %1$s\nshutdown
1	ifenable	100	.*	interface %1$s\nno shutdown
1	ifaccess	100	.*	interface %1$s\nswitchport mode access\nswitchport access vlan %2$s\nspanning-tree portfast 
1	ifvoice	100	.*	interface %1$s\nswitchport voice vlan %2$s
1	ifdesc	100	.*	interface %1$s\ndescription %2$s
1	epilogue	100	.*	line con 0\nexit\nexit\nwrite memory 
2	prologue	100	.*	configure
2	ifreset	100	.*	delete interfaces %1$s unit 0 family ethernet-switching\ndelete ethernet-switching-options voip interface %1$s
2	ifdisable	100	.*	set interfaces %1$s disable
2	ifenable	100	.*	delete interfaces %1$s disable
2	ifaccess	100	.*	set interfaces %1$s unit 0 family ethernet-switching port-mode access\nset interfaces %1$s unit 0 family ethernet-switching vlan members %2$s
2	ifdesc	100	.*	set interfaces %1$s description "%2$s"
2	ifvoice	100	.*	set interfaces %1$s unit 0 family ethernet-switching\nset ethernet-switching-options voip interface %1$s vlan %2$s
2	epilogue	100	.*	commit\nexit configuration
3	prologue	100	.*	configure terminal
3	resetvlan	100	.*	vlan %2$s\nno tagged %1$s\nno untagged %1$s
3	ifenable	100	.*	interface %1$s\nenable
3	ifdisable	100	.*	interface %1$s\ndisable
3	ifaccess	100	.*	vlan %2$s\nuntagged %1$s
3	ifvoice	100	.*	vlan %2$s\ntagged %1$s
3	ifdesc	100	.*	interface %1$s\nname "%2$s"
3	epilogue	100	.*	vlan 1\nexit\nexit\nwrite memory
\.

    COPY topo.dotattr (rank, type, regexp, gvattr) FROM stdin;
10100	2	juniper/M.*	shape=circle\nstyle=filled fillcolor=lightgrey\nfixedsize height=1
10200	2	cisco/12000.*	shape=doublecircle\nstyle=filled fillcolor=lightgrey\nfixedsize height=1
10300	2	juniper/EX8.*	shape=box style=filled fillcolor=lightblue
10400	2	juniper/Chassis.*	shape=box style=filled fillcolor=lightblue
10500	2	cisco/WS-C45.*	shape=box style=filled fillcolor=lightblue
10600	2	cisco/WS-C37.*	shape=box style=filled fillcolor=lightblue height=.25
10700	2	cisco/WS-C29.*	shape=box style=filled fillcolor=lightblue height=.25
10800	2	cisco/WS-.*PS	shape=box style=filled fillcolor=yellow height=.25
10900	2	cisco/37.*	shape=octagon style=filled fillcolor=orange1 height=.25
11000	2	cisco/38.*	shape=octagon style=filled fillcolor=orange1
11100	2	cisco/.*routeur	shape=circle\nstyle=filled fillcolor=lightgrey\nfixedsize height=1
11200	2	cisco/1605.*	shape=circle\nstyle=filled fillcolor=lightgrey\nfixedsize height=1
11300	2	cisco/1721.*	shape=circle\nstyle=filled fillcolor=lightgrey\nfixedsize height=1
11400	2	cisco/7206.*	shape=circle\nstyle=filled fillcolor=lightgrey\nfixedsize height=1
11500	2	juniper/EX2.*	shape=box style=filled fillcolor=SteelBlue height=.25
11600	2	juniper/EX4.*	shape=box style=filled fillcolor=SteelBlue height=.25
11900	2	fwroutebridge.*	shape=Mcircle\nstyle=filled fillcolor=tomato\nheight=1
13000	2	fwroute.*	shape=circle\nstyle=filled fillcolor=tomato\nheight=1
13100	2	fw.*	shape=box style=filled fillcolor=tomato height=.25
13200	2	switch.*	shape=box style=filled fillcolor=lightgrey height=.25
13300	2	hp.*	shape=box style=filled fillcolor=pink height=.25
13400	2	.*	shape=triangle
20100	3	router	shape=circle\nstyle=filled fillcolor=lightgrey\nfixedsize height=1.5
20200	3	host	shape=box\nstyle=filled fillcolor=lightblue\nheight=.25
20300	3	cloud	shape=ellipse\nstyle=filled fillcolor=palegreen\nwidth=1.5
\.

    COPY pgauth.realm (realm, descr, admin) FROM stdin;
authadmin	Administrators of internal PostgreSQL auth	1
netmagis	Netmagis users	0
\.

    COPY global.groupe (nom, admin) FROM stdin;
wheel	1
\.
EOF

    psql --no-psqlrc --quiet -c "INSERT INTO global.config
					VALUES ('defuser', '$defuser')"
}

##############################################################################
# Create Netmagis users
##############################################################################

netmagis_create_user ()
{
    user="$1"
    psql --no-psqlrc --quiet --file - <<EOF
    INSERT INTO pgauth.user (login, password, nom, prenom)
	VALUES ('$user', '*', 'Boss', 'Joe') ;
    INSERT INTO pgauth.member (login, realm) VALUES ('$user', 'authadmin') ;
    INSERT INTO pgauth.member (login, realm) VALUES ('$user', 'netmagis') ;
    INSERT INTO global.corresp (login, present, idgrp) VALUES ('$user', 1, 1) ;
EOF

    if [ "$pwgen" != "" -a "$crypt" != "" ]
    then
	adminpw=`$pwgen`
	cmd=`printf "$crypt" $adminpw`
	cryptpw=`$cmd`
	psql --no-psqlrc --quiet -c "UPDATE pgauth.user
					SET password = '$cryptpw'
					WHERE login = '$user'"
	echo "Password for Netmagis user '$user' is '$adminpw'." >&2
    fi

}

##############################################################################
# Create mac database
##############################################################################

create_mac ()
{
    echo "Creating MAC database as '$macdbname'"

    PGHOST="$macdbhost"
    PGPORT="$macdbport"
    PGDATABASE="$macdbname"
    PGUSER="$macdbuser"
    PGPASSWORD="$macdbpassword"
    export PGHOST PGPORT PGDATABASE PGUSER PGPASSWORD

    ###############################
    # Create mac database
    ###############################

    if db_create_if_not_exists
    then :
    else
	echo "Erreur while creating database '$PGDATABASE'" 2>&1
	exit 1
    fi

    # exit if schema already exist
    if db_test_schemas "mac"
    then
	exit 1
    fi

    ###############################
    # Initialize mac database schemas and contents
    ###############################

    create_mac_schemas
}

##############################################################################
# Mac database 
##############################################################################

create_mac_schemas ()
{
    psql --no-psqlrc --quiet --file - <<'EOF' 2>&1 | grep -v 'NOTICE: .* will create implicit'

    CREATE SCHEMA mac ;

    -- Generic session table which will be used to associate some
    -- data (ip-mac, port-mac-vlan) with a start and a stop date
    CREATE TABLE mac.session (
	start		TIMESTAMP,  	-- session start
	stop		TIMESTAMP,  	-- session stop
	src		INET,		-- origin of the information
	closed		BOOLEAN		-- 1 if session timed out
    ) ;

    -- Postgresql composite type to instantiate a generic session
    -- as an IP-MAC session
    CREATE TYPE mac.ipmac_t AS (
	ip		INET,		-- IP address
	mac		MACADDR		-- MAC address
    );

    -- IP-MAC session instance
    CREATE TABLE mac.ipmac (
	data		mac.ipmac_t
    ) INHERITS (mac.session) ;

    CREATE INDEX ON mac.ipmac (src);
    CREATE INDEX ON mac.ipmac (data);
    CREATE INDEX ON mac.ipmac (closed);
    CREATE INDEX ON mac.ipmac (stop);
    CREATE INDEX ON mac.ipmac (start);
    CREATE INDEX ON mac.ipmac ( ((data).ip) );
    CREATE INDEX ON mac.ipmac ( ((data).mac) );

    CREATE TYPE mac.portmac_t AS (
	mac		MACADDR,	-- MAC address
	port		TEXT,		-- port name
	vlanid		INTEGER		-- VLAN id
    ) ;
    CREATE TABLE mac.portmac (
	data		mac.portmac_t
    ) INHERITS (mac.session) ;

    CREATE INDEX ON mac.portmac (src);
    CREATE INDEX ON mac.portmac (data);
    CREATE INDEX ON mac.portmac (closed);
    CREATE INDEX ON mac.portmac (stop);
    CREATE INDEX ON mac.portmac (start);
    CREATE INDEX ON mac.portmac ( ((data).mac) );
    CREATE INDEX ON mac.portmac ( ((data).port) );
    CREATE INDEX ON mac.portmac ( ((data).vlanid) );
EOF
}

##############################################################################
# Main program
##############################################################################

#
# Initialize environnement
#

init_env

#
# Syntax checking
#       
 
args=`getopt h $*`

if [ $? != 0 ]
then usage
fi

set -- $args

while true
do
    case "$1" in
	-h) usage
	    exit 0
	    ;;
	--) shift
	    break
	    ;;
    esac
done

if [ $# = 0 ]
then set netmagis mac
fi

#
# Check actions
#

for action
do
    case "$action" in
	netmagis|mac) ;;
	*)
	    echo "Unknown action '$action'" >&2
	    usage
	    exit 1
	    ;;
    esac
done

#
# Do actions
#

for action
do
    case "$action" in
	netmagis) create_netmagis ;;
	mac)      create_mac ;;
    esac
done


exit 0
